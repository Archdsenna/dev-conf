" Mac

" vim 动词(动词表示对文本的操作)
" +----------+----------+--------------------------------------------------------+
" |d         |delete    |删除(不会进插入模式)                                    |
" +----------+----------+--------------------------------------------------------+
" |c         |change    |修改(会进插入模式)                                      |
" +----------+----------+--------------------------------------------------------+
" |y         |yank      |复制                                                    |
" +----------+----------+--------------------------------------------------------+
" |v         |visual    |选中                                                    |
" +----------+----------+--------------------------------------------------------+
" |p         |put       |粘贴                                                    |
" +----------+----------+--------------------------------------------------------+
"

" vim 名词(表示待编辑的文本对象)
" +----------+----------+--------------------------------------------------------+
" |h/l       |char      |一个字符(左/右侧)                                       |
" +----------+----------+--------------------------------------------------------+
" |w         |world     |一个单词                                                |
" +----------+----------+--------------------------------------------------------+
" |s         |sentence  |一个句子(以英文'.'结束作为一个句子)                     |
" +----------+----------+--------------------------------------------------------+
" |p         |paragraph |一个段落(不包含空行的内容块作为一个段落)                |
" +----------+----------+--------------------------------------------------------+
"

" vim 修饰符(可以理解为vim 介词, 表示待编辑文本的范围或者位置)
" +----------+----------+--------------------------------------------------------+
" |i         |inside    |表示在...之内(带i的命令不会包含周围空格)                |
" +----------+----------+--------------------------------------------------------+
" |a         |around    |表示环绕                                                |
" +----------+----------+--------------------------------------------------------+
" |t         |till      |向后移动到某个字符之前(不包括该字符)                    |
" +----------+----------+--------------------------------------------------------+
" |T         |Till      |向前移动到某个字符之后                                  |
" +----------+----------+--------------------------------------------------------+
" |f         |find      |向后移动到某个字符(包括该字符)                          |
" +----------+----------+--------------------------------------------------------+
" |F         |Find      |向前移动到某个字符                                      |
" +----------+----------+--------------------------------------------------------+
"

" vim 光标移动
" +----------+-------------------------------------------------------------------+
" |;         |重复执行上一次光标移动                                             |
" +----------+-------------------------------------------------------------------+
" |,         |反方向重复执行上一次光标移动(已自定义映射为;;)                     |
" +----------+-------------------------------------------------------------------+
"

" vim 选择缩进
" +----------+-------------------------------------------------------------------+
" |shift + < |向左缩进,在要对齐的地方按Ctrl+v标记位置,然后按Shift+<左缩进到该位置|
" +----------+-------------------------------------------------------------------+
" |shift + > |向右缩进,按Ctrl+v选中要缩进的行,然后按Shift+>向右缩进              |
" +----------+-------------------------------------------------------------------+
"

" vim 命令(动词+介词+名词):[删除|替换|复制|选中|移动]
" +----------+-------------------------------------------------------------------+
" |C         |删除光标到行尾的内容,并进入插入模式                                |
" +----------+-------------------------------------------------------------------+
" |dw        |删除光标后的单词及其后空格, d2w:删除2个单词及每个单词后空格        |
" +----------+-------------------------------------------------------------------+
" |diw       |删除光标所在位置的单词, 不删除其后空格                             |
" +----------+-------------------------------------------------------------------+
" |daw       |删除光标所在位置的单词, 及其后空格,d2aw:删除2个单词及每个单词后空格|
" +----------+-------------------------------------------------------------------+
" |di{       |删除{}内的内容(其他括号同理)                                       |
" +----------+-------------------------------------------------------------------+
" |da{       |删除{},及括号内的内容                                              |
" +----------+-------------------------------------------------------------------+
" |de        |删除光标到单词尾的内容(不包含单词后空格)    Tips: w带空格,e不带空格|
" +----------+-------------------------------------------------------------------+
" |dj / dk   |删除光标行+上/下一行                                               |
" +----------+-------------------------------------------------------------------+
" |dh / dl   |删除光标左/右侧的1个字符(删除2个: d2h/d2l)                         |
" +----------+-------------------------------------------------------------------+
" |dt+位置字符|删除到位置字符之前(不包含位置字符)                                |
" +----------+-------------------------------------------------------------------+
" |cw        |替换光标后的单词( 会进入插入模式 )                                 |
" +----------+-------------------------------------------------------------------+
" |ciw       |替换光标处的完整单词( 会进入插入模式 )                             |
" +----------+-------------------------------------------------------------------+
" |c2h / c2l |替换光标左侧/右侧的2个字符(会进入插入模式)                         |
" +----------+-------------------------------------------------------------------+
" |yj / yk   |复制光标行+上/下一行                                               |
" +----------+-------------------------------------------------------------------+
" |yh / yl   |复制光标左侧/右侧的1个字符(复制2个: y2h/y2l)                       |  
" +----------+-------------------------------------------------------------------+
" |ye        |复制光标到行尾的所有内容                                           |
" +----------+-------------------------------------------------------------------+
" |yt+位置字符|复制到位置字符之前(不包含位置字符)                                |
" +----------+-------------------------------------------------------------------+
" |yf+位置字符|复制到位置字符(包含位置字符)                                      |
" +----------+-------------------------------------------------------------------+
" |viw       |选中光标处一个单词(不包含其后空格)                                 |
" +----------+-------------------------------------------------------------------+
" |v2b       |向前选中2个单词                                                    |
" +----------+-------------------------------------------------------------------+
" |ve        |选中光标到行尾的所有内容(v模式下e可连续按)                         |
" +----------+-------------------------------------------------------------------+
" |xp        |交换2个字符的位置                                                  |
" +----------+-------------------------------------------------------------------+
" |ddp       |交行2行的位置                                                      |
" +----------+-------------------------------------------------------------------+
" |ea        |在单词末尾进入插入模式                                             |
" +----------+-------------------------------------------------------------------+
" |f+位置字符|移动第1个匹配的字符处,例如:fa,移动到第一个a字符,再按fa移动到下一个a|
" +----------+-------------------------------------------------------------------+
" |t+位置字符|移动到位置字符之前                                                 |
" +----------+-------------------------------------------------------------------+
"

" vim 前缀命令g:g在Vim中是一个非常灵活的前缀命令,它可以与其他命令一起使用来实现各种功能
" +----------+-------------------------------------------------------------------+
" |gg        |跳转到文件开头(G跳转到文件末尾)                                    |
" +----------+-------------------------------------------------------------------+
" |gf        |打开光标所在文件路径的文件                                         |
" +----------+-------------------------------------------------------------------+
" |ge        |移动光标到前一个单词的末尾                                         |
" +----------+-------------------------------------------------------------------+
" |gu        |将单词转为全小写(guw:光标后小写, guiw:光标处单词转小写)| 字母大小写|
" +----------+-------------------------------------------------------| 互相转换用|
" |gU        |将单词转为全大写(gUw:光标后大写, gUiw:光标处单词转大写)| ~命令     |
" +----------+-------------------------------------------------------------------+
"

" vim 命令快捷键总结 : 功能自上而下依次为[插入|删除|替换|剪切|复制|粘贴|选中|撤销|移动]
" +----------+-------------------------------------------------------------------+
" |命令      |功能                                                               |
" +----------+-------------------------------------------------------------------+
" |a         |在当前字符后, 进入[插入]模式              6ax: 在当前字符后插入6个x|
" +----------+-------------------------------------------------------------------+
" |A         |在当前行尾，进入[插入]模式                                         |
" +----------+-------------------------------------------------------------------+
" |o         |在下一行, 进入插入模式                                             |
" +----------+-------------------------------------------------------------------+
" |O         |在上一行, 进入插入模式                                             |
" +----------+-------------------------------------------------------------------+
" |i         |在当前位置, 进入插入模式                      6ix: 在光标处插入6个x|
" +----------+-------------------------------------------------------------------+
" |I         |在当前行行首, 进入插入模式                                         |
" +----------+-------------------------------------------------------------------+
" |s         |清空当前字符, 进入插入模式(2s,删除光变后2个字符并进入插入模式)     |
" +----------+-------------------------------------------------------------------+
" |S         |清空当前行, 进入插入模式(与cc效果相同)                             |
" +----------+-------------------------------------------------------------------+
" |x         |删除光标后的1个字符(不进入任何模式), 3x: 删除光标后的3个字符       |
" +----------+-------------------------------------------------------------------+
" |X         |删除光标前的1个字符, 2X: 删除光标前的2个字符                       |
" +----------+-------------------------------------------------------------------+
" |r         |精确替换一个字符(不进入输入模式),可视模式下会把选中内容全部替换    |
" +----------+-------------------------------------------------------------------+
" |R         |在当前行进入替换模式，直接输入替换的文本覆盖原文本                 |
" +----------+-------------------------------------------------------------------+
" |C         |删除从当前光标位置到本行末尾的所有字符, 并进入插入模式             |
" +----------+-------------------------------------------------------------------+
" |D         |剪切从当前光标位置到本行末尾的所有字符                             |
" +----------+-------------------------------------------------------------------+
" |Y         |复制整行(等同yy)                                                   |
" +----------+-------------------------------------------------------------------+
" |p         |在当前行下方粘贴, 6p:粘贴6行                                       |
" +----------+-------------------------------------------------------------------+
" |P         |在当前行上方粘贴                                                   |
" +----------+-------------------------------------------------------------------+
" |V         |进入可视行模式,可以按行选中文本                                    |
" +----------+-------------------------------------------------------------------+
" |ctrl+v    |进入可视块模式,可以选择多行中的相同列                              |
" +----------+-------------------------------------------------------------------+
" |u / Ctrl+r|撤销修改/恢复修改(Ctrl+r已自定义映射为rr)                          |
" +----------+-------------------------------------------------------------------+
" |b         |向左按单词移动                                                     |
" +----------+-------------------------------------------------------------------+
" |w         |向右按单词移动                                                     |
" +----------+-------------------------------------------------------------------+
" |e         |移动到单词末尾                                                     |
" +----------+-------------------------------------------------------------------+
" |h         |向左按字符移动, 2h为向左移动两个字符                               |
" +----------+-------------------------------------------------------------------+
" |l         |向右按字符移动, 2l为向右移动两个字符                               |
" +----------+-------------------------------------------------------------------+
" |j         |向下移动一行(注意:自定义映射已修改为j向上移动)                     |
" +----------+-------------------------------------------------------------------+
" |k         |向上移动一行(注意:自定义映射已修改为k向下移动)                     |
" +----------+-------------------------------------------------------------------+
"

" vim 个性化快捷键总结(自定义的快捷映射)
" +----------+-------------------------------------------------------------------+
" |命令      |功能                                                               |
" +----------+-------------------------------------------------------------------+
" |q         |:q                                                                 |
" +----------+-------------------------------------------------------------------+
" |aa/ee     |光标回行首/尾                                                      |        
" +----------+-------------------------------------------------------------------+
" |ai/ei     |光标回行首/尾+进入插入模式                                         |        
" +----------+-------------------------------------------------------------------+
" |as        |光标回行首+删除第1个字符+并进入插入模式                            |
" +----------+-------------------------------------------------------------------+
" |a+空格    |删除光标后1个字符+加空格+并进入插入模式                            |
" +----------+-------------------------------------------------------------------+
" |sh        |水平分屏                                                           |
" +----------+-------------------------------------------------------------------+
" |sv        |垂直分屏                                                           |
" +----------+-------------------------------------------------------------------+
" |ya / yb   |复制全文到 vim剪贴板 / 系统剪贴板                                  |
" +----------+-------------------------------------------------------------------+
" |da / db   |删除全文到 vim剪贴板 / 系统剪贴板                                  |
" +----------+-------------------------------------------------------------------+
" |yee / ys  |复制光标到行尾内容到 vim剪贴板 / 系统剪贴板                        |
" +----------+-------------------------------------------------------------------+
" |dee / ds  |删除光标到行尾内容到 vim剪贴板 / 系统剪贴板                        |
" +----------+-------------------------------------------------------------------+
" |dy        |删除选中的内容到系统剪贴板(y=s'y'stem)                             |
" +----------+-------------------------------------------------------------------+
" |hi        |逆序显示历史命令(hi=history)                                       |
" +----------+-------------------------------------------------------------------+
" |jk        |替代Esc(返回Normal模式/退出Visual模式/退出命令行模式)              |
" +----------+-------------------------------------------------------------------+
" |rr        |取消撤销(u)操作                                                    |
" +----------+-------------------------------------------------------------------+
" |ej / ek   |在上/下一行末尾进入插入模式                                        |
" +----------+-------------------------------------------------------------------+
" |hj / hk   |在上/下一行开头进入插入模式, h=head                                |
" +----------+-------------------------------------------------------------------+
" |cj / ck   |删除上/下一行(光标保持在当前行)                                    |
" +----------+-------------------------------------------------------------------+
" |sj / sk   |清空上/下一行内容(光标保持在当前行)                                |
" +----------+-------------------------------------------------------------------+
" |ew        |写入当前修改内容(等价":w", ew=ensure write, 即确定写入)            |
" +----------+-------------------------------------------------------------------+
" |we        |保存并退出 (we=write exit, 写入后退出)                             |
" +----------+-------------------------------------------------------------------+
" |si        |清除光标到行尾内容,并进入插入模式(光标为删除前的位置)              |
" +----------+-------------------------------------------------------------------+
" |sl        |清空当前行内容(space line)                                         |
" +----------+-------------------------------------------------------------------+
" |空格+i    |清空当前行,并进入插入模式                                          |
" +----------+-------------------------------------------------------------------+
" |tk        |在下一行进入插入模式,并缩进一个tab                                 |
" +----------+-------------------------------------------------------------------+
" |hm / hn   |水平分屏增大/减小                                                  |
" +----------+-------------------------------------------------------------------+
" |vm / vn   |垂直分屏增大/减小                                                  |
" +----------+-------------------------------------------------------------------+
" |vh        |2个垂直分屏转水平分屏(自定义映射wh/wl也可以)                       |
" +----------+-------------------------------------------------------------------+
" |hv        |2个水平分屏转垂直分屏(自定义映射wj/wk也可以)                       |
" +----------+-------------------------------------------------------------------+
" |wh/wj/wk/wl|当前分屏左/上/右/下移                                             |
" +----------+-------------------------------------------------------------------+
" |eh / el   ||开启光标所在行/列高亮,再按一次关闭                                |
" +----------+-------------------------------------------------------------------+
" |et        |同时开启行列高亮                                                   |
" +----------+-------------------------------------------------------------------+
" |eu        |退出当前buffer, eu=exit b'u'ffer                                   |
" +----------+-------------------------------------------------------------------+
" |bl        |显示buffer列表,按Enter跳转,按c关闭,按Tab多选      (bl=buffer list) |
" +----------+-------------------------------------------------------------------+
" |bj        |显示buffer列表,为每个buffer显示位置字符,按字符跳转(bj=buffer jump) |
" +----------+-------------------------------------------------------------------+
" |wr        |恢复上次窗口布局                                                   |
" +----------+-------------------------------------------------------------------+
" |en        |vim帮助文档txt跳转到标题对应的内容(原ctrl+]命令)                   |
" +----------+-------------------------------------------------------------------+
" |ne        |返回到标题(原ctrl+t命令)                                           |
" +----------+-------------------------------------------------------------------+
" |md        |进入vim命令行模式                                                  |
" +----------+-------------------------------------------------------------------+
" |lr        |返回上一次光标所在行                                               |
" +----------+-------------------------------------------------------------------+
" |aj / ak   |光标跳转到上/下一个历史编辑位置,a=at                               |
" +----------+-------------------------------------------------------------------+
" |bn        |新建无文件缓冲区并命名,bn=buffer new                               |
" +----------+-------------------------------------------------------------------+
" |hf        |无文件缓冲区保存为文件,hf=hold file, hold=保存                     |
" +----------+-------------------------------------------------------------------+
" |er        |无文件缓冲区重命名                                                 |
" +----------+-------------------------------------------------------------------+
" |re        |对已存在的文件重命名, re=rename                                    |
" +----------+-------------------------------------------------------------------+
" |cl        |清空命令行显示的消息                                               |
" +----------+-------------------------------------------------------------------+
" |go        |在上方 [ 上方无空行 ] 增加三行空行,并将光标位于中行, 进入插入模式  |
" +----------+-------------------------------------------------------------------+
" |gu        |在下方 [ 下方无空行 ] 增加三行空行,并将光标位于中行, 进入插入模式  |
" +----------+-------------------------------------------------------------------+
" |ao        |在上方 [ 上方有空行 ] 增加三行空行,并将光标位于中行, 进入插入模式  |
" +----------+-------------------------------------------------------------------+
" |bo        |在下方 [ 下方有空行 ] 增加三行空行,并将光标位于中行, 进入插入模式  |
" +----------+-------------------------------------------------------------------+
" |bm        |跳转到匹配的括号(需将光标置于括号上), bm=bracket match             |
" +----------+-------------------------------------------------------------------+
" 

" 命令助记规则表(todo: 把所有命令都补充上)
" +-----------------------------------+------------------------------------+--------------------------------------+-----------------+
" |快捷键组合类型                     |示例                                |解释                                  |说明             |
" +-----------------------------------+------------------------------------+--------------------------------------+-----------------+
" |控制键 + 单词头¹/单词尾²           |¹ 空格+b : 显示buffer列表           |窗口控制键(空格) + buffer 单词头      |                 |
" |                                   |² 空格+d : 列表显示之前使用的命令   |窗口控制键(空格) + command单词尾      |                 |
" +-----------------------------------+------------------------------------+--------------------------------------+-----------------+
" |动词(单词首字母) + 名词            |g+Enter                             |generate + Enter, 产生一个换行        |与vim动词无关,本 |     
" |                                   |g+空格                              |generate + 空格 , 产生一个空格        |组快捷键仅适用于 |
" |                                   |d+Enter                             |delete + Enter  , 删除光标后的换行    |Normal模式       |
" +-----------------------------------+------------------------------------+--------------------------------------+-----------------+
"
" vim 插件快捷键总结
" -------------------------------------                    按插件归类(插件按英文首字母排序)
" +----------+----------+--------+--------- ----+
" |  插  件  |  快捷键  |  功能  |  快捷键总数  |
" +----------+----------+--------+--------------+
" 
" +----------+----------+--------------+
"

" -------------------------------------                    按前缀键归类
" +----------+----------+---------------------+--------+
" |  前缀键  |  触发键  |  所属插件  |  组合  |  功能  |        
" +----------+----------+------------+--------+--------+
" 

" mac nvim支持python3
" =============================================================================
" 步骤:
"   1. 系统需要先完成安装python3
"       $ brew install python3
"   2. 安装nvim自带的python支持(Neovim与Python交互需要安装pynvim(之前称为neovim)库)
"       2.1 因为mac不允许直接通过pip方式下载python组件以防止损坏系统环境,所以通过python的虚拟环境完成下载,如下:
"           $ python3 -m venv ~/.venv               " 创建一个python虚拟环境
"           $ source ~/.venv/bin/activate           " 激活虚拟环境
"           $ python3 -m pip install neovim(pynvim) " 下载nvim的python支持
"           $ which python3                         " 在虚拟环境中查看python3的安装路径
"           $ 在init.vim中将python3安装路径赋值给g:python3_host_prog变量
let g:python3_host_prog = '~/.venv/bin/python3'

" 通用配置
" =============================================================================
let mapleader = ","      " 定义<leader>键
set nocompatible         " 设置不兼容原始vi模式
filetype on              " 设置开启文件类型侦测
filetype plugin on       " 设置加载对应文件类型的插件。在~/.vim/ftplugin/下创建不同语言的缩进格式文件，例如c为c.vim。
set noeb                 " 关闭错误的提示
syntax enable            " 开启语法高亮功能
syntax on                " 自动语法高亮
set t_Co=256             " 开启256色支持
" set cmdheight=2          " 设置命令行的高度
set showcmd              " select模式下显示选中的行数
set ruler                " 总是显示光标位置
set laststatus=2         " 总是显示状态栏
set number               " 开启行号显示
set cursorline           " 高亮显示当前行
set showmatch            " 自动高亮匹配的括号
set whichwrap+=<,>,h,l   " 设置光标键跨行
set ttimeoutlen=0        " 设置<ESC>键响应时间
set backspace=2          " 解决vim由于兼容vi导致back删除键失效
set hidden               " 允许不保存切换buffer
set autoread             " 文件在Vim之外修改过，自动重新读入
set helpheight=999       " 查看帮助文档全屏
" set sidescroll=10      " 设置Vim中侧向滚动的粒度
set scroll=20            " 设置鼠标滚动时的滚动粒度(Max:40)
set scrolloff=20         " 进行行滚动时，当前行始终保持在屏幕中间
set signcolumn=auto:4    " 设置左侧符号区域最多显示4个字符(auto表示有标志才显示,没有不显示)
set textwidth=1000       " 设置每行文本的宽度最大为1000个字符(避免文本在超过这个值时被自动折行,所以设置一个较大的值)
set splitright           " 设置新垂直窗口在右侧
set splitbelow           " 设置新水平窗口在下面
set virtualedit=all      " 设置光标可在buffer的所有区域移动
set history=3000         " 设置vim最多保留的历史命令数


" 代码缩进和排版
" =============================================================================
set autoindent           " 与前一行同样等级缩进
set cindent              " 设置使用C/C++语言的自动缩进方式
set smartindent          " 智能的选择对齐方式
filetype indent on       " 自适应不同语言的智能缩进
set expandtab            " tab=空格
set tabstop=4            " tab等于4个空格(不同语言tab的空格数在语言类型文件中定义)
set shiftwidth=4         " 自动缩进空格数(换行时自动缩进的空格数)
set nowrap               " 禁止折行
set nofoldenable         " 禁用折叠代码

" vim 命令补全
" =============================================================================
" vim 控制命令行补全
set wildmenu                         " 命令模式下补全以菜单形式显示
set wildoptions=pum                  " 命令行模式候选项竖排列表显示
set wildmode=longest,full            " 自动补全时优先显示最长的匹配项，然后显示所有可能的匹配项
" Vim 中控制自动补全行为
set completeopt-=preview             " 补全时不显示窗口，只显示补全列表
set completeopt=menu,menuone,longest " 在自动补全时显示菜单，并在只有一个匹配项时自动完成，同时显示最长的匹配项


" 搜索设置
" =============================================================================
" set hlsearch           " 高亮显示搜索结果
set nohlsearch           " 关闭高亮搜索结果
set incsearch            " 输入搜索模式时，每输入一个字符，就自动跳到第一个匹配的结果
set ignorecase           " 搜索时大小写不敏感
set smartcase            " 智能大小写搜索

" vim 主题设置
" =============================================================================
set background=light


" vim 插件列表(外部插件)
" =============================================================================
call plug#begin('~/.config/nvim/plugged') " 设置nvim下vim-plug下载插件的路径
" -------------------------------------                                 git 相关
Plug 'airblade/vim-gitgutter'      " 实时显示git文件修改的地方
Plug 'tpope/vim-fugitive'          " git插件(显示branch,支持vim内使用git)
Plug 'rbong/vim-flog'              " 查看git graph
Plug 'zivyangll/git-blame.vim'     " 显示git blame
Plug 'christoomey/vim-conflicted'  " 有助于解决git合并冲突(未学)

" -------------------------------------                                 任务构建
Plug 'skywind3000/asynctasks.vim'  " vim内完成编辑&编译&运行
Plug 'skywind3000/asyncrun.vim'    " 同上

" -------------------------------------                                 调    试
" Plug 'lldb-tools/vim-lldb'       " 等待社区修复使用python3.12导致的
                                   " lldb插件问题

" -------------------------------------                                 代码注释
Plug 'tomtom/tcomment_vim'         " 快速注释代码

" -------------------------------------                                 头文件切换
Plug 'vim-scripts/a.vim'           " C代码,.c与.h切换

" -------------------------------------                                 vim 美化
Plug 'vim-airline/vim-airline'     " vim 状态栏美化
Plug 'vim-airline/vim-airline-themes' " vim airline主题
Plug 'flazz/vim-colorschemes'      " vim 状态栏主题

" -------------------------------------                                 语法标签类
Plug 'preservim/tagbar'            " 显示类/方法/变量
Plug 'kshenoy/vim-signature'       " 在当前行添加一个标签(mark)

" -------------------------------------                                 自动补全
Plug 'neoclide/coc.nvim', {'branch': 'release'} " 基于LSP自动补全
Plug 'jiangmiao/auto-pairs'        " 自动补全括号对
Plug 'tpope/vim-endwise'           " ifdef/endif补全
Plug 'SirVer/ultisnips'            " 支持快速操作代码片段的选项”和插值
Plug 'honza/vim-snippets'          " 提供许多常用编程语言代码片段

" -------------------------------------                                 语法树支持
Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'} 
                                   " nvim中使用treesitter(为源文件构建
                                   " 具体的语法树,并在源文件编辑时有效
                                   " 地更新语法树)
Plug 'nvim-treesitter/nvim-treesitter-textobjects' 
                                   " 使用treesitter处理textobjects对象
Plug 'nvim-treesitter/nvim-treesitter-context' 
                                   " 基于treesitter 语法树来显示代码的
                                   " 上下文信息(在顶部显示当前在所在的
                                   " 函数、类等代码数据信息

" -------------------------------------                                 文件管理
Plug 'preservim/nerdtree'          " 显示文件目录列表
Plug 'Xuyuanp/nerdtree-git-plugin' " 显示 NERDTree 中文件和文件夹的 
                                   " Git 状态标志
Plug 'tiagofumo/vim-nerdtree-syntax-highlight' " NerdTree文件类型高亮
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } } " (插件作用同下)
Plug 'junegunn/fzf.vim'            " vim 快速搜索并打开一个文件，支持
                                   " 文件内容预览

" -------------------------------------                                 搜    索
" Plug 'junegunn/vim-slash'          " 优化搜索,移动光标后清除高亮(目前
                                   " 没起作用)

" -------------------------------------                                 文本操作
Plug 'machakann/vim-sandwich'      " 添加/替换/删除成对的符号(含括/引号)
Plug 'godlygeek/tabular'           " 快速对齐文本
Plug 'tpope/vim-abolish'           " 处理单词变体(修改大小写、命名格式)
                                   " [未学]
Plug 'brooth/far.vim'              " 文本查找与替换(未学)
Plug 'tommcdo/vim-exchange'        " 简单文本交换(快速交换两个单词/句子)
Plug 'terryma/vim-expand-region'   " 扩展选中的文本范围到下一个最大的
                                   " 文本对象(字符->单词->行->段->文件)

" -------------------------------------                                 文本比较
Plug 'AndrewRadev/linediff.vim'    " 快速比较两个文本块

" -------------------------------------                                 Muti-Cursor
Plug 'terryma/vim-multiple-cursors'

" -------------------------------------                                 快速笔记
Plug 'mtth/scratch.vim'            " 顶部临时开个窗口记笔记,切换窗口会
                                   " 自动关闭                                   

" -------------------------------------                                 剪贴板
Plug 'christoomey/vim-system-copy' " 可以将内容复制到系统剪贴板(终端
                                   " 不同tab中的vim可以互相复制粘贴)
" 对于通过远程SSH运行Vim的情况下执行复制非常有用(当前未启用)
" Plug 'ojroques/vim-oscyank', {'branch': 'main'}                                            

" -------------------------------------                                 寄存器
Plug 'junegunn/vim-peekaboo'       " 打开vim的寄存器列表,从中选取曾经
                                   " 复制或者删除的内容

" -------------------------------------                                 quickfix列表
Plug 'sk1418/QFGrep'               " 可以在quickfix窗口中过滤结果
Plug 'stefandtw/quickfix-reflector.vim' " 可以编辑quickfix窗口,然后将
                                        " 内容写回buffer

" -------------------------------------                                 事务管理(Todolist)
Plug 'jceb/vim-orgmode'

" -------------------------------------                                 日期管理
Plug 'tpope/vim-speeddating'       " 快速对日期加/减天数
Plug 'mattn/calendar-vim'          " 显示日历

" -------------------------------------                                 光标移动
Plug 'easymotion/vim-easymotion'   " 让光标快速到达指定位置(包括行)

" -------------------------------------                                 buffer相关
Plug 'AndrewRadev/bufferize.vim'   " 在新buffer中显示命令的输出结果,
                                   " 可对输出结果进行复制

" -------------------------------------                                 窗口管理
Plug 'dstein64/vim-win'            " 显示窗口编号并h/j/k/l切换窗口

" -------------------------------------                                 其他优化插件
Plug 'tpope/vim-repeat'            " 使用.重复上次的插件操作(未起作用)
Plug 'voldikss/vim-floaterm'       " 支持在vim上悬浮终端窗口
Plug 'mbbill/undotree'             " 以列表显示vim撤回了哪些修改
                                   " 以及修改的内容 
Plug 'chrisbra/NrrwRgn'            " 将注意力集中在一个选定的区域内,暂
                                   " 时隐藏其余部分
" Plug 'kien/rainbow_parentheses.vim' " 括号对彩色高亮(默认不开启)
Plug 'mhinz/vim-startify'          " vim启动界面,显示会话列表&历史文件
Plug 'dstein64/vim-startuptime'    " 显示vim启动时间

call plug#end()

" vim 插件列表(内置插件)
" =============================================================================
" -------------------------------------                    vim查看man手册
" Note: Man手册结构
"       第1章: 用户命令(可执行程序和shell命令)
"       第2章：系统调用
"       第3章：C库函数
"       第4章：特殊文件(通常是/dev中的设备)和驱动
"       第5章：文件格式和约定
"       第6章：游戏等
"       第7章：杂项(包括宏包和约定,例如man(7), groff(7))
"       第8章：系统管理命令和守护进程
"       第9章: 内核例程(非标准)
" Usage:
"       @an  : (默认)右侧垂直分屏打开man页面。按an后, 会
"              调用:ManOpen命令(自定义命令,原命令为:Man),
"              在ManOpen后输入要查看的内容名字
"       @am  : 全屏模式打开man页面,m=max
"       @Tab : man页面中,在当前光标下单词按Tab,在新buffer
"              显示该单词对应的man页面,如不存在则显示错误

runtime ftplugin/man.vim

" Tips: 命令行的映射不需要加<silent>,否则按下映射键后命令行不会立即显示
nnoremap an :ManOpen 
nnoremap am :ManOpenOnly 

" 定义一个新命令, 以右侧垂直分屏模式打开 Man 页面(默认打开man页面的方式)
command! -nargs=+ ManOpen vertical rightbelow Man <args> 
" 定义一个新命令, 以全屏模式打开 Man 页面
command! -nargs=+ ManOpenOnly vertical rightbelow Man <args> | bd # | only

function! ManOpenTab(manPage) abort
    " 尝试打开man页面，捕获可能的错误信息
    redir => l:output
    silent! execute 'Man ' . a:manPage
    redir END

    " 如果man手册不存在该条目,则抛出错误信息
    if l:output =~ 'no manual entry'
        echohl ErrorMsg
        echo 'No man entry for ' . a:manPage
        echohl None
    else
        " 如果man页面存在，配置窗口打开方式
        " silent! execute 'vsp | Man ' . a:manPage . ' | only'
        execute 'ManOpen' a:manPage
        echo ""
    endif
endfunction

" Tips: 使用自动命令组的好处
"       使用augroup来定义一组针对 man 文件类型的设置和映射。这样做的好处是,
"       每次这个组被重新加载时(比如重新加载配置文件),autocmd! 会首先清除之
"       前的设置, 然后重新应用新的设置, 确保设置不会重复叠加
augroup ManKeyBindings
    autocmd!
    " 在查看 Man 页面时,按j向上,k向下
    autocmd FileType man nnoremap <buffer> j k
    autocmd FileType man nnoremap <buffer> k j
    " 在查看 Man 页面时自动显示行号
    autocmd FileType man setlocal number
    " 禁止折行
    autocmd FileType man setlocal nowrap
    " Tips: bufhidden选项决定了当buffer不再显示在任何窗口时Vim应该如何处理它。
    "       设置为hide表示当buffer被隐藏(例如, 切换到另一个buffer)时, 它不会
    "       被自动卸载, 其内容会被保留在内存中。这样, 当再次切换回这个buffer
    "       时, 它会立即显示, 而不需要重新加载内容。这种设置特别适用于那些加
    "       载内容需要较长时间或者你希望保持 buffer 状态的场景
    autocmd FileType man setlocal bufhidden=hide    " 缓存内容并禁止在切换时重新加载
    " 当文件类型是man时,将Tab键映射到:Man命令,按Tab查看当前光标下单词的man页面
    autocmd FileType man nnoremap <silent> <buffer> <Tab> :call ManOpenTab(expand("<cword>"))<CR>
augroup END

" vim 插件配置
" =============================================================================
" -------------------------------------                    vim-gitgutter
" Note: vim-gitgutter只有对被git跟踪的文件才会在编辑时显示diff，
"       新增的文件编辑时不会显示
" Usage: 以下命令需要让光标位于hunk(修改处)上
"   @bk                  : 显示当前buffer文件的所有修改块。命令速记, 'h'表示hunk(块，即修改的地方)
"   @(当前暂未映射)      : 暂存修改(会保留修改的内容，但是去掉符号标记)
"   @(当前暂未映射)      : 撤销修改
"   @(当前暂未映射)      : 对比显示diff: 左侧显示源文件，右侧显示修改的地方
"   @ha                  : 在quickfix中显示所有有修改的文件(会忽略更改未保存的文件)
"   @,d                  : 对比显示diff
"   @gn                  : 跳到下个修改块(hunk)
"   @gp                  : 跳到上个修改块(hunk)
"   @nk                  : 在修改块之间循环跳转
"   @gz                  : 折叠所有未更改的行

set updatetime=50                         " 检测更新时间
let g:gitgutter_sign_priority = 0         " 设置gitgutter标志的优先级,0为最高,数字越小优先级越高,
                                          " vim标志绘制顺序为由左往右(优先级由高到低)

let g:gitgutter_sign_allow_clobber = 0    " 禁止vim-gitgutter覆盖其他标记
" 禁止GitGutter抢占终端焦点,当GitGutter在终端中显示Git状态信息时,仍然可以在终端中输入命令或者进行其他操作
let g:gitgutter_terminal_reports_focus=0 
" 关闭浮动窗口方式显示hunk,而是在底部用新开窗口显示hunk
let g:gitgutter_preview_win_floating = 0
" 将所有修改块加载到quickfix列表中(会忽略所有未保存的更改,如果想在quickfix中显示必须:wq写入),
" 这样就可以通过点击hunk中的修改直接转到文件
nnoremap ha :Gqf<CR>
command Gqf GitGutterQuickFix | copen

" 控制是否全局启动GitGutter插件,按一次显示diff符号及类型,再按一次关闭
" nnoremap <Leader>c :GitGutterToggle<cr>
" 对比显示diff: 左侧显示源文件，右侧显示修改的地方
nnoremap <leader>d :GitGutterDiffOrig<cr>

" 预览当前文件的所有修改块(命令助记: _b_uffer hun_k_)
" Tips: bk=buffer hunk,即当前buffer文件的hunk(修改块)
nmap bk <Plug>(GitGutterPreviewHunk)   
" 暂存修改(当前暂未映射)
" nmap <未映射> <Plug>(GitGutterStageHunk)     
" 撤销修改(当前暂未映射)
" nmap <未映射> <Plug>(GitGutterUndoHunk)      

" git diff状态标志的颜色
highlight GitGutterAdd    cterm=bold ctermfg=22    " 新增的内容"+" 
highlight GitGutterChange cterm=bold ctermfg=130   " 修改的内容"~"
highlight GitGutterDelete cterm=bold ctermfg=1     " 删除的内容"-"

set foldtext=gitgutter#fold#foldtext()  " 折行的显示方式：+-- 45 lines (*): abcdef

" 折叠所有未更改的行, 可使用'zr' 展开大块上方和下方的 3 行上下文
" 按'gz', 折叠所有未更改的行, 按'zr'前后各展开3行
nnoremap gz :GitGutterFold<cr>   

" 增强在修改块之间跳转,在修改块之间跳转时可循环遍历所有缓冲区中的块
function! NextHunkAllBuffers()
  let line = line('.')
  GitGutterNextHunk
  if line('.') != line
    return
  endif

  let bufnr = bufnr('')
  while 1
    bnext
    if bufnr('') == bufnr
      return
    endif
    if !empty(GitGutterGetHunks())
      1
      GitGutterNextHunk
      return
    endif
  endwhile
endfunction

function! PrevHunkAllBuffers()
  let line = line('.')
  GitGutterPrevHunk
  if line('.') != line
    return
  endif

  let bufnr = bufnr('')
  while 1
    bprevious
    if bufnr('') == bufnr
      return
    endif
    if !empty(GitGutterGetHunks())
      normal! G
      GitGutterPrevHunk
      return
    endif
  endwhile
endfunction

nmap <silent> gn :call NextHunkAllBuffers()<CR>
nmap <silent> gp :call PrevHunkAllBuffers()<CR>

" 在跳转最后一个修改块时，将从头进行跳转(仅对当前buffer)
function! GitGutterNextHunkCycle()
  let line = line('.')
  silent! GitGutterNextHunk
  if line('.') == line
    1
    GitGutterNextHunk
  endif
endfunction
" 按'nk'在修改块间循环跳转(仅对当前buffer)
nmap <silent> nk :call GitGutterNextHunkCycle()<CR>
"                 Tips: nk='n'ext hun'k'

" -------------------------------------                    nerdtree
" Usage:
"   @,n : 打开Nerdtree窗口,显示文件夹和文件列表
"
"   Nerdtree 操作命令
"   (1) 文件/文件夹操作
"       Note: root目录 = 顶层目录 = 根目录,表示Nerdtree目录的根目录
"       @u   : 将root目录向上移动一个目录
"       @U   : 与u相同,但会保持旧的root目录是打开状态
"       @e   : 进入文件夹内部浏览, 会在右侧开启小窗口进入文件夹列表
"       @O   : 递归地打开当前文件夹下的所有文件夹
"              Warn: nerdtree展开的文件夹如果包含数量巨大的子文件夹/子文件,Nerdtree会有很大的延迟,
"                    可以改用vim-floaterm插件提供的yazi文件管理器窗口,打开方式:
"                    ① vim命令: FloatermNew yazi
"                    ② 快捷键 : 空格 + y 
"       @o   : 可以打开① 文件/② 文件夹
"              ① 文件   : 在右侧窗口中打开文件
"              ② 文件夹 : 打开/关闭文件夹(按一下打开,再按关闭)
"       @x   : 关闭父级文件夹
"       @X   : 递归关闭当前文件夹下的所有文件夹
"       @p   : 返回到父目录
"       @P   : 返回到root目录(顶层目录/根目录)
"       @go  : 在预览窗口中打开文件, 光标将仍然保留在Nerdtree窗口中, 用于预览多个文件特别有用.
"       @i   : 以水平分割窗口打开文件
"       @gi  : 以水平分割窗口打开文件, 但光标仍然保留在Nerdtree窗口
"       @s   : 以垂直分割窗口打开文件
"       @gs  : 以垂直分割窗口打开文件, 但光标仍然保留在Nerdtree窗口
"       @t   : 在新标签页打开选择的文件, 并全屏
"       @T   : 在新标签页静默打开选择的文件, 并全屏, 因为是静默, 所以不会跳转到新窗口
"       @C   : 将当前所选文件夹改为根目录, 即将该文件夹作为顶层目录, 与O不同, O是在当前视图下将文件夹展开, C则是直接进入到文件夹
"       @cd  : 将当前文件夹改为CWD(当前工作目录)
"       @CD  : 将文件夹目录跳转到CWD(当前工作目录)中, 即将CWD作为顶层目录
"              Note: 要CD的目录只有是cd的子目录才能直接用CD把目录设置为Nerdtree的顶层目录。例如,用cd设置了CWD=/A/B/C,此时
"                    vim的工作目录位于C,如果现在想用CD设置B为顶层目录会无效,因为B不是C的子目录, 而是C的父级目录。所以要想
"                    用CD把目录设置为顶层目录,必需满足该目录是CWD(即cd设置的目录)的子目录。所以一般先用cd设置CWD,然后再用
"                    CD来设置想要成为顶层目录的目录
"       @m   : 对所选择的文件或文件夹弹出编辑菜单, 包括修改文件名、复制、移动、删除等操作
"       @I   : 显示系统隐藏文件
"       @f   : 开/关文件过滤器,Nerdtree启动时候会默认开启过滤器,不显示过滤的文件/文件夹,如果想显示按下f。
"              在'let NERDTreeIgnore=[]'的[]中添加要过滤的文件/文件夹
"       @FL  : 文件右侧显示文件总行数
"       @B   : 隐藏/显示书签, 如果显示书签, 还会将光标自动跳转至书签
"              <1> Nerdtree书签(Bookmark)操作
"                  @:Bookmark             +name     : 创建书签(为文件/文件夹), 命令后跟要设置的名字,例如 Bookmark name
"                  @:ClearBookmarks                 : 清除指定的书签,后跟要删除的书签名,例如 ClearBookmarks name
"                  @:ClearAllBookmarks              : 清除所有书签
"                  @:OpenBookmark         +bookmark : 打开书签,后跟书签名,对于文件夹书签,会将文件夹设为新根;对于文件书签,
"                                                     会在右侧窗口打开该文件以供编辑
"                  @:RevealBookmark       +bookmark : 显示书签位置,后跟书签名
"                  @:BookmarkToRoot       +bookmark : 将与书签对应的目录设为新的根目录,如果书签指向文件,则将改用文件父级目录作根目录
"                  @:EditBookmarks                  : 打开书签文件进行手动编辑, 例如删除无效书签
"                  @:ReadBookmarks                  : 重新读取书签
"
"   (2) 关闭&移动
"       @q          : 退出NerdTree窗口
"       @D          : 删除书签(在最上方的bookmark list里选择要删除的书签,按D删除光标所在行显示的书签)
"       @F          : 隐藏文件(将不显示任何文件,只显示文件夹),再按一次恢复文件显示
"       @ctrl +  j  : 移动到同级的下一个目录
"       @ctrl +  k  : 移动到同级的上一个目录
"       @K          : 移动到同级目录的第一个(在上方)
"       @J          : 移动到同级目录的最后一个(在下方)
"
"   (3) 全屏
"       @A  : 全屏进入NerdTree窗口(再按一次退出全屏窗口)
"
"   (4) 刷新
"       @r  : 刷新当前文件夹的缓存, 使界面刷新
"       @R  : 刷新整个文件夹树的缓存, 使整个界面更新
"
"   (5) 帮助
"       @?  : 快速显示帮助, 忘记命令时使用

nnoremap <silent> <leader>n :NERDTreeToggle<cr>
let g:NERDTreeFileExtensionHighlightFullName = 1
let g:NERDTreeExactMatchHighlightFullName = 1
let g:NERDTreePatternMatchHighlightFullName = 1
let g:NERDTreeHighlightFolders = 1
let g:NERDTreeHighlightFoldersFullName = 1
let g:NERDTreeDirArrowExpandable='›'
let g:NERDTreeDirArrowCollapsible='⌄'
highlight NERDTreeUp ctermfg=25
highlight NERDTreeDir ctermfg=23
highlight NERDTreeDirSlash ctermfg=23
highlight NERDTreeOpenable ctermfg=23
highlight NERDTreeClosable ctermfg=23
highlight NERDTreeExecFile ctermfg=1

" 设置Nerdtree过滤器要忽略掉的文件/文件夹
" Note: '\.d$[[dir]]', '\.o$[[file]]', 'tmp/cache$[[path]]'分别表示文件夹、文件、路径
let NERDTreeIgnore=['\.git$[[dir]]', '\.vscode$[[dir]]', '\.dSYM$[[dir]]', 'tags']

" -------------------------------------                    nerdtree-git-plugin
" Note: git状态只有在git仓库中才能正确显示，没有git信息的
"       目录无法显示，因为获取不到git元数据
let g:NERDTreeGitStatusGitBinPath = '/usr/bin/git'
let g:NERDTreeGitStatusUntrackedFilesMode = 'all'
let g:NERDTreeGitStatusShowClean = 1
let g:NERDTreeGitStatusShowIgnored = 1      " 显示ignore状态
" Note: git文件状态含义
"     @Modified      [ M ]   (已修改):  文件有修改
"     @Staged        [ S ]   (暂  存):  文件的当前版本已经被添加到了暂存区（Index）中，
"                                       准备提交到 Git 仓库中
"     @Untracked     [ + ]   (未跟踪):  表示文件存在于工作目录中，但尚未被 Git 跟踪。这
"                                       通常是新创建的文件，Git 不会自动跟踪它们
"     @Renamed       [ R ]   (重命名):  表示文件在提交中被重命名了
"     @Unmerged      [ U ]   (未合并):  表示文件存在于一个冲突的合并中，需要手动解决冲突后才能继续
"     @Deleted       [ - ]   (已删除):  表示文件在提交中被删除了
"     @Dirty         [ ! ]       (脏):  表示工作目录中有未被暂存的改动
"     @Ignored       [ I ]   (已忽略):  表示文件被添加到了.gitignore 中，Git 将忽略对这些文件的跟踪和管理
"     @Clean         [ √ ]   (干  净):  表示工作目录中没有未被跟踪的文件，也没有未提交的修改
"     @Unknown       [ ? ]   (未  知):  表示 Git 不识别文件的状态，通常是因为文件不在 Git 仓库中
" Note:
"     表示文件的git状态符号颜色在.vim/after/syntax/nerdtree.vim中进行设置
let g:NERDTreeGitStatusIndicatorMapCustom = {
                \ 'Modified'  :'M',
                \ 'Staged'    :'ꓢ',
                \ 'Untracked' :'+',
                \ 'Renamed'   :'R',
                \ 'Unmerged'  :'U',
                \ 'Deleted'   :'-',
                \ 'Dirty'     :'!',
                \ 'Ignored'   :'I',
                \ 'Clean'     :'√',
                \ 'Unknown'   :'?',
                \ }
highlight NERDTreeFlags ctermfg=22      " git 状态的[ ]颜色

" -------------------------------------                    airline
" Usage:
"       @空格+数字 : 切换到数字对应的buffer
"       @ah        : 切换到上一个buffer(递减buffer编号)
"       @al        : 切换到下一个buffer(递增buffer编号)
"                    Tips: 助记,t=tab
" Note:
"     Vim 状态栏(trailing、mixed-indent、mix-indent-file)的含义:
"         @Trailing (显示行尾空格): 显示行尾存在空格的行
"         @Mixed-indent(显示混合缩进): 显示当前行的混合缩进情况。
"           混合缩进是指当前行的缩进方式与文件中其他行的缩进方式不一致
"         @Mixed-indent-file(显示文件中的混合缩进):将文件中存在混合缩进的行数显示在状态栏中
if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif
let g:airline_theme="luna"                              " vim 状态栏主题
let g:airline#extensions#tabline#enabled = 1            " 顶部显示标签
let g:airline#extensions#tabline#show_splits = 1        " 显示每个tab打开的分割(仅当tab打开时)[好像没生效]
let g:airline#extensions#tabline#show_tabs = 1          " 显示tab，无论数量多少
let g:airline#extensions#tabline#show_tab_count = 1     " 显示tab数量
let g:airline#extensions#tabline#tab_nr_type = 1        " tab编号的显示类型(只显示序号，不显示该tab下分割的buffer数)
let g:airline#extensions#tabline#tabnr_formatter = 'tabnr' "tab显示样式
let g:airline#extensions#tabline#show_tab_nr = 1        " 显示tab编号
let g:airline#extensions#tabline#show_tab_type = 1      " 显示类型:[buffers]/[tabs]
let g:airline#extensions#tabline#formatter = 'unique_tail' " buffer文件只显示文件名,不显示路径

let g:airline#extensions#branch#enabled = 1     " 底部状态栏显示git分支
let g:airline#extensions#hunks#enabled = 1      " 底部状态栏显示修改记录
let g:airline#extensions#hunks#non_zero_only = 1 " 仅当有修改时显示
let g:airline#extensions#hunks#hunk_symbols = ['+', '~', '-'] " 底部状态栏显示增加/修改/删除的标记符号

let g:airline#extensions#tagbar#enabled = 1     " tagbar扩展[暂没明确作用]
let g:airline#extensions#fzf#enabled = 1        " fzf扩展[暂没明确作用]

let g:airline_symbols.branch = '⎇ '             " git分支图标
let g:airline_symbols.readonly = '🔒'           " 只读文件标记
let g:airline_symbols.colnr = ''                " 列符号
let g:airline_symbols.linenr = ' '              " 行符号
let g:airline_symbols.maxlinenr = ' '           " 行总数标记

let g:airline#extensions#whitespace#show_message = 1
let g:airline#extensions#whitespace#checks =
   \  [ 'conflicts', 'trailing', 'mixed-indent-file' ]

" 在版本控制过程中,如果文件存在合并冲突,状态栏中
" 以 [数目]C 的格式显示
let g:airline#extensions#whitespace#conflicts_format = '[%s]C ' " 合并冲突的显示格式,C=conflicts

let g:airline_symbols.whitespace = ''           " 尾部空白标志
let g:airline#extensions#whitespace#trailing_format = '[%s]TS ' " 尾部空白格式:[数目]TS, TS=Trailing Space

" 文件存在混合缩进显示格式, 混合缩进是指在同一文件中同时使用空格和制表符进行缩进,
let g:airline#extensions#whitespace#mixed_indent_file_format =
   \ '[%s]X'  " X=mixed-indent-file             " 混合缩进显示格式: [范围]X

" 开启buffer编号显示，按数字1、2等切换buffer,按-/+来递减/递增buffer
let g:airline#extensions#tabline#buffer_idx_mode = 1
nmap <Space>1 <Plug>AirlineSelectTab1
nmap <Space>2 <Plug>AirlineSelectTab2
nmap <Space>3 <Plug>AirlineSelectTab3
nmap <Space>4 <Plug>AirlineSelectTab4
nmap <Space>5 <Plug>AirlineSelectTab5
nmap <Space>6 <Plug>AirlineSelectTab6
nmap <Space>7 <Plug>AirlineSelectTab7
nmap <Space>8 <Plug>AirlineSelectTab8
nmap <Space>9 <Plug>AirlineSelectTab9
nnoremap <silent> ah <Plug>AirlineSelectPrevTab
nnoremap <silent> al <Plug>AirlineSelectNextTab
" buffer编号样式
let g:airline#extensions#tabline#buffer_idx_format = {
        \ '0': '⓿ ',
        \ '1': '① ',
        \ '2': '② ',
        \ '3': '③ ',
        \ '4': '④ ',
        \ '5': '⑤ ',
        \ '6': '⑥ ',
        \ '7': '⑦ ',
        \ '8': '⑧ ',
        \ '9': '⑨ '
        \}

" airline 依赖的扩展插件
" -------------------------------------                      vim-flog [airline extension]
" Usage: 
"   @gl         : 打开git commit graph
"   @ctrl+n     : 直接打开下一个commit
"   @ctrl+p     : 打开上一条commit
"   @u          : 刷新graph
"   @a          : 显示所有分支
"   @gq         : 退出git commit graph
" gl打开git提交历史 
nnoremap <silent> gl :Flog<cr>                    


" -------------------------------------                      tagbar
" 了解tagbar: https://github.com/vimcn/tagbar.cnx/blob/master/tagbar.cnx
" Usage:
"    @<F1>              :显示键映射帮助。
"    @<CR>/<Enter>      :跳转到当前光标下的 tag。如果是伪标签或一般的头信息则没作用.
"    @p                 :源文件跳转到当前光标下的 tag。但光标停留在 Tagbar 窗口。
"    @<LeftMouse>       :如果点击折叠图标，按折叠的当前状态开打开或关闭折叠。
"    @<2-LeftMouse>     :同 <CR>。如果希望使用单击替代双击，参考 |g:tagbar_singleclick|。
"    @<Space>           :在命令行显示当前 tag 的原型信息。(比如行号)
"    @+/zo              :打开当前光标下的折叠。
"    @-/zc              :如果光标下有折叠则关闭光标下的折叠，如果没有则关闭当前的折叠。
"    @o/za              :切换光标下的折叠状态，如果光标下没有折叠，切换当前的折叠状态。
"    @*/zR              :通过设置折叠级别(foldlevel)为 99 来打开所有的折叠。
"    @=/zM              :通过设置折叠级别为 0 来关闭所有的折叠。
"    @<C-N>             :转到下一个顶层 tag。
"    @<C-P>             :转到前一个顶层 tag。
"    @s                 :在 tag 名称排序和文件顺序排序中切换。
"    @x                 :切换 Tagbar 窗口的最大化。
"    @q                 :关闭 Tagbar 窗口。
let g:tagbar_width = 30
nnoremap <silent> <leader>t :TagbarToggle<cr>
let g:tagbar_sort = 0           " tagbar按照标签在文件中出现的顺序排序,1为按英文首字母顺序排列
let g:tagbar_autofocus = 1      " 在 Tagbar 窗口打开时，光标会自动移动到 Tagbar 窗口
" @TagbarKind: Tagbar 种类，通用的类型比如函数和变量的头。
highlight TagbarKind ctermfg=23
" @TagbarScope: Tagbar 范围，定义范围的 tags，比如 class,struct 等。
highlight TagbarScope ctermfg=25
" @TagbarType: tag 或范围的类型，如果是有的话。
highlight TagbarType ctermfg=1
" @TagbarSignature: 函数签名(参数颜色)
highlight TagbarSignature ctermfg=89
" @TagbarPseudoID: 星号表示伪标签。
" highlight TagbarPseudoID ctermfg=1
" @TagbarFoldIcon: 可折叠 tags 左边的图标。
highlight TagbarFoldIcon ctermfg=130
" @TagbarHighlight: 自动高亮的当前 tag 的颜色。
" @TagbarAccessPublic: "public" 可见性/可访问性符号(结构体成员前面的标识符)
highlight TagbarAccessPublic ctermfg=1
" @TagbarAccessProtected: "protected" 可见性/可访问性符号。
highlight TagbarAccessProtected ctermfg=1
" @TagbarAccessPrivate: "private" 可见性/可访问性符号。
highlight TagbarAccessPrivate ctermfg=1

" -------------------------------------                    fzf
" Usage:
"       @tab键  : 选择多个
"       @空格+f : 打开文件列表
"       @,+g    : 显示当前目录下所有git文件(不带git状态)
"       @,+sg   : 显示当前目录下所有git文件(带git状态)
"       @空格+b : 显示buffer列表
"       @空格+a : 显示commit列表(源代码所有commit)
"       @空格+c : 显示当前 buffer 的 commit 列表(仅当前文件的commit)
"       @空格+e : 列表显示之前打开过的文件
"       @空格+d : 列表显示之前使用的命令(vim函数或系统命令)
"                 Tips: 空格+d会显示历史命令,选中命令后,直接Enter会执行该命令,如果
"                       想在该命令的基础上进行修改,可以按Ctrl+e,命令会被复制到命令
"                       行,可以在此基础上继续编辑
"       @ctrl+j/k: 列表中向上/下选择
       
" 打开文件搜索列表,默认显示当前目录文件。查找指定路径可给Files函数传入路径参数，例如 :Files path, 命令助记(f = _f_iles)
nnoremap <Space>f :Files<cr>
" 显示所有git文件(文件不显示git状态)
nnoremap <silent> <Leader>g :GFiles<cr>
" 显示所有git文件(文件显示git状态)
nnoremap <silent> <Leader>sg :GFiles?<cr>
" 打开buffer列表, 命令助记(b = _b_uffer)
nnoremap <silent> <Space>b :Buffers<cr>
" 打开 commit 列表(依赖fugitive.vim插件), 命令助记(a = _a_ll commits)
nnoremap <silent> <Space>a :Commits<cr>
" 打开当前 buffer 的 commit 列表, 命令助记(c = burrer _c_ommit)
nnoremap <silent> <Space>c :BCommits<cr>
" 显示commit的diff差异时,用垂直窗口分割进行对比
set diffopt+=vertical

" 列表显示之前打开过的文件, 命令助记(e = fil_e_)
nnoremap <silent> <Space>e :History<cr> 
" 列表显示之前使用的命令, 包括vim函数或系统命令, 命令助记(d = comman_d_)
nnoremap <silent> <Space>d :History:<cr>

" 设置fzf窗口的高度和宽度
let g:fzf_layout = { 'window': { 'height': 1.0, 'width': 1.0 } }

" fzf搜索框颜色
"       @fg        : 列表项字体颜色
"       @fg+       : 列表当前项字体颜色
"       @bg        : 窗口背景色
"       @bg+       : 列表当前项背景色
"       @hl        : 突出显示的子字符串(列表)
"       @hl+       ：突出显示的子字符串(当前)
"       @preview-bg: 右侧预览窗口背景色
"       @info      : 预览框里的行信息 
"       @border    : 边框色
"       @gutter    : 文件列表左侧竖线
"       @prompt    : 搜索类型标记(path/gitfile)
"       @pointer   : 列表左侧指示箭头
"       @query     : 输入字体颜色
let g:fzf_colors =
                        \{'fg':         ['fg', 'NERDTreeDir'],
                        \ 'fg+':        ['fg', 'NERDTreeDir'],
                        \ 'bg':         ['bg', 'Normal'],
                        \ 'bg+':        ['bg', 'CursorLine'],
                        \ 'hl':         ['fg', 'NERDTreeExecFile'],
                        \ 'hl+':        ['bg', 'Search'],
                        \ 'preview-bg': ['bg', 'Normal'],
                        \ 'info':       ['bg', 'airline_c'],
                        \ 'border':     ['bg', 'airline_c'],
                        \ 'gutter':     ['bg', 'Normal'],
                        \ 'prompt':     ['bg', 'airline_b'],
                        \ 'pointer':    ['bg', 'Keyword'],
                        \ 'marker':     ['bg', 'Error'],
                        \ 'spinner':    ['bg', 'Error'],
                        \ 'query':      ['fg', 'DiagnosticWarn'],
                        \ 'header':     ['bg', 'Error'] }

" -------------------------------------                    git-blame
" Usage:
"       @ctrl+s : 查看git blame信息
nnoremap <C-s> :<C-u>call gitblame#echo()<CR>

" -------------------------------------                    vim-floaterm
" Usage:
"       @空格 + t : 在vim上打开悬浮终端窗口,再按一下隐藏
"                   Tips: 助记: t=terminal, 即终端
"       @空格 + y : 打开yazi文件管理器浮动窗口
" 在vim上打开悬浮终端       
let g:floaterm_keymap_toggle = '<Space>t'
let g:floaterm_width = 1.00
let g:floaterm_height = 1.02
let g:floaterm_opener='edit'    " 从yazi打开文件时从当前buffer打开(默认会用水平分割窗口打开文件)
highlight Floaterm ctermbg=NONE
highlight FloatermBorder cterm=bold ctermfg=23 ctermbg=NONE
nnoremap <silent> <Space>y :FloatermNew yazi<CR>

" -------------------------------------                    asyncrun
" Repo: 
"       https://github.com/skywind3000/asynctasks.vim/tree/master 
" Usage:
"       @ar    : 编译并运行, 助记,ar='a'sync'r'un
"       @ctrl+g : 在项目中查找关键词
let g:asyncrun_open = 15             " quickfix 窗口高度
let g:asynctasks_term_rows = 10      " 终端高度为 10"
let g:asynctasks_term_pos = 'bottom' " 终端位置
"let g:asynctasks_term_pos = 'tab'   " 内置终端将在vim buffer中打开

" 运行asynctask命令后，将光标焦点保持在quickfix窗口上
"   @编译并运行
"     Note: run为async插件定义的单个任务命令，可在.task文件中定义
function! RunAndSwitch()
    :AsyncTask run
    :wincmd p
endfunction
noremap <silent> ar :call RunAndSwitch()<cr>
"   @在项目中查找关键词
"     Note: 显示所有包含关键字的代码行，选中行按Enter新打开文件
"             并跳转到关键字所在行
function! GrepAndSwitch()
    :AsyncTask grep
    :wincmd p
endfunction
noremap <silent> <C-g> :call GrepAndSwitch()<cr>

" -------------------------------------                    undotree
" Note: undotree标志含义
"       (1) 当前状态标记为> number <
"       (2) 将通过:redo或<ctrl-r>恢复的下一个状态标记为{ number }
"       (3) [ number ]标记最近的更改
"       (4) 保存的更改标记为s ，大S表示最近保存的更改

" Usage:
"       @空格+u : 打开撤销操作列表
nnoremap <silent> <Space>u :UndotreeToggle<CR>       
let g:undotree_DiffAutoOpen = 1         " 自动打开差异窗口，显示当前状态和选择的历史状态之间的差异
let g:undotree_SetFocusWhenToggle = 1   " 打开undo面板后，光标自动聚焦到undo面板
let g:undotree_ShortIndicators = 1      " 使用短指示器来表示撤销树中的分支关系
let g:undotree_WindowLayout = 2         " undo面板布局类型
let g:undotree_DiffpanelHeight = 20     " undo diff面板高度
let g:undotree_SplitWidth = 25          " undo左侧面板宽度

" -------------------------------------                    NrrwRgn
" Usage:
"       @mn     : 在新的缩小窗口中打开所选区域(原插件命令:NR)
"       @wq     : 将专注区的修改写回原始区，同时关闭专注窗口
"       @NRV    : 打开上次可视选择的区域的缩小窗口
"       @WR     : 将专注区的修改写回原始区，但不关闭专注窗口

" mn 打开专注窗口                          
vnoremap <silent> mn :NR<CR>                    

"let g:nrrw_rgn_vert = 1                        " 垂直方式打开专注窗口
let g:nrrw_rgn_resize_window = 'relative'       " 通过百分比的方式设置专注窗口的尺寸
let g:nrrw_rgn_rel_min = 100                    " 专注窗口高度最小值
let g:nrrw_rgn_rel_max = 100                    " 专注窗口高度最大值
let g:nrrw_rgn_nohl = 1                         " 不在原始区域中高亮显示选中内容

" -------------------------------------                    tcomment_vim
" Usage: 
"       [注] 1. 单行: 按第一次注释，再按一次取消注释
"            2. 多行: 可视模式下选中文本进行注释/取消注释
"       @空格      : 注释当前行
"       @空格+r    : 在光标右侧添加注释
"       @空格+空格 : 选中的内容添加块注释
noremap <silent> <Space> :TComment<CR>
noremap <silent> <Space>r :TCommentRight<CR> 
noremap <silent> <Space><Space> :TCommentBlock<CR>

" -------------------------------------                    tabular
" Usage:
"       @=      : 先用v命令选中文本块,然后按'='号,会在命令行调用
"                 Tabularize /命令,然后输入对齐参照字符,例如以','
"                 对齐,在Tabularize /后直接输入','字符, 完整命令
"                 为:Tabularize /,(,号为对齐参照)
map = :Tabularize /

" -------------------------------------                    calendar-vim
" Usage:
"       @ ← ↑ ↓ →方向键         : 选择日期
"       @shift + h              : 到上个月
"       @shift + l              : 到下个月
"       @:CalendarH             : (vim命令)打开日历面板
"       @t                      : 回到今天(日历面板已开的情况下)
let g:calendar_focus_today = 1          " 移至下一个或上一个日历时保持焦点在今天
let g:calendar_keys = { 'goto_next_month': '<S-l>', 'goto_prev_month': '<S-h>'} " shift+h: 到上个月, shift+l: 到下个月
let g:calendar_number_of_months = 6     " 日历面板显示6个月
let g:calendar_navi = 'top'             " 导航栏置于顶部
let g:calendar_navi = 'center'

" -------------------------------------                    vim-sandwich
" Note: 
"       (1) 下面的命令在可视模式下也可使用
"       (2) 下面的"括号"是简单表达,表示成对出现的任何字符
" Usage:
"       @sr+目标字符+替换字符 : 替换字符,把目标字符换成替换字符，例如sr"', 把"替换为', 命令sr助记: sandwich + replace
"       @sd+待删除括号        : 删除括号, 例如sd(, 删除()括号对, 命令sd助记: sandwich + delete
"                               Tips: 在可视模式下,删除选中文本块中的匹配括号对,如果只有一对匹配,直接执行sd命令即可删除括号对,
"                                     无需指定要删除的括号对,sd命令会删除任意括号对;如果选中的文本有多对匹配,例如({[]}),会默认
"                                     删除最外层的括号对,即例子中的()
"       @sal +待添加括号      : 给光标后的字符添加括号(给单词中的字母添加成对符号)
"       @saw +待添加括号      : 给光标后的单词添加括号, 例如saw(, 光标后的单词会加上括号对(), 命令sa助记: sandwich + add
"       @saiw+待添加括号      : 给光标处的单词添加括号, 例如saiw(, 光标处的单词周围会加上括号对()
"       
"       @sais+待添加括号      : 段落添加括号,不包括外层包围字符(surrounding), 助记: i=inner
"       @saas+待添加括号      : 段落添加括号,包括外层包围字符,助记: a = around
"                               Tips: sais类命令按的时候,不要一次按完,否则不生效,先按sa,然后按i,最后按s,比如: sa i s这样的节奏(下同)
"       @saib+待添加括号      : 句子添加括号,不包括外层包围字符(surrounding)
"       @saab+待添加括号      : 句子添加括号,包括外层包围字符
"                               范围解释:
"                                            |<----ib,is---->|
"                               {surrounding}{surrounded text}{surrounding}
"                               |<-----------------ab,as----------------->|

" -------------------------------------                    vim-easymotion
" Usage:
"       @,+w/b    : 跳转到当前光标前/后的位置
"       @,+j/k    : 行级跳转,跳转到当前光标行上/下的位置
"       @,+h/l    : 行内跳转,跳转到当前光标行左/右的位置 
"       @/        : 搜索跳转,按Tab向下翻页,按Shift+Tab向上翻页,到达目标区域时,按Enter显示位置
"       @,+.      : 重复上一次的搜索
map <leader> <Plug>(easymotion-prefix)
map <Leader>j <Plug>(easymotion-k)
map <Leader>k <Plug>(easymotion-j)
map <Leader>h <Plug>(easymotion-linebackward)
map <Leader>l <Plug>(easymotion-lineforward)
map / <Plug>(easymotion-sn)
map <Leader>. <Plug>(easymotion-repeat)

let g:EasyMotion_smartcase = 1          " 设置此选项后, v 将匹配 v 和 V ，但 V 将仅匹配 V

hi EasyMotionTarget ctermbg=228 ctermfg=red         " 单字位置标识
hi EasyMotionTarget2First ctermbg=228 ctermfg=166   " 双字位置标识第1字
hi EasyMotionTarget2Second ctermbg=228 ctermfg=166  " 双字位置标识第2字
hi EasyMotionIncSearch ctermbg=228 ctermfg=red      " 搜索模式下匹配的文本颜色
hi EasyMotionIncCursor cterm=bold ctermbg=202                  " 搜索模式下光标颜色

" -------------------------------------                    vim-system-copy
" Usage:
"   @cpiw   : 将单词复制到系统剪贴板
"   @cy     : 将整行复制到系统剪贴板
"   @cp     : 要将选中的内容复制到剪贴板,在可视模式下选中然后cp
let g:system_copy_silent = 1            " 抑制打印消息输出
" let g:system_copy_enable_osc52 = 1    " 远程ssh使用vim复制失败的备份复制工具(当前未启用)

nmap <silent> cy <Plug>SystemCopyLine

" -------------------------------------                    vim-peekaboo
" Note: Vim有许多不同的寄存器。当你复制文本时, 它会进入"寄存器。
"       当你删除文本时, 它会进入数字寄存器。然后还有小写和大写
"       等寄存器供你个人使用。
"       当你要使用寄存器时, 这个插件会预览它们。当你按下"键时,
"       它会在右侧打开一个寄存器列表, 可以看到每个寄存器的内容
"       并选择正确的寄存器内容。
" Usage:
"   @"  : 打开vim的寄存器列表(可以用v选中文本,然后打开寄存器列表,选中寄存器
"         前面的标识符即可复制寄存器内容,然后按p将内容粘贴到光标位置) 

" -------------------------------------                    linediff.vim
" Usage:
"   @tt  : 可视模式下选中第一块文本内容按'tt',然后选中第二块
"          文本再按'tt',即可比较两块文本的差异。Normal模式下,
"          按tt默认会选中当前行作为第一块要比较的文本
map tt :Linediff<CR>

" -------------------------------------                    vim-signature
" Usage:
"   @ma              : 在当前行添加一个标签'a'(每行最多可打2个标记符号)
"                      [⚠️ ]Note: 如果要设置标记d, 不能连按md,先按下m, 
"                                停顿下再按d,即可设置, d标志(md已映射
"                                为进入命令行模式的命令":")
"   @'a              : 跳转到标记为a的行
"   @m,              : 放置下一个可用标记
"   @cmx       (原dm): 删除标签'x'
"   @dm        (原m-): 删除当前行所有标记
"   @m + 空格        : 删除当前缓冲区的所有标记
"   @m/              : 打开位置列表(quickfix)并显示当前缓冲区
"                      的所有标记,同时显示位置字符
" Note: 这个插件的标记是以行为准打的,所以如果标记的位置如果有行变动(行增/行减),
"       则之前在该位置打的标记则可能会变动
" Tips:
"   1. 命令助记, m 表示mark
hi SignatureMarkText cterm=bold ctermfg=88  " mark字符标记颜色

nnoremap m/ :<C-U>call signature#mark#List(0, 0)<CR><Plug>(easymotion-j)


" 重新映射原插件命令:
"   dm => cm
"   m- => dm
nnoremap cm :<C-U>call signature#utils#Remove(v:count)<CR>
nnoremap dm :<C-U>call signature#mark#Purge("line")<CR>

" -------------------------------------                    scratch.vim
" Note: Vim的文档提到了一种称为scratch缓冲区的特殊缓冲区类型。
"       这个插件实现了它。Scratch缓冲区是临时丢弃缓冲区。
" Usage:
"   @空格+n     : normal模式下打开草稿窗口并进入插入模式,当离开插入模式时，草稿窗口会关闭。
"                 在可视模式下时,会将当前选择( 按字符、按行或按块 )粘贴到草稿窗口中,所有的
"                 笔记内容会写入g:scratch_persistence_file指定的文件中,后续写入的笔记会追加
"                 在之前的记录后面
"   @空格+N     : 新打开一个干净的草稿窗口(其余功能同上),新窗口写入的内容会覆盖原笔记内容
vnoremap <Space>n <Plug>(scratch-selection-reuse)
nnoremap <Space>n <Plug>(scratch-insert-reuse)
vnoremap <Space>N <Plug>(scratch-selection-clear)
nnoremap <Space>N <Plug>(scratch-insert-clear)
let g:scratch_height = 0.5      " 草稿窗口高度
" 默认情况下,离开Vim时草稿窗口的内容会丢失。要保存笔记内容,需要将
" g:scratch_persistence_file 选项设置为有效的文件路径,该文件用来保存笔记内容
let g:scratch_persistence_file = '~/note/scratch.vim'

" -------------------------------------                    QFRestore
" Note: Quickfix是vim最大的特性之一。不幸的是,一旦用结果填充了quickfix列表，它就会被冻结。
"       无法进一步过滤quickfix列表。这种行为不太合理,因为我们总是希望细化结果。Qfgrep允许
"       这样做。现在,我们可以在quickfix窗口中过滤结果
" Usage:
"   @,q     : 对当前Quickfix进行过滤,用户以交互方式输入
"   @,qb    : 对当前Quickfix进行反向过滤，用户以交互方式输入
"   @,qr    : 恢复原始Quickfix条目
" Tips: 命令助记, q 等于 quickfix

let g:QFG_hi_prompt='ctermbg=24 ctermfg=15'     " 用户输入模式提示颜色
let g:QFG_hi_info = 'ctermbg=113 ctermfg=16'    " 信息提示颜色
let g:QFG_hi_error = 'ctermbg=88 ctermfg=15'    " 错误信息提示颜色

" 对当前Quickfix进行过滤，用户以交互方式输入
map <Leader>q :QFGrep<CR>
" 对当前Quickfix进行反向过滤，用户以交互方式输入
map <Leader>qb ::QFGrepV<CR>
" 恢复原始Quickfix条目
map <Leader>qr :QFRestore<CR>

" -------------------------------------                    quickfix-reflector
" Usage: 
"   @用法和正常编辑buffer一样,就是把quickfix当成了buffer进行操作,如果要写回buffer需要执行:w命令
"   @:w   : 将quickfix中的修改写回buffer

" -------------------------------------                    rainbow_parentheses.vim
" Note: 此插件当前默认关闭,因为当所有括号高亮后会使代码界面色彩过多,削弱语法的高亮效果
"       如需开启,将上面此插件的Plug开关打开,并取消下面的注释
" 颜色格式[ctermfg, guifg]
" let g:rbpt_colorpairs = [
"     \ ['brown',       'RoyalBlue3'],
"     \ ['Darkblue',    'SeaGreen3'],
"     \ ['darkcyan',    'RoyalBlue3'],
"     \ ['darkred',     'SeaGreen3'],
"     \ ['darkmagenta', 'DarkOrchid3'],
"     \ ['brown',       'firebrick3'],
"     \ ['darkmagenta', 'DarkOrchid3'],
"     \ ['Darkblue',    'firebrick3'],
"     \ ['darkcyan',    'SeaGreen3'],
"     \ ['darkred',     'DarkOrchid3'],
"     \ ]
" let g:rbpt_max = 16     " 最大的嵌套层数(超过不再高亮)
" let g:rbpt_loadcmd_toggle = 0
" au VimEnter * RainbowParenthesesToggle      
" au Syntax * RainbowParenthesesLoadRound     " ()
" au Syntax * RainbowParenthesesLoadSquare    " []
" au Syntax * RainbowParenthesesLoadBraces    " {}

" -------------------------------------                    a.vim
" Usage: 
"       @,a     : 垂直分割窗口并打开c\h文件
"
"       :A	    : 在新Buffer中切换到c\h文件
"       :AS     : 垂直分割窗口并打开c\h文件
"       :AT     : 新建一个Tab并打开c\h文件
" 垂直分割窗口并打开c\h文件
noremap <Leader>a :AV<CR> 


" -------------------------------------                    bufferize.vim
" Usage: 
"   @M  : 命令行调用Bufferize命令,然后在后面输入命令,在右侧的垂直窗口
"         中显示命令的输出结果(本质是一个vim临时缓冲区), 可对命令的输
"         出结果进行复制
" Tips: (1) 如果是普通normal模式下命令,按下M后直接在提示符后输入命令名即可,
"           例如, 在新buffer中显示所有高亮组
"               :vertical botright Bufferize hi
"       (2) 如果要在新buffer中显示vim命令的结果,则需要在命令前加":"
"           例如, 在新buffer中显示TSInstallInfo命令的结果(命令前加:)
"               :vertical botright Bufferize :TSInstallInfo

" 将光标焦点保持在打开的输出窗口上
let g:bufferize_focus_output = 1
" 在右侧的垂直窗口中显示命令的输出结果
map M :vertical botright Bufferize 

" -------------------------------------                    vim-exchange
" Note: 先选第一处交换位置,用Usage里的命令,然后再选第二处交
"       换位置,同样是Usage里的命令,在第二处位置处按下命令后,
"       两处位置就会自动完成交换
" Usage:
"   @cx     : 标记要交换的位置范围(位置范围用w/iw/is来指定,
"             分别表示光标后单词/光标处单词/光标所在的段落,
"             如果没有指定范围, 默认位置为光标所在的字符)
"   @cxc    : 清除cx的位置标记
"   @X      : 作用与cx相同,但用于[ 可视模式 ]
"   @cxl    : 标记位置范围为[ 光标后的字符 ]
"   @cxw    : 标记位置范围为[ 光标后的单词 ]
"   @cxiw   : 标记位置范围为[ 光标位置的完整单词 ]
"   @cxis   : 标记位置范围为[ 光标所在的段落 ]
"   @cxx    : 标记位置范围为[ 光标所在的行 ]
" Tips:
"   1. 用法可以理解为: cx + 交换范围,cx就是标记第一处位置,表明
"      这处位置接下来要与哪处位置进行交换。按下cx后,可以指定要
"      交换的范围,例如w表示光标后的单词,iw表示光标所在的完整单
"      词,如果cx后没有指定范围, 默认会标记当前光标所在的字符作
"      为交换位置。标记好第一处位置后,接下来将光标移动到第二处
"      位置,再次用命令选中要交换的位置,选中的同时,位置交换完成
"   2. 如果两处交换的位置相同,例如都是cxiw,第二处可以直接使用.

" -------------------------------------                    vim-expand-region
" Usage:
"       @+      : 可视模式下先选中,然后按 + 展开视觉选择
"       @_      : 可视模式下先选中,然后按 _ 缩小视觉选择

" -------------------------------------                    coc.nvim
" Note: Coc是一个基于Language Server Protocol(LSP)的插件, 可以
"       与各种语言服务器进行交互来提供代码补全、语法检查、跳转
"       定义等功能 
"     ▶ 如何使用?
"       (1) Coc本身不提供具体语言的补全功能,只是提供了一个
"           补全功能的平台, 所以在安装完成后, 需要安装具体
"           的语言服务(lsp)以提供补全的内容。
"       (2) 使用方法
"           Q: 安装完coc.nvim后,如何实现跳转到函数定义或者查看函数被引用等功能?
"           A: (1) 先安装对应语言的lsp,例如C可用clangd作为lsp,coc安装命令:
"                   :CocInstall coc-clangd 
"              (2) 为lsp生成compile_commands.json(编译数据库文件,用于提供函数定义跳转)
"                  clangd等lsp服务在处理大型项目时都依赖compile_commands.json文件,
"                  通过这个文件来支持函数定义跳转等功能,所以需要使用一些工具来先生成
"                  compile_commands.json文件,将这个文件放在项目的根目录下,然后coc.nvim
"                  就可以支持跳转到函数定义等代码浏览功能。
"           Q: 如何生成compile_commands.json文件?
"           A: 主要有三种工具可以来生成: bear 、compiledb、cmake
"              使用区别:
"              ▶ cmake    : 直接支持编译完生成编译数据库文件
"                           Usage: cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1
"              ▶ compiledb: 为基于GNU make构建系统生成Clang的JSON编译数据库文件
"                           Usage: compiledb /path/to/make (for make)
"              ▶ bear     : 为clang工具生成编译数据库的工具,也可为make构建系统生成编译数据库文件
"                           Usage: bear -- /path/to/make (for make)
"     ▶ coc.nvim的一些优点:
"       (1) coc提高重构效率: coc支持修改符号名后,可以立即更新整个项目中的符号
"       (2) 对编程语言的补全通过lsp,并且以插件方式提供lsp服务,直接下载对应插件就可以支持该语言的补全,插件系统也很方便管理所有插件
"
" Usage:
"       @ae     : 显示所有错误(打开quickfix列表)       
"       @<      : 到上一个错误
"       @>      : 到下一个错误
"       @Tab键  : 悬浮方式显示信息(例如函数原型信息)
"       @cn     : 快速更改变量名或符号,并自动更新所有相关引用
"       @gd     : 跳转到定义
"                 Tips: 按下gd的间隔时间决定打开方式
"                       (1) gd连按(gd连续按下,中间无停顿),在右侧垂直分屏打开定义
"                       (2) gd隔按(先按g,停顿后按d),在当前buffer打开定义
" Tips: coc命令
"       @:CocList extensions : 查看已安装的lsp
"                              Note: CocList extensions 命令用来显示所有已安装的扩展列表。
"                                    执行这个命令后,会弹出一个模糊匹配的提示输入框, 这样
"                                    可以快速筛选和选择你想要的扩展
"       @:CocUpdate          : 更新 coc.nvim 以及所有相关的语言服务器插件
"       @:CocOpenLog         : 查看日志
set encoding=utf-8 
set nobackup            " 禁止在保存文件时创建备份文件 
set nowritebackup       " 禁止在写入文件时创建备份

nnoremap <silent> ae :CocDiagnostics<CR>

inoremap <silent><expr> <TAB>
      \ coc#pum#visible() ? coc#pum#next(1) :
      \ CheckBackspace() ? "\<Tab>" :
      \ coc#refresh()
inoremap <expr><S-TAB> coc#pum#visible() ? coc#pum#prev(1) : "\<C-h>"

inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm()
                              \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"

function! CheckBackspace() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

if has('nvim')
  inoremap <silent><expr> <c-space> coc#refresh()
else
  inoremap <silent><expr> <c-@> coc#refresh()
endif

" 到上一个诊断信息
nmap <silent> < <Plug>(coc-diagnostic-prev)
" 到下一个诊断信息
nmap <silent> > <Plug>(coc-diagnostic-next)

" 转到定义(包括函数或变量)
nmap <silent> gd <Plug>(coc-definition)       
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

nnoremap <silent> <Tab> :call ShowDocumentation()<CR>
function! ShowDocumentation()
  if CocAction('hasProvider', 'hover')
    call CocActionAsync('doHover')
  else
    call feedkeys('<Tab>', 'in')
  endif
endfunction

" 光标停留一定时间后(CursorHold事件触发),高亮显示代码中的错误和警告信息
autocmd CursorHold * silent call CocActionAsync('highlight')
" 快速更改变量名或符号,并自动更新所有相关引用, 助记: cn=change name
nmap <silent> cn <Plug>(coc-rename)

augroup mygroup
  autocmd!
  " 当文件类型为 typescript 或 json 时的格式化格式
  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
  " 触发 Coc.nvim 插件的跳转占位符操作时,更新签名帮助信息
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
augroup end

" airline对coc.nvim的支持
let g:airline#extensions#coc#enabled = 1
let g:airline#extensions#coc#error_symbol = 'E:'
let g:airline#extensions#coc#warning_symbol = 'W:'
let g:airline#extensions#coc#show_coc_status = 1
let g:airline#extensions#coc#stl_format_err = '%C(L%L)'
let g:airline#extensions#coc#stl_format_warn = '%C(L%L)'

highlight! link CocFloatThumb NONE
hi CocFloatThumb ctermfg=NONE ctermbg=NONE  " 滚动条区域中的拖动条颜色

highlight! link CocFloatSbar NONE           
hi CocFloatSbar ctermfg=NONE ctermbg=NONE   " coc浮动窗口的滚动条区域背景

highlight! link CocFloatDividingLine NONE
hi CocFloatDividingLine ctermfg=22          " coc浮动窗口分割线

highlight! link CocErrorFloat NONE
hi CocErrorFloat ctermfg=1

hi CocFloating cterm=NONE ctermfg=66 ctermbg=194       " coc浮动窗口内文字颜色
" hi CocMenuSel ctermfg=23 ctermbg=150       " 列表选中项的背景
hi CocPumSearch ctermfg=26                  " 列表项匹配的子子字符串的颜色

" Q: nvim-treesitter语法高亮与coc.nvim语义高亮重复的问题
" A: nvim-treesitter 主要提供的是基于语法的高亮,而不是传统意义上的
"    基于语义的高亮。语法高亮是根据代码的语法结构(如关键字、操作符、
"    标识符等)来应用颜色, 而语义高亮则涉及到代码的更深层次意义 (如
"    变量类型、作用域等), 语义标记通过不同的颜色和样式来区分代码中
"    各种元素,其中也会对变量、函数、类等进行高亮,而nvim-treesitter
"    也会对变量、函数、类等进行高亮, 所以二者会存在重复高亮的问题,
"    如何为nvim-treesitter与coc.nvim的高亮范围解释:
"       nvim-treesitter语法高亮范围 : 基本语法类型
"       coc.nvim       语义高亮范围 : 基本语法类型 + 作用域
"
"    q1: 如何查看某处语法是否重复高亮?
"    a1: 在光标处执行Inspect命令, 如果显示treesitter和coc.nvim的两
"       个高亮组, 则表示光标处内容存在双重高亮, 例如:
"             Treesitter
"               - @variable.c links to @variable c
"               - @function.c links to Function c
"
"             Extmarks
"               - CocSemTypeFunction links to Function coc-semanticTokens
"               - CocSemTypeModFunctionDeclaration coc-semanticTokens
"      
"    q2: 如何解决重复高亮?
"    a2: 基本类型高亮使用nvim-treesitter高亮,作用域高亮使用coc.nvim,
"        所以关闭coc.nvim提供的基本类型高亮即可,具体地, 在光标处执行
"        Inspect命令,查看coc开头的高亮组名字, 然后在 init.vim 中添加
"        hi! link name NONE, 即可关闭coc对该类型对高亮

" 关闭自定义类型(例如C结构体struct, typedef自定义类型)的coc高亮
highlight! link CocSemTypeClass NONE        

" -------------------------------------                    ultisnips & vim-snippets
" Note: ultisnips插件提供一种快速操作代码片段的能力,例如编辑
"       代码片段的选项或者进行插值。而vim-snippets提供的是代
"       码片段,包括各种编程语言的代码片段,也可以自定义自己的
"       代码片段,其中,vim-snippets包含了两种格式的代码片段,
"           (1) snippets/*  : 使用 snipMate 格式的片段
"           (2) UltiSnips/* : 使用 UltiSnips 格式的片段
"       ultisnips插件可通过设置触发键,通过关键字快速插入代码
"       片段,并且可以切换到不同的选项位置进行编辑。
" Tips: 如果想借助coc.nvim提供的补全能力, 在补全时可以将代码
"       片段也显示在后选项里,可以安装
"            ~/.config/nvim/plugged/vim-snippets/snippets,
"       其中c.snippets文件是c语言的代码补全片段
" 快速地插入预定义的代码片段的触发键(按此键插入代码片段,当前未设置)
let g:UltiSnipsExpandTrigger="<Nop>"
" 设置代码片段跳转的快捷键
let g:UltiSnipsJumpForwardTrigger="<Nop>"
let g:UltiSnipsJumpBackwardTrigger="<Nop>"

" 使用 :UltiSnipsEdit 命令(语言的代码补全配置)时, 垂直分屏打开ultisnips配置
let g:UltiSnipsEditSplit="vertical"

" -------------------------------------                    vim-startuptime
" Usage:
"       @:StartupTime : 显示vim的启动时间,即启动项时间占比

" -------------------------------------                    vim-win
" Usage:            
"       @空格+w  : 启用vim-win窗口管理
"       @w       : 关闭vim-win
"       @q       : 关闭buffer窗口
"       @f       : 水平分屏
"                  Tisp: 助记,f=fen,即分(分屏), f的'-'表示水平方向
"       @v       : 垂直分屏
"       @n       : 切换到下一个buffer
"       @p       : 切换到上一个buffer
"       @h/j/k/l : 移动到左/上/下/右窗口
"       @H/J/K/L : 把窗口移动到左/上/下/右侧
"       @g       : 增加高度(增大水平分屏的高度),g=gao,即高
"       @d       : 降低高度(减小水平分屏的高度),d=di, 即低
"       @M       : 增加宽度(增大垂直分屏的宽度),M=Max,即增大
"       @N       : 减小宽度(减小垂直分屏的宽度),N=miN,即减小
"                  Tips: 大写的M、N竖线多,表示垂直方向,所以M、N分别控制垂直方向分屏的增加和缩小
"       @r       : 恢复窗口的默认标准宽/高度
"       @m       : 最大化当前分屏, m=max
"       @o       : 恢复上一次分屏布局,o=original,即原始的
"       @t       : 创建一个新的tab
map <silent> <Space>w <plug>WinWin
" 自定义vim命令: Win启用vim-win
command Win :call win#Win()
let g:win_ext_command_map = {
      \   'q': 'wincmd c',
      \   'v': 'wincmd v',
      \   'f': 'wincmd s',
      \   'm': 'only',
      \   'o': 'call RestoreSession()',
      \   'n': 'bnext',
      \   'p': 'bprevious',
      \   'r': 'wincmd =',
      \   't': 'tabnew',
      \   'w': 'Win#exit',
      \   'j': 'wincmd k',
      \   'k': 'wincmd j',
      \   'H': 'wincmd H',
      \   'J': 'wincmd K',
      \   'K': 'wincmd J',
      \   'L': 'wincmd L',
      \   'g': 'resize +10',
      \   'd': 'resize -10',
      \   'M': 'vertical resize +20',
      \   'N': 'vertical resize -20'
      \ }
" vim-win指示*号颜色
highlight! link WinStar NONE
hi WinStar cterm=bold ctermfg=23 ctermbg=NONE

" -------------------------------------                    vim-startify
" Note: session保存的位置: ~/.config/nvim/session
" Usage:
"    启动界面命令:
"       @e       : 创建一个空缓冲区
"       @i       : 创建一个空缓冲区并进入插入模式
"    导航至某个条目:
"       @b       : 在buffer中打开
"       @s       : 在水平分屏中打开
"       @v       : 在垂直分屏中打开
"       @t       : 在tab中打开
"                  Tips: 先导航到条目上,在执行操作,可以对多个
"                        条目执行此操作,也可以混合使用它们,选
"                        择的顺序将被记住
"       @B/S/V/T : 批处理多个,功能同上
"                  Tips: 要关闭批处理模式, 只需再次使用相同的大写键或任何小写变体。
"                        选择完成后, Startify 将自动关闭, 也可以通过:Startify重新
"                        打开启动界面
"    session命令 

" session保存的位置
let g:startify_session_dir = '~/.config/nvim/session'

" vim启动界面标题
let g:startify_custom_header = [
            \ '            __                  ',
            \ '    __  __ /\_\    ___ ___      ',
            \ '   /\ \/\ \\/\ \ /'' __` __`\   ',
            \ '   \ \ \_/ |\ \ \/\ \/\ \/\ \   ',
            \ '    \ \___/  \ \_\ \_\ \_\ \_\  ',
            \ '     \/__/    \/_/\/_/\/_/\/_/  ',
            \ ]

" 启动界面文件字体颜色
hi StartifyFile ctermfg=23
" 启动界面路径字体颜色
hi StartifyPath ctermfg=66

" -------------------------------------                    nvim-treesitter
" Note: 
"       1. nvim treesitter系列插件作用解释
"          (1) Treesitter是一个现代的、高性能源代码解析库, 可以构建出代码
"              的语法树, 使编辑器能够更智能地理解代码的结构。Treesitter可
"              以生成抽象语法树(AST)。与传统的词法分析器不同, TreeSitter
"              可以实时更新AST, 这使得nvim-treesitter-textobjects能够即时
"              响应代码的变化, 提供动态的文本对象选择
"          (2) nvim-treesitter,支持nvim中使用Treesitter功能来增强
"              文本对象的选择和操作
"          (3) nvim-treesitter-textobjects,利用Treesitter的语法树,
"              语法感知文本对象, 支持对语法文本对象进行选择、移动、
"              交换和查看
"       2. 当前已安装的语言解析器
"          [c] [vim] [vimdoc] [query] [lua] [markdown] [markdown_inline]
" Usage:
"       (1) nvim-treesitter : 针对语法节点的范围
"           @sn : 开始选择语法节点,将选中光标下的最小语法节点
"                 <助记>: sn=select now
"           @se : 选择的范围会扩展到包含当前选择的下一个较大的语法节点
"                 <助记>: se=select expand
"           @su : 将扩展选择范围到当前节点的父级作用域
"                 <助记>: su=select upgrade
"           @sm : 选择的范围会缩小到当前选择的下一个较小的语法节点
"                 <助记>: sm=select mini
"       (2) nvim-treesitter-textobjects : 针对语法文本对象
"           ● 选择
"             ▶ 以下所列均代表范围,可配合vim动词进行操作,例如选择(v)、删除(d)、修改(c)
"               例如, fa表示函数全部,dfa表示删除函数全部。如果是进入Visual模式进行选择,
"               则可以不连按,例如vfa, 按下v后进入可视模式, 然后再按下范围fa(必须连按),
"               选中整个函数
"
"               @fa : 整个函数,fa=function all
"               @fi : 函数内部,fi=function inner
"               @ca : 整个类
"               @ci : 类内部
"               @oa : 整个循环,o=lo'o'p, o外形为环状,表示循环
"               @oi : 循环内部
"               @sa : 条件选择(如if, else)整体, sa=select all
"               @si : 条件选择语句的判断条件,si=select inner
"               @ah : 赋值语句左侧,例如x = 5 + 3, 对应x, ah=assignment h, 即赋值左侧
"               @al : 赋值语句右侧,例如x = 5 + 3, 对应5 + 3, al=assignment l, 即赋值右侧
"               @ia : 选择函数调用的外部,整个被调用的函数,i=invoke(调用), ia=invoke all
"               @ii : 选择函数调用的内部,被调用函数的参数部分,ii=invoke inner
"               @ma : 整个注释,ma=co'm'ment all
"               @mi : 注释符里的部分(当前只支持python,yaml语言),mi=co'm'ment inner
"               @ra : 选择返回语句的外部部分,包含return关键字,例如return x, 会选中"return x", ra=return all
"               @ri : 选择返回语句的内部部分,不包含return关键字,例如return x, 只会选中x, ri=return inner 
"               @n  : 选中整个数字,n=number
"               @u  : 选择一个完整的语句块单元,u=unit
"               @ab : 语句块外部,括号+括号内部分,如{},(),[]等,ab=all block
"               @ib : 语句块内部,即只有括号内部分, ib=inner block
"                     [⚠️ ]Note: block文本对象的范围词与其他文本对象是反的,block的范围词在前,而其他在后,
"                               因为block范围词在后时,例如vbi,范围选择会不准确,只有vib正确
"               @ap : 选中函数参数,连同参数分隔符,如f(x, y),会选中 "x," 或者 ", y ", ap=all parameter
"               @ip : 只选中函数参数,不包含参数间分隔符,例如f(x, y),会选中"x"或者"y", ip=inner parameter
"                     [⚠️ ]Note: parameter文本对象的范围词与其他文本对象是反的,parameter的范围词在前,而其他在后,
"                               因为parameter范围词在后时,例如vpi,范围选择会不准确,只有vip正确
"             ▶ Tips: a. textobjects的作用重在选择文本范围,这些范围是基于treesitter
"                        语法树分析的结果,相比于基于表达式的更加智能和准确
"                     b. 光标不在语法点时,默认向下查找第一个语法点
"           ● 移动
"               @aj        : 回退到上一次光标位置
"               @ak        : 前进到下一次光标位置
"
"             ▶ 函数 (f=function)
"               @nfs / nfe : 跳转到下一个函数定义的开始处/结束处
"                            助记: nfs=next function start 
"                                  nfe=next function end
"               @pfs / pfe : 跳转到上一个函数定义的开始处/结束处
"                            助记: pfs=previous function start 
"                                  pfe=previous function end
"               @nf        : 跳转到下一个函数定义的开始处|结束处(如果当前在开始处,再按到结束处,反之亦然)
"               @pf        : 跳转到上一个函数定义的开始处|结束处(与上同理)
"
"             ▶ 循环 (o=loop)
"               @nos / noe : 跳转到下一个循环开始处/结束处
"               @pos / poe : 跳转到上一个循环开始处/结束处
"               @no        : 跳转到下一个循环开始处|结束处(如果当前在开始处,再按到结束处,反之亦然)
"               @po        : 跳转到上一个循环开始处|结束处(与上同理)
"
"             ▶ 条件选择 (s=select)
"               @nss / nse : 跳转到下一个条件选择开始处/结束处
"               @pss / pse : 跳转到上一个条件选择开始处/结束处
"               @ns        : 跳转到下一个条件选择开始处|结束处(如果当前在开始处,再按到结束处,反之亦然)
"               @ps        : 跳转到上一个条件选择开始处|结束处(与上同理)
"
"             ▶ 赋值语句 (a=assignment)
"               @nah / nal : 跳转到下一个赋值语句开始处/结束处
"               @pah / pal : 跳转到上一个赋值语句开始处/结束处
"               @na        : 跳转到下一个赋值语句开始处|结束处(如果当前在开始处,再按到结束处,反之亦然)
"               @pa        : 跳转到上一个赋值语句开始处|结束处(与上同理)
"
"             ▶ 函数调用 (i=invoke)
"               @nis / nie : 跳转到下一个函数调用开始处/结束处
"               @pis / pie : 跳转到上一个函数调用开始处/结束处
"               @ni        : 跳转到下一个函数调用开始处|结束处(如果当前在开始处,再按到结束处,反之亦然)
"               @pi        : 跳转到上一个函数调用开始处|结束处(与上同理)
"
"             ▶ 注释 (m=comment)
"               @nms / nme : 跳转到下一个注释开始处/结束处
"               @pms / pme : 跳转到上一个注释开始处/结束处
"               @nm        : 跳转到下一个注释开始处|结束处(如果当前在开始处,再按到结束处,反之亦然)
"               @pm        : 跳转到上一个注释开始处|结束处(与上同理)
"
"             ▶ 返回语句 (r=return)
"               @nrs / nre : 跳转到下一个返回语句开始处/结束处
"               @prs / pre : 跳转到上一个返回语句开始处/结束处
"               @nr        : 跳转到下一个返回语句开始处|结束处(如果当前在开始处,再按到结束处,反之亦然)
"               @pr        : 跳转到上一个返回语句开始处|结束处(与上同理)
"
"             ▶ 数字 (n=number)
"               @nns / nne : 跳转到下一个数字开始处/结束处
"               @pns / pne : 跳转到上一个数字开始处/结束处
"               @nn        : 跳转到下一个数字开始处|结束处(如果当前在开始处,再按到结束处,反之亦然)
"               @pn        : 跳转到上一个数字开始处|结束处(与上同理)
"
"             ▶ 语句块单元 (u=unit)                      
"               @ui        : 跳转到下一个语句块单元开始处  
"               @uu        : 跳转到上一个语句块单元开始处
"
"             ▶ 函数参数 (p=parameter)
"               @nps / npe : 跳转到下一个函数参数开始处/结束处
"               @pps / ppe : 跳转到上一个函数参数开始处/结束处
"               @np        : 跳转到下一个函数参数开始处|结束处(如果当前在开始处,再按到结束处,反之亦然)
"               @pp        : 跳转到上一个函数参数开始处|结束处(与上同理)
"
"             ▶ 代码块 (b=block)
"               @nbs / nbe : 跳转到下一个代码块开始处/结束处
"               @pbs / pbe : 跳转到上一个代码块开始处/结束处
"               @nb        : 跳转到下一个代码块开始处|结束处(如果当前在开始处,再按到结束处,反之亦然)
"               @pb        : 跳转到上一个代码块开始处|结束处(与上同理)
"
" zc 关闭光标下的折叠。
" zo 打开光标下的折叠。
" za 切换光标下的折叠状态。
" zm: 增加foldlevel，使更多的折叠关闭。
" zr: 减少foldlevel，使更多的折叠打开
" zR 打开所有折叠。
" zM 关闭所有折叠。
"   ▶ nvim-treesitter命令
"       @:TSInstall 语言 : 安装对应语言的语法解析器,例如C:
"                          TSInstall c
"       @:TSUpdate 语言  : 更新对应语言的解析器
"       @:TSUpdate all   : 更新所有语言解析器,或仅使用:TSUpdate
"       @:TSInstallInfo  : 查看所有可安装的语言解析器,及安装状态
"       @:TSBufToggle highlight : 启用treesitter高亮
"   
"   ▶ 查看光标处nvim-treesitter的高亮组
"       @:Inspect以显示光标下的突出显示组
"       @:InspectTree显示解析的语法树
"       @:EditQuery打开实时查询编辑器
" Tips:
"       助记: treesitter有关的命令为TS开头,TS=TreeSitter

" 配置 Neovim 中的代码折叠(folding)功能,特别是通过 Tree-sitter 语法树来控制折叠行为
set foldmethod=expr  " 设置折叠方法为表达式
" 设置折叠表达式为 Tree-sitter 提供的函数,即使用 vim.treesitter.foldexpr() 函数来决定折叠,
" 这个函数是由 Neovim 的 Tree-sitter 集成提供,它根据语法树的结构来计算折叠点
set foldexpr=v:lua.vim.treesitter.foldexpr()

lua << EOF
require'nvim-treesitter.configs'.setup {
  -- 需要安装的语言解析器的列表,这些语言的解析器将被安装(这里的设置主要用于首次启动nvim-treesitter时安装)
  ensure_installed = { "c", "lua", "vim", "vimdoc", "query", "markdown", "markdown_inline" },
  -- 当设置为 false 时，表示解析器的安装将是异步的，即不会阻塞 Neovim 的其他操作
  sync_install = false,
  -- 当设置为true时,如果进入一个缓冲区buffer且缺少相应的解析器,nvim-treesitter会自动安装缺失的解析器
  auto_install = true,
  -- 这是一个列表, 包含不应安装的解析器, 在这个例子中, "javascript" 解析器将被忽略
  ignore_install = { "javascript" },
  highlight = {
    -- 设置为 true 以启用基于 tree-sitter 的语法高亮
    enable = true,
    -- 可以是一个列表,列出不需要高亮的语言解析器,也可以是一个函数,用于在特定条件下禁用高亮,例如当文件大小超过100KB时
    disable = {},
    -- 设置为 false 表示不使用传统的Vim正则表达式高亮,仅使用tree-sitter进行高亮,这可以提高性能并减少高亮冲突
    additional_vim_regex_highlighting = false,
  },
  -- nvim-treesitter增量操作
  incremental_selection = {
    -- 启用增量选择功能,这允许通过自定义的快捷键逐步扩大或缩小代码的选择范围
    enable = true,
    -- 这是一个键映射表,定义了如何通过键盘操作来控制增量选择的行为
    keymaps = {
      -- 这个键绑定用于初始化选择。按下 sn 时,将选中光标下的最小语法节点,如果设置为 false,则此映射被禁用
      init_selection = "sn",
      -- 这个键绑定用于增加选择的范围。每次按下 sn,选择的范围会扩展到包含当前选择的下一个较大的语法节点
      node_incremental = "se",
      -- 这个键绑定用于按作用域逐步增加选择范围。按下 su 时,将扩展选择范围到当前节点的父级作用域
      scope_incremental = "su",
      -- 这个键绑定用于减小选择的范围。每次按下 sm,选择的范围会缩小到当前选择的下一个较小的语法节点
      node_decremental = "sm",
    },
  },
-- -------------------------------------                    nvim-treesitter-textobjects 
  -- textobjects对象
  textobjects = {
    -- 选择功能
    select = {
      -- 启用文本对象的选择功能
      enable = true,

      -- 在选择文本对象时自动向前查找,类似于Vim的targets.vim插件功能
      lookahead = true,

      -- 使用 keymaps 字典定义快捷键和对应的文本对象
      -- 这些映射允许通过特定的快捷键选择代码中的特定文本对象。每个键位映射关联到一个查询字符串,这些字符串指定了要选择的代码结构
      keymaps = {
        -- 使用 af 快捷键选择整个函数的外部区域。这意味着选择从函数的开始到结束的整个区块
        ["fa"] = "@function.outer",
        -- 使用 if 快捷键选择函数的内部区域, 不包括函数的声明和尾部的大括号
        ["fi"] = "@function.inner",
        -- 用 ac 快捷键选择整个类的外部区域, 包括类的所有内容和包围它的大括号
        ["ca"] = "@class.outer",
        -- 使用 ic 快捷键选择类的内部部分, 不包括类的大括号。此映射还包含一个描述, 说明了这个快捷键的功能,
        -- 这在使用如 which-key 这样的插件时可以显示给用户看
        ["ci"] = { query = "@class.inner", desc = "Select inner part of a class region" },
        ["oa"] = "@loop.outer",         -- 整个循环
		["oi"] = "@loop.inner",         -- 循环内的部分
		["sa"] = "@conditional.outer",  -- 条件选择(如if, else)整体
		["si"] = "@conditional.inner",  -- 条件选择语句的条件部分
		["ah"] = "@assignment.lhs",     -- 赋值语句左侧,例如x = 5 + 3, 对应x
		["al"] = "@assignment.rhs",     -- 赋值语句右侧,例如x = 5 + 3, 对应5 + 3
		["ia"] = "@call.outer",         -- 选择函数调用的外部,整个被调用的函数,i=invoke(调用)
		["ii"] = "@call.inner",         -- 选择函数调用的内部,被调用函数的参数部分
		["ma"] = "@comment.outer",      -- 整个注释
		["mi"] = "@comment.inner",      -- 注释符里的部分(当前只支持python,yaml语言)
		["ra"] = "@return.outer",       -- 选择整个返回语句,包含return关键字,例如return x, 会选中"return x"
		["ri"] = "@return.inner",       -- 选择返回语句,不包含return关键字,例如return x, 只会选中x
		["n"]  = "@number.inner",       -- 选中整个数字,n=number
		["u"]  = "@statement.outer",    -- 选择一个完整的语句块单元,u=unit
        ["ab"] = "@block.outer",        -- 代码块外部,括号+括号内部分,如{},(),[]等
		["ib"] = "@block.inner",        -- 代码块内部,即只有括号内部分
		["ap"] = "@parameter.outer",    -- 选中函数参数,连同参数分隔符,如f(x, y),会选中 "x," 或者 ", y "
		["ip"] = "@parameter.inner",    -- 只选中函数参数,不包含参数间分隔符,例如f(x, y),会选中"x"或者"y"
		-- ["ag"] = "@regex.outer",        -- 选择正则表达式的外部部分,支持vim      [暂未明确范围]
		-- ["ig"] = "@regex.inner",        -- 选择正则表达式的内部部分,支持bash,vim [暂未明确范围]
        -- 使用 ls 快捷键选择当前语言作用域。这个映射指定了查询组locals,这意味着它使用的是 locals.scm 查询文件中定义的作用域。
        -- 同样, 这里也提供了一个描述,帮助用户理解这个快捷键的作用
        -- ["ls"] = { query = "@scope", query_group = "locals", desc = "Select language scope" },
      },

      -- selection_modes 字典允许为不同的文本对象指定选择模式(字符选择、行选择或块选择)
      -- 例如, ['@function.outer'] = 'V' 表示选择整个函数时使用行选择模式。
      selection_modes = {
        ['@parameter.outer'] = 'v', -- charwise
        ['@function.outer'] = 'V', -- linewise
        ['@class.outer'] = '<c-v>', -- blockwise
      },
      -- 在选择文本对象时包括前导或后续的空白字符
      include_surrounding_whitespace = true,
    },

    -- 交换功能(当前状态: 关闭)
    swap = {
        enable = false,    -- 交换功能关闭
        swap_next = {
          ["<leader>a"] = "@parameter.inner",
        },
        swap_previous = {
          ["<leader>A"] = "@parameter.inner",
        },
    },

    -- 移动功能
    move = {
        enable = true,    -- 启用移动功能
        -- 当你设置 set_jumps = true 时,这意味着每次使用 nvim-treesitter 插件的文本对象移动功能时,都会在跳转列表(jumplist)中记录一个条目。
        -- 这允许你使用 Neovim 的跳转命令在编辑历史中前后移动
        -- 跳转命令:
        --    Ctrl-o :  后退到上一次光标位置(已自定义映射为: aj, a=at)
        --    Ctrl-i :  前进到下一次光标位置(已自定义映射为: ak)
        set_jumps = true, -- 在跳转列表中设置跳转点, 允许使用如 Ctrl-o 和 Ctrl-i 在跳转点之间前后移动
        goto_next_start = {
          ["nfs"] = "@function.outer",    -- 跳转到下一个函数定义开始处
          -- ["]]"] = { query = "@class.outer", desc = "Next class start" },
          -- ["]o"] = "@loop.*",
          -- ["]o"] = { query = { "@loop.inner", "@loop.outer" } },
          ["nos"] = "@loop.outer",        -- 跳转到下一个循环开始处
          ["nss"] = "@conditional.outer", -- 跳转到下一个条件选择开始处
          ["nah"] = "@assignment.lhs",    -- 跳转到下一个赋值语句的左侧(即赋值开始)
          ["nis"] = "@call.outer",        -- 跳转到下一个函数调用的开始处
          ["nms"] = "@comment.outer",     -- 跳转到下一个注释的开始处
          ["nrs"] = "@return.outer",      -- 跳转到下一个返回语句的开始处
          ["nns"] = "@number.inner",      -- 跳转到下一个数字的开始处
          ["ui"]  = "@statement.outer",   -- 跳转到下一个语句块单元的开始处
          ["nps"] = "@parameter.outer",   -- 跳转到下一个函数参数的开始处
                                          -- treesitter的参数头和参数尾解释:
                                          --          参数头          参数尾参数头          参数尾参数头          参数尾
                                          --            ↓                  ↓↓                    ↓↓                 ↓
                                          --        foo(struct mm_struct *mm, struct ma_state *mas, bool mm_wr_locked)
          ["nbs"] = "@block.outer",       -- 跳转到下一个语句块的开始

          -- ["]s"] = { query = "@scope", query_group = "locals", desc = "Next scope" },
          -- ["]z"] = { query = "@fold", query_group = "folds", desc = "Next fold" },
        },
        goto_next_end = {
          ["nfe"] = "@function.outer",    -- 跳转到下一个函数定义结束处
          -- ["]["] = "@class.outer",
          ["noe"] = "@loop.outer",        -- 跳转到下一个循环结束处
          ["nse"] = "@conditional.outer", -- 跳转到下一个条件选择结束处
          ["nal"] = "@assignment.rhs",    -- 跳转到下一个赋值语句的右侧(即赋值结束)
          ["nie"] = "@call.outer",        -- 跳转到下一个函数调用的结束处
          ["nme"] = "@comment.outer",     -- 跳转到下一个注释的结束处
          ["nre"] = "@return.outer",      -- 跳转到下一个返回语句的结束处
          ["nne"] = "@number.inner",      -- 跳转到下一个数字的结束处
          ["npe"] = "@parameter.outer",   -- 跳转到下一个函数参数的结束处
          ["nbe"] = "@block.outer",       -- 跳转到下一个语句块的结束
        },
        goto_previous_start = {
          ["pfs"] = "@function.outer",    -- 跳转到上一个函数定义开始处
          -- ["[["] = "@class.outer",
          ["pos"] = "@loop.outer",        -- 跳转到上一个循环开始处
          ["pss"] = "@conditional.outer", -- 跳转到上一个条件选择开始处
          ["pah"] = "@assignment.lhs",    -- 跳转到上一个赋值语句的左侧(即赋值开始)
          ["pis"] = "@call.outer",        -- 跳转到上一个函数调用的开始处
          ["pms"] = "@comment.outer",     -- 跳转到上一个注释的开始处
          ["prs"] = "@return.outer",      -- 跳转到上一个返回语句的开始处
          ["pns"] = "@number.inner",      -- 跳转到上一个数字的开始处
          ["uu"]  = "@statement.outer",   -- 跳转到上一个语句块单元的开始处
          ["pps"] = "@parameter.outer",   -- 跳转到上一个函数参数的开始处
          ["pbs"] = "@block.outer",       -- 跳转到上一个语句块的开始
        },
        goto_previous_end = {
          ["pfe"] = "@function.outer",    -- 跳转到上一个函数定义结束处
          -- ["[]"] = "@class.outer",
          ["poe"] = "@loop.outer",        -- 跳转到上一个循环结束处
          ["pse"] = "@conditional.outer", -- 跳转到上一个条件选择结束处
          ["pal"] = "@assignment.rhs",    -- 跳转到上一个赋值语句的右侧(即赋值结束)
          ["pie"] = "@call.outer",        -- 跳转到上一个函数调用的结束处
          ["pme"] = "@comment.outer",     -- 跳转到上一个注释的结束处
          ["pre"] = "@return.outer",      -- 跳转到上一个返回语句的结束处
          ["pne"] = "@number.inner",      -- 跳转到上一个数字的结束处
          ["ppe"] = "@parameter.outer",   -- 跳转到上一个函数参数的结束处
          ["pbe"] = "@block.outer",       -- 跳转到上一个语句块的结束
        },
        goto_next = {
          ["nf"] = "@function.outer",     -- 跳转到下一个函数定义的开始处|结束处
          ["no"] = "@loop.outer",         -- 跳转到下一个循环开始处|结束处
          ["ns"] = "@conditional.outer",  -- 跳转到下一个条件选择开始处|结束处
          ["na"] = "@assignment.lhs",     -- 跳转到下一个赋值语句的左侧(即赋值开始)
          ["ni"] = "@call.outer",         -- 跳转到下一个函数调用的开始|结束
          ["nm"] = "@comment.outer",      -- 跳转到下一个注释的开始|结束
          ["nr"] = "@return.outer",       -- 跳转到下一个返回语句的开始|结束
          ["nn"] = "@number.inner",       -- 跳转到下一个数字的开始|结束
          -- ["nu"] = "@statement.outer",    -- 跳转到下一个语句块单元的开始|结束
          ["np"] = "@parameter.outer",    -- 跳转到下一个函数参数的开始|结束
          ["nb"] = "@block.outer",        -- 跳转到下一个语句块的开始|结束
        },
        goto_previous = {
          ["pf"] = "@function.outer",     -- 跳转到上一个函数定义的开始处|结束处
          ["po"] = "@loop.outer",         -- 跳转到上一个循环开始处|结束处
          ["ps"] = "@conditional.outer",  -- 跳转到上一个条件选择开始处|结束处
          ["pa"] = "@assignment.lhs",     -- 跳转到上一个赋值语句的左侧(即赋值开始)
          ["pi"] = "@call.outer",         -- 跳转到上一个函数调用的开始|结束
          ["pm"] = "@comment.outer",      -- 跳转到上一个注释的开始|结束
          ["pr"] = "@return.outer",       -- 跳转到上一个返回语句的开始|结束
          ["pn"] = "@number.inner",       -- 跳转到上一个数字的开始|结束
          -- ["pu"] = "@statement.outer",    -- 跳转到上一个语句块单元的开始|结束
          ["pp"] = "@parameter.outer",    -- 跳转到上一个函数参数的开始|结束
          ["pb"] = "@block.outer",        -- 跳转到上一个语句块的开始|结束
        },
    },
  },  
}

-- 增强键位映射的功能,使textobjects的move功能的移动操作可以重复执行,并且可以指定操作的方向
local ts_repeat_move = require "nvim-treesitter.textobjects.repeatable_move"

vim.keymap.set({ "n", "x", "o" }, ";", ts_repeat_move.repeat_last_move)
-- 反方向重复执行上一次光标移动,自定义映射为;;
vim.keymap.set({ "n", "x", "o" }, ";;", ts_repeat_move.repeat_last_move_opposite)

vim.keymap.set({ "n", "x", "o" }, "f", ts_repeat_move.builtin_f_expr, { expr = true })
vim.keymap.set({ "n", "x", "o" }, "F", ts_repeat_move.builtin_F_expr, { expr = true })
vim.keymap.set({ "n", "x", "o" }, "t", ts_repeat_move.builtin_t_expr, { expr = true })
vim.keymap.set({ "n", "x", "o" }, "T", ts_repeat_move.builtin_T_expr, { expr = true })
EOF

" -------------------------------------                    nvim-treesitter-context 
" Usage:
"       @af : 跳转到顶部显示的代码上下文处,af=at first
lua <<EOF
require'treesitter-context'.setup{
  -- 启用treesitter提供代码上下文信息
  enable = true,
  -- 设置上下文窗口应跨越的行数。如果设置为<=0,则表示没有限制
  max_lines = 0,
  -- 设置启用上下文的最小编辑器窗口高度。如果设置为<=0,则表示没有限制
  min_window_height = 0,
  -- 如果设置为true, 则在上下文窗口中显示行号
  line_numbers = true,
  -- 设置单个上下文显示的最大行数
  multiline_threshold = 20,
  -- 如果 max_lines 被超过, 设置要丢弃的上下文行的范围。可选值为 'inner' 或 'outer'
  trim_scope = 'outer',
  -- 设置用于计算上下文的行。可选值为'cursor'(光标所在行)或'topline'(窗口顶部行)
  mode = 'topline',
  -- 设置上下文和内容之间的分隔符。应为单个字符字符串,如 '-'。当设置了分隔符时,只有当光标线上方至少有两行时,上下文才会显示。
  separator = nil,
  -- zindex用于确定页面上元素的堆叠顺序,即用于控制上下文窗口相对于其他可能的浮动窗口的堆叠顺序。一个较高的 zindex 值意味着上下文窗口将显示在其他较低 zindex 值的窗口之上
  zindex = 20,
  -- 允许用户根据缓冲区的类型或特定条件来启用或禁用上下文显示
  on_attach = nil,

  -- 快速跳转到顶部显示的代码上下文处
  vim.keymap.set("n", "af", function()
    require("treesitter-context").go_to_context(vim.v.count1)
  end, { silent = true })
}
EOF


" -------------------------------------                    vim-orgmode
"


" -------------------------------------                    far.vim
" Usage:
"   @
let g:far#enable_undo=1         " 支持撤回替换操作



" vim 个性化
" =============================================================================
" -------------------------------------                    vim字符样式
" 修改vim填充字符, 去掉'~'符号。 注: '\'后有个空格
set fillchars=eob:\ 

" 修改分割线样式
set fillchars+=vert:\⎜

" vim diff 模式下将删除部分的填充字符设置为空格
set fillchars+=diff:\ 

" -------------------------------------                    vim光标
" 设置所有模式下光标保持为不闪烁的块
set guicursor=a:block-iCursor-blinkon0      

" 终端模拟器光标颜色(此处用于控制vim-fzf插件打开的
" 搜索窗口中的光标颜色)
hi TermCursor ctermbg=NONE ctermfg=darkred

" 修改vim-easymotion插件搜索输入(按/)时双光标问题的
" 第一个光标颜色(此问题属于nvim问题,还未修复)
hi Cursor ctermbg=166 ctermfg=166

" 自定义vim颜色配置
" `````````````````````````````````````````````````````````````````````````````
" -------------------------------------                    vim区域配色
" Note: 分割线颜色(必须放在vim配置的最后，否则不生效)
" nvim使用WinSeparator控制垂直分割线
hi WinSeparator cterm=bold ctermbg=NONE ctermfg=22   

" 当前行&当前行行号&当前列颜色
highlight CursorLine cterm=bold ctermfg=NONE ctermbg=NONE
highlight CursorLineNr cterm=bold ctermfg=black ctermbg=NONE
hi CursorColumn cterm=bold ctermfg=NONE ctermbg=151

" 设置行号颜色为浅灰色
highlight LineNr ctermfg=249

" 设置括号对的颜色
highlight MatchParen cterm=bold ctermbg=yellow ctermfg=Red

" 多窗口时底部状态栏的分割线颜色
highlight StatusLine cterm=NONE ctermfg=NONE ctermbg=23
highlight StatusLineNC cterm=NONE  ctermfg=NONE ctermbg=23

" 底部状态栏显示的字体颜色
highlight StatusLine cterm=bold ctermbg=23 ctermfg=15

" 底部模式字符颜色
hi ModeMsg cterm=bold ctermbg=NONE ctermfg=88   " 插入模式字符,例如'--插入--'
hi MoreMsg cterm=bold ctermbg=NONE ctermfg=88   " 查看模式,例如'--更多--' 

" vim 搜索匹配字符的颜色
hi Search cterm=NONE ctermbg=228 ctermfg=1
hi CurSearch cterm=NONE ctermbg=228 ctermfg=1

" 底部交互模式时信息提示字符颜色
hi Question cterm=NONE ctermfg=25

" vim diff模式下比较文本差异时的配色
highlight DiffAdd cterm=NONE ctermfg=23 ctermbg=194 " 新增文本背景色
highlight DiffDelete cterm=NONE ctermfg=1 ctermbg=224
highlight DiffChange cterm=NONE ctermfg=1 ctermbg=224
highlight DiffText cterm=NONE ctermfg=124 ctermbg=217

" vim 菜单配色
highlight PMenu cterm=NONE ctermfg=15 ctermbg=66           " 列表背景
highlight PMenuSel cterm=NONE ctermfg=15 ctermbg=106       " 列表选中项的背景
highlight PmenuSbar cterm=NONE ctermfg=NONE ctermbg=23     " 弹出菜单的滚动条区域背景
highlight PmenuThumb cterm=NONE ctermfg=white ctermbg=23   " 滚动条区域中的拖动条颜色

" vim浮动窗口
hi DiagnosticWarn ctermfg=130          " 浮动窗口警告字体颜色(当前用于coc插件)

hi WarningMsg ctermfg=130              " vim警告色

" 代码折叠相关配色
highlight Folded ctermfg=NONE ctermbg=NONE         " Folded 指的是被折叠起来的代码块
highlight FoldColumn ctermfg=NONE ctermbg=NONE     " 折叠列
highlight CursorLineFold ctermfg=NONE ctermbg=NONE " 光标所在行折叠

" vim 可视(块)模式下选中文字的背景色
highlight Visual ctermbg=194 ctermfg=23

" -------------------------------------                    vim语法通用部分配色
" Note: 语言相关的配色通过ftplugin目录下的x.vim进行单独配色,
"       例如c.vim为C语言配色, 语言文件中未指定的配色,将使用
"       vim的自动配色设置，就是下面的语法类型的设置
"
" Tips:
"       Q: 想修改某个字符的配色,如何查看它属于哪个高亮组？
"       A: 将光标放在该单词上,然后使用以下命令来检查该位置的语法组: 
"            :echo synIDattr(synID(line("."), col("."), 1), "name")
"       Q: 怎么查看某个高亮组是哪种配色方案？
"       A: 使用hi(highlight缩写)命令, 例如查看VertSplit的高亮色,命令如下:
"            :hi VertSplit     
"
" 语法类解释:
"     Normal        : vim普通文本(非语法块文字,及提示信息文字)
"     Comment       : 用于注释代码中的解释或说明        
"     Constant      : 常数,表示固定的数值、字符串或符号
"     Special       : 表示特殊字符或符号
"     Identifier    : 表示标识符或变量名  
"     Statement     : 语句中涉及到的语法关键字颜色 
"     PreProc       : 表示预处理指令 
"     Type          : 表示数据类型 
"     Underlined    : 表示下划线
"     Ignore        : 表示忽略的内容  
"     String        : 表示字符串 
"     Character     : 表示字符 
"     Number        : 表示数字
"     Boolean       : 表示布尔值 
"     Float         : 表示浮点数
"     Function      : 表示函数 
"     Conditional   : 表示条件语句
"     Repeat        : 表示循环语句
"     Label         : 表示标签
"     Operator      : 表示运算符 
"     Keyword       : 语法关键字颜色 
"     Include       : 表示包含的文件 
"     Define        : 表示宏定义 
"     Macro         : 表示宏 
"     PreCondit     : 表示预处理条件  
"     StorageClass  : 表示存储类 
"     Structure     : 表示结构体
"     Typedef       : 表示类型定义 
"     Tag           : 表示标签 
"     SpecialChar   : 表示特殊字符
"     Delimiter     : 表示分隔符
"     SpecialComment: 表示特殊注释

hi Normal ctermfg=238
hi Comment cterm=NONE ctermfg=242
hi Constant cterm=NONE ctermfg=88    
hi Special cterm=NONE ctermfg=5
hi Identifier cterm=NONE ctermfg=25
hi Keyword cterm=NONE ctermfg=130
hi Statement cterm=NONE ctermfg=130
hi PreProc cterm=NONE ctermfg=88
hi Type cterm=NONE ctermfg=28
hi Ignore cterm=NONE ctermfg=88
hi String cterm=NONE ctermfg=24
hi Character cterm=NONE ctermfg=88
hi Number cterm=NONE ctermfg=88
hi Boolean cterm=NONE ctermfg=136
hi Float cterm=NONE ctermfg=89
hi Function cterm=NONE ctermfg=25
hi Conditional cterm=NONE ctermfg=126
hi Repeat cterm=NONE ctermfg=5
hi Label cterm=NONE ctermfg=126
hi Operator cterm=NONE ctermfg=166
hi Keyword cterm=NONE ctermfg=red
hi Include cterm=NONE ctermfg=88
hi Define cterm=NONE ctermfg=126
hi Macro cterm=NONE ctermfg=25
hi PreCondit cterm=NONE ctermfg=31
hi StorageClass cterm=NONE ctermfg=130
hi Structure cterm=NONE ctermfg=89
hi Typedef cterm=NONE ctermfg=5
hi Tag cterm=NONE ctermfg=25
hi SpecialChar cterm=NONE ctermfg=88 
hi Delimiter cterm=NONE ctermfg=130
hi SpecialComment cterm=NONE ctermfg=239

" -------------------------------------                    nvim-treesitter语法配色
" Note:
"       (1) 在nvim-treesitter中,每种语言的Treesitter解析器都有自己的查询文件,
"           可在nvim-treesitter的每个语言解析器目录下找到 highlights.scm文件,
"           查看所有的捕获组,即可以被捕获和高亮的语法元素
"       (2) scm文件解释: 
"             ; Command command  ;表示.scm文件的注释
"             (command) @string  表示一个规则,将类型为command的节点
"                                高亮显示为string类型的颜色, 可以用
"                                hi命令修改string配色从而改变treesitter
"                                的语法配色
"       (3) 如何修改treesitter语法高亮色
"           修改@后的高亮组即可,例如.scm中有高亮组:
"             [
"               "sign"
"               "abort"
"             ] @keyword
"           用hi命令查看vim当前是否有keyword高亮组,如果有直接用hi命令重新设置高亮色:
"             hi keyword ctermfg=9

" vim语法配色
hi keyword ctermfg=130

" C语法配色
hi @keyword.import ctermfg=66       " #include
hi @keyword.conditional ctermfg=126 " if/else/case/switch
" [
"   "#if"
"   "#ifdef"
"   "#ifndef"
"   "#else"
"   "#elif"
"   "#endif"
"   "#elifdef"
"   "#elifndef"
"   (preproc_directive)
" ] @keyword.directive
hi @keyword.directive ctermfg=6
hi @keyword.directive.define ctermfg=126 " #define" @keyword.directive.define
" 循环关键词(for、while)颜色 
hi @keyword.repeat.c ctermfg=89

hi @type ctermfg=2      " typedef定义的类型等
hi @property ctermfg=66 " field_identifier,即字段名(结构体成员)

" -------------------------------------                    高亮显示y命令复制区域
" 定义高亮样式
highlight YankHighlight ctermbg=229
" 使用自动命令在复制后高亮显示
autocmd TextYankPost * silent! lua vim.highlight.on_yank {higroup="YankHighlight", timeout=200}


" 自定义vim自动命令
" `````````````````````````````````````````````````````````````````````````````
" -------------------------------------                    设置quickfix窗口高度
autocmd FileType qf setlocal winheight=20

" -------------------------------------                    自动关闭位置列表和quickfix列表
" 在位置列表/quickfix列表跳转完成后,自动关闭
" 位置列表/quickfix列表
autocmd FileType qf nnoremap <silent> <buffer> <CR> <CR>:lclose<CR>:cclose<CR>

" -------------------------------------                    关闭quickfix后,聚焦到之前的窗口
" Usage:
"       @q  : 关闭quickfix后,保持原始窗口的聚焦(vim默认关闭
"             qf窗口后,会改变原始窗口的聚焦,即关闭qf窗口后,
"             新聚焦的窗口不是进入qf窗口前的那个窗口)
autocmd FileType qf nnoremap <silent> <buffer> q :wincmd p<CR>:cclose<CR>


" 自定义vim快捷键映射
" `````````````````````````````````````````````````````````````````````````````
" -------------------------------------                    分屏
" Note: 
"       h=horizontal,水平
"       v=vertical,  垂直
" Usage:
"       @sh : 水平分屏
"       @sv : 垂直分屏
" Tips: 
"       助记: sh=split horizontal, 切分水平
"             sv=split vertical,   切分垂直
nnoremap <silent> sh :sp<CR>
nnoremap <silent> sv :vsp<CR>

" -------------------------------------                    增加/减少垂直分屏宽度
" Usage:
"       @vm  : 增加垂直分屏宽度
"       @vn  : 减少垂直分屏宽度
" Tips: 
"       助记: vm=vertical max, 即垂直变大
"             vn=vplit mini,   即垂直减小
" 增加垂直分屏宽度
nnoremap <silent> vm :vertical resize +20<CR>
" 减少垂直分屏宽度
nnoremap <silent> vn :vertical resize -20<CR>

" -------------------------------------                    增加/减少水平分屏高度
" Usage:
"       @hm :增加水平分屏高度
"       @hn :减少水平分屏高度
" Tips:
"       助记: hm=horizontal max, 即水平变大
"             hn=horizontal mini,即水平减小
" 增加水平分屏高度
nnoremap <silent> hm :resize +10<CR>
" 减少水平分屏高度
nnoremap <silent> hn :resize -10<CR>

" -------------------------------------                    窗口分屏均匀化/最大化(即单独显示分屏)
" Usage:
"       @wn : 恢复窗口到vim默认布局(标准大小)
"       @wm : 分屏最大化(即分屏单独显示为全屏)
" Tips: 
"       助记: wn=windows normal,即窗口标准化
"             wm=windows max, 即窗口最大化
nnoremap <silent> wn :wincmd =<CR>
nnoremap <silent> wm :only<CR>

" -------------------------------------                    垂直分屏<=>水平分屏
" Usage:
"       @vh : 2个垂直分屏转水平分屏
"       @hv : 2个水平分屏转垂直分屏
" Tips:
"       助记: vh=vertical 转 horizontal, 即垂直转水平
"             hv=horizontal 转 vertical, 即水平转垂直
nnoremap <silent> vh <C-w>t<C-w>K
nnoremap <silent> hv <C-w>t<C-w>H

" -------------------------------------                    垂直/水平分屏换位置
" Usage:
"       @wh : 将当前窗口移到左方
"       @wj : 将当前窗口移到上方
"       @wk : 将当前窗口移到下方
"       @wl : 将当前窗口移到右方
" Tips:
"       助记: w=window, 即窗口
nnoremap <silent> wh : wincmd H<CR>
nnoremap <silent> wj : wincmd K<CR>
nnoremap <silent> wk : wincmd J<CR>
nnoremap <silent> wl : wincmd L<CR>

" -------------------------------------                    移动窗口
" Usage:
"       @空格+h : 移到 左 窗口
"       @空格+j : 移到 上 窗口
"       @空格+k : 移到 下 窗口
"       @空格+l : 移到 右 窗口
nnoremap <silent> <Space>h <C-w>h
nnoremap <silent> <Space>j <C-w>k
nnoremap <silent> <Space>k <C-w>j
nnoremap <silent> <Space>l <C-w>l

" -------------------------------------                    快速垂直滚动
" Usage:
"       @shift+j    : 单按1次▶光标上移20行, 持续按▶以20行/秒的速度向上滚动
"       @shift+k    : 单按1次▶光标下移20行, 持续按▶以20行/秒的速度向下滚动
map <silent> <S-j> 20<Up>
map <silent> <S-k> 20<Down>

" -------------------------------------                    快速水平滚动
" Usage:
"       @shift+h    : 单按1次▶光标左移5个字符, 持续按▶以5个字符/秒的速度向左滚动
"       @shift+l    : 单按1次▶光标右移5个字符, 持续按▶以5个字符/秒的速度向右滚动
map <silent> <S-h> 5<Left>
map <silent> <S-l> 5<Right>

" -------------------------------------                    单行移动
" Usage:
"       @j      : 上移一行
"       @k      : 下移一行
" Tips: 
"       1. 快速滚动到目标区域附近后，通过j、k以单行向上、下移动
"       2. 以下设置在所有模式下都生效
"       3. 加速vim方向键移动, 需修改mac设置, 方法如下
"          ● Mac: 系统偏好设置 -> 键盘 -> 调整"键重复速率"
"            和"重复前延迟"滑块, 将"键重复速率"设置为最快, 
"            "重复前延迟"设置为最短
"          ● [⚠️ ] Mac自带的'简体拼音'输入法在修改此设置后, 
"                 存在偶发性失效的问题, 因此改用'搜狗拼音'
"                 输入法), 具体设置如下:
"                 (1) 在键盘->输入法 设置中, 关闭'使用大写
"                     锁定键切换"ABC"输入法'
"                 (2) 下载'搜狗拼音'输入法,并在Mac输入法中
"                     添加,添加方法:
"                     系统设置->键盘->输入法->按+号->简体中文,
"                     选择'搜狗拼音'(当搜狗拼音安装完成后,
"                     会在简体中文中显示)

map <silent> j <Up>
map <silent> k <Down>

" -------------------------------------                    退出窗口/buffer
" Usage:
"       @q      : 退出当前窗口/buffer
"       @空格+q : 退出所有窗口/buffer
nnoremap <silent> q :q<CR>
nnoremap <silent> <Space>q :qa<CR>

" -------------------------------------                    光标回行首/尾
" Usage:
"       @aa : 光标回行首
"       @ee : 光标回行尾
noremap <silent> aa 0
noremap <silent> ee $
  
" -------------------------------------                    光标回行首/尾+进入插入模式
" Usage:
"       @ai : 光标回行首+进入插入模式
"       @ei : 光标回行尾+进入插入模式(支持Normal+Insert模式)
nnoremap <silent> ai I
nnoremap <silent> ei A
inoremap <silent> ei <Esc>A

" -------------------------------------                    "注释快速编辑: 
" Usage:
"       @as     : 光标回行首+删除第一个字符+进入插入模式
"                 [适用]: 有注释如" abc, 要删除注释符,并且进入插入模式
"       @a+空格 : 删除光标后第一个字符+加空格+进入插入模式
"                 [适用]: 在""下,需要删除第2个",空格后,进入插入模式
" 删除光标后字符+增加空格+进入插入模式
nnoremap <silent> as 0s
nnoremap <silent> a<Space> ls<Space>

" -------------------------------------                    删除上/下一行
" Usage:
"       @cj : 删除上方一行
"       @ck : 删除下方一行
" Tips: 
"       助记: c=clear,表示清除
nnoremap <silent> cj kdd
nnoremap <silent> ck :let save_cursor = getpos(".")<CR>:execute save_cursor[1] + 1 . "delete"<CR>:call setpos('.', save_cursor)<CR>


" -------------------------------------                    清空上/下一行内容
" Usage:
"       @sj : 清空上一行内容
"       @sk : 清空下一行内容
" Tips:
"       助记: s=space,空格,表示变成空行,即清空行

" Tips: sj使用黑洞寄存器 "_ 删除从光标位置到行尾的内容,黑洞寄存器
"       可以避免不必要的剪贴板覆盖,对操作对环境的影响最小
nnoremap <silent> sj k0"_Dj
nnoremap <silent> sk :let save_cursor = getpos(".")<CR>:execute save_cursor[1] + 1 . "s/.*//"<CR>:call setpos('.', save_cursor)<CR>

" -------------------------------------                    清空当前行内容
" Usage:
"       @sl : 清空当前行内容, 助记:space line,清空行
nnoremap <silent> sl S<ESC>

" -------------------------------------                    清空当前行内容+进入插入模式
" Usage:
"       @空格+i : 清空行,并进入插入模式
" Tips: 空格+i=清空+insert
nnoremap <silent> <Space>i S

" -------------------------------------                    在上/下一行末尾进入插入模式 (支持Normal模式+插入模式)
" Usage:
"       @ej : 在上一行末尾进入插入模式(支持Normal+Insert模式)
"       @ek : 在下一行末尾进入插入模式
" Tips: 
"      助记: ej/ek中的e同时包含两个含义, e=end+edit,即末尾编辑
nnoremap <silent> ej kA
inoremap <silent> ej <Esc>kA
nnoremap <silent> ek jA
inoremap <silent> ek <Esc>jA

" -------------------------------------                    在上/下一行开头进入插入模式
" Usage:
"       @hj : 在上一行开头进入插入模式
"       @hk : 在下一行开头进入插入模式
nnoremap <silent> hj k0i
nnoremap <silent> hk j0i

" -------------------------------------                    在下一行进入插入模式+Tab缩进 (支持Normal模式+插入模式)
" Usage:
"       @tk : 在下一行开头进入插入模式,并增加Tab缩进
inoremap <silent> tk <Esc>ji<Tab>
nnoremap <silent> tk <Esc>ji<Tab>

" -------------------------------------                    移动当前行
" Usage:
"       @ctrl + j : 当前行上移
"       @ctrl + k : 当前行下移
nnoremap <silent> <C-j> :m-2<CR>
nnoremap <silent> <C-k> :m+1<CR>

" -------------------------------------                    增加空格
" Usage:
"   @g+空格 : 在光标前添加一个空格(generate space)
nnoremap <silent> g<Space> :normal! i<Space><Esc>

" -------------------------------------                    增加空行(光标保持当前行)
" Usage:
"       @gj : 在上方增加空行(光标在当前行不动)
"       @gk : 在下方增加空行(光标在当前行不动)
"       @ga : 在当前行上方+下方增加空行(光标在当前行不动), 进入插入模式
"       @go : 在上方 [ 上方无空行 ] 增加三行空行,并将光标位于中行, 进入插入模式  ᒥ ---    ᒣ
"             Tips: go=great o, 即大o(O)命令                                     ᒪ --- ⬆  ᒧ

"       @gu : 在下方 [ 下方无空行 ] 增加三行空行,并将光标位于中行, 进入插入模式  ᒥ --- ⬇  ᒣ
"             Tips: gu=generate u,u=under, 表示在……下面,即在当前行下面           ᒪ ---    ᒧ
"                   生成空白行
"       @ao : 在上方 [ 上方有空行 ] 增加三行空行,并将光标位于中行, 进入插入模式  ᒥ ---    ᒣ
"             Tips: ao=above o, above=上面, 即在行上方执行o命令                                 
"                                                                                ᒪ --- ⬆  ᒧ
"
"       @bo : 在下方 [ 下方有空行 ] 增加三行空行,并将光标位于中行, 进入插入模式  ᒥ --- ⬇  ᒣ
"             Tips: bo=bottom o, 在行底部执行o命令
"                                                                                ᒪ ---    ᒧ
nmap <silent> gj O<Esc>k
nmap <silent> gk o<Esc>j
noremap <silent> ga O<Esc>o
noremap <silent> go O<Esc>o<Esc>O
noremap <silent> gu o<Esc>O<Esc>o
noremap <silent> ao O<Esc>O
noremap <silent> bo o<Esc>o

" -------------------------------------                    增加换行
" Usage:
"   @g+Enter    : 将光标后的内容移入下一行(generate enter)
nnoremap <silent> g<CR> i<CR><Esc>

" -------------------------------------                    取消换行
" Usage:
"   @d+Enter    : 将下一行内容移入光标后(delete enter)
nnoremap <silent> d<CR> a<Del><Esc>

" -------------------------------------                    缩短组合前缀键等待延时(ms)
set timeoutlen=200

" -------------------------------------                    复制全文
" Usage:
"       @ya : 选中全文复制到vim剪贴板
"       @yb : 选中全文复制到系统剪贴板
" Note: 快捷映射使用vim Ex 命令
"       % : 表示选择整个文件。
"       y : 是 yank(复制)命令。
"       + : 指定使用系统剪贴板
" nnoremap <silent> ya :%y<CR>
nnoremap <silent> yb :%y+<CR>

" -------------------------------------                    剪贴全文
" Usage:
"       @da : 剪贴全文到vim剪贴板
"       @db : 剪贴全文到系统剪贴板 
" nnoremap <silent> da :%d<CR>
nnoremap <silent> db :%d+<CR>

" -------------------------------------                    复制光标到行尾
" Usage:
"       @yee : 复制光标至行尾内容到vim剪贴板
"       @ys  : 复制光标到行尾内容到系统剪贴板(s=system,
"              表示系统剪贴板)
" 映射 'ys' 以复制从光标到行尾的内容到系统剪贴板
nnoremap <silent> ys "+y$

" -------------------------------------                    删除光标到行尾
" Usage:
"       @dee : 删除光标到行尾内容到vim剪贴板
"       @ds  : 删除光标到行尾内容到系统(s=system)剪贴板
nnoremap <silent> ds "+d$

" -------------------------------------                    删除选中内容到系统剪贴板
" Note: "+寄存器,表示系统剪贴板
" Usage:
"       @dy : 删除选中内容到系统剪贴板
vnoremap <silent> dy "+d

" -------------------------------------                    删除光标到行尾+进入插入模式
" Usage:
"       @si : 清除光标到行尾+进入插入模式
"             Tips: 助记,s=space,清空,即清空光标到行尾内容
nnoremap <silent> si C

" -------------------------------------                    反转(逆序)文本
" Usage:
"       @:ReverseText : 反转全部文本
" command! ReverseText execute "g/^/m0"
command! ReverseText silent! %!gtac

" -------------------------------------                    逆序显示历史命令
" Note: 在macOS上,tac命令不是默认安装的,因为它是GNU的一部分,
"       而macOS使用的是BSD工具。tac命令用于将文件的内容以反
"       向顺序输出。为了在macOS上使用tac, 你可以安装GNU的coreutils,
"       它包括 tac 和其他 GNU 版本的常用命令,gtac(tac命令的GNU版本)
"       mac使用如下命令安装:
"           $ brew install coreutils
" Usage:
"   @hi  : 逆序显示历史命令(时间越近,位置越前)
function! HistoryReverse()
    execute "vertical botright Bufferize history"
    silent! %!gtac
endfunction
map <silent> hi :call HistoryReverse()<CR>

" -------------------------------------                    输入法自动切换英文
" Note: 由于改用'搜狗拼音'输入法(原因见:单行移动:3. 加速vim方向键移动)
"       此处需同时设置切换到'搜狗拼音'输入法的英文模式,具体如下:
"       (1) 安装:
"               ① 搜狗拼音
"               ② 搜狗输入法切换助手(Mac App即可下载)
"       (2) 设置:
"               ① 搜狗拼音: 
"                 ⓵ 偏好设置->常用->默认状态->中英文,改为'英文'
"                 ⓶ 高级->智能输入->自动切换到英文状态,选中此项
"               ② 搜狗输入法切换助手
"                 ⓵ 偏好设置->自动切换设置->终端->搜狗拼音默认状态->英文
           
" Normal/Visual模式自动切换到英文输入法(当前Mac已设置'搜狗拼音'
" 为首选输入法,默认状态为英文,即会切换到搜狗拼音的英文输入模式),
" 方式: 使用osascript执行AppleScript,该脚本会找到系统菜单栏中的输入法
"       切换图标,并选择搜狗拼音输入法
autocmd ModeChanged *:n,*:v silent !osascript -e 'tell application "System Events" to tell process "SystemUIServer" to tell (1st menu bar item of menu bar 1 whose description is "text input") to {click, click (1st menu item whose title is "搜狗拼音") of menu 1}'

" -------------------------------------                    Esc键快捷映射
" 将 'jk' 映射为 'Esc' 在插入模式和可视模式下
inoremap <silent> jk <Esc>
vnoremap <silent> jk <Esc>
" 在命令行模式下将 jk 映射为 <Esc>
cnoremap <silent> jk <C-c>

" -------------------------------------                    vim取消撤销操作(u)
" Usage:
"       @rr : 取消撤销操作(vim原Ctrl+r命令)
nnoremap <silent> rr <C-r>

" -------------------------------------                    保存写入(写入当前内容)
" Usage:
"       @ew : 当前修改内容写入(等价:w)
"             Tips: ew=ensure write : 确定写入
nnoremap <silent> ew :w<CR>

" -------------------------------------                    保存写入+退出
" Usage:
"       @we : (保持写入)保存并退出(等价:wq)
"             Tips: we=write exit : 写入并退出
nnoremap <silent> we ZZ

" -------------------------------------                    高亮光标所在行/列
" Usage:
"       @eh : 开启光标所在行高亮,再按一次关闭
"       @el : 开启光标所在列高亮,再按一次关闭
"       @et : 同时开启行列高亮
" Tips:
"       助记: eh=extrude hang(行), extrude=突出,即突出行
"             el=extrude lie(列), 突出列
"             et,t字母表示'十'的意思
" 定义一个变量来标记当前配置状态

" 高亮光标所在行
nnoremap <silent> eh :call ToggleHighlight()<CR>
let g:highlight_enabled = 0
function! ToggleHighlight()
    if g:highlight_enabled == 0
        " 开启高亮设置
        hi CursorLine cterm=bold ctermfg=NONE ctermbg=151
        hi CursorLineNr cterm=bold ctermfg=black ctermbg=151
        let g:highlight_enabled = 1
    else
        " 取消高亮设置
        hi CursorLine cterm=bold ctermfg=NONE ctermbg=NONE
        hi CursorLineNr cterm=bold ctermfg=black ctermbg=NONE
        let g:highlight_enabled = 0
    endif
endfunction

" 高亮光标所在列
nnoremap <silent> el :set cursorcolumn!<CR>
" 同时高亮行和列
nnoremap <silent> et :call ToggleHighlight()<CR>:set cursorcolumn!<CR>

" -------------------------------------                    显示Buffer列表并切换/关闭/分屏
" Usage:
"       @bl  : 使用quickfix显示buffer列表,在选项上按Enter即可跳转
"       @bj  : 使用quickfix显示buffer列表,在选项上显示位置字符(按下位置字符进行跳转)
"
"       ▶ 进入quickfix后:
"            @按Enter : 切换到对应buffer
"            @c       : 关闭该buffer,可按Tab多选
"            @h       : 水平分屏,可按Tab多选(默认在当前buffer下方打开新水平分屏)
"            @sj      : 在上方水平分屏,可按Tab多选
"            @v       : 垂直分屏,可按Tab多选(默认在当前buffer右侧打开新垂直分屏)
"            @hv      : 在左侧垂直分屏,可按Tab多选
"            @按Tab   : 多选
" Tips:
"       助记: bl=buffer list, 即buffer列表
"             bj=buffer jump, 即buffer跳转

let g:selected_buffers = []     " 选中的buffer列表

function! SwitchToBuffer()
  " 获取当前行的 buffer 编号
  let bufnr = getqflist()[line('.') - 1].bufnr
  " 检查buffer是否存在
  if buflisted(bufnr)
    " 切换到该 buffer
    let winid = bufwinnr(bufnr)
    if winid != -1
      " 如果 buffer 已经在某个窗口打开，则切换到那个窗口
      execute winid . 'wincmd w'
    endif
    cclose
    execute 'buffer' bufnr
  endif
endfunction

" tab选中的高亮色
hi SelectedBuffer ctermbg=228 ctermfg=1

" 开始一个新的自动命令组
" 关闭guickfix时清空选择的buffer
augroup ClearSelectedBuffers 
  " 清除 ClearSelectedBuffers 组中的所有现有自动命令
  autocmd!                   
  " 监听 quickfix 窗口关闭事件
  autocmd WinClosed * if getwininfo(win_getid())[0].loclist == 0 | let g:selected_buffers = [] | endif
augroup END

function! UpdateQuickfixHighlight()
  let l:qf_list = getqflist()
  " 清除之前的高亮
  call clearmatches()
  for i in range(len(l:qf_list))
    let l:bufnr = l:qf_list[i].bufnr
    if index(g:selected_buffers, l:bufnr) >= 0
      " 为选中的 buffer 添加高亮
      call matchadd('SelectedBuffer', '\V' . escape(l:qf_list[i].text, '\'))
    endif
  endfor
  call setqflist(l:qf_list)
endfunction

function! ToggleSelectBuffer()
  let current_line = line('.')     " 保存当前行号
  let bufnr = getqflist()[current_line - 1].bufnr
  let idx = index(g:selected_buffers, bufnr)
  if idx == -1
    call add(g:selected_buffers, bufnr)
  else
    call remove(g:selected_buffers, idx)
  endif
  call UpdateQuickfixHighlight()
  call cursor(current_line, 1)  " 恢复光标到当前行
endfunction

function! GetTargetBuffer()
  for check_bufnr in range(1, bufnr('$'))
    if buflisted(check_bufnr) && getbufvar(check_bufnr, '&buftype') != 'quickfix' && index(g:selected_buffers, check_bufnr) == -1 && check_bufnr != g:focused_bufnr
      return check_bufnr
    endif
  endfor
  return -1
endfunction

function! FindEmptyNonQuickfixBuffer()
    " 遍历所有 buffer
    for bufnr in range(1, bufnr('$'))
        " 检查 buffer 是否存在
        if bufexists(bufnr)
            " 检查 buffer 名称是否为空
            if bufname(bufnr) == ''
                " 检查 buffer 类型是否为空
                if getbufvar(bufnr, '&buftype') == ''
                    " 检查 buffer 是否未被修改
                    if getbufvar(bufnr, '&modified') == 0
                        " 找到符合条件的 buffer，返回其编号
                        return bufnr
                    endif
                endif
            endif
        endif
    endfor
    " 如果没有找到，返回 0
    return -1
endfunction

function! CloseQFBuffer() abort
    " 遍历所有的 buffer
    for bufnr in range(1, bufnr('$'))
        " 找到quickfix buffer
        if buflisted(bufnr) && getbufvar(bufnr, '&buftype') == 'quickfix'
            " 如果找到符合条件的 buffer，返回其编号
            execute 'bd' bufnr
        endif
    endfor
    " 如果没有找到符合条件的 buffer，返回 -1
    return -1
endfunction

function! HandleFoucsBuffer(bufnr)
  let suitable_bufnr = GetTargetBuffer()
  if suitable_bufnr != -1
    let winid = bufwinnr(suitable_bufnr)
    if winid != -1
      " 如果 buffer 已经在某个窗口打开，则切换到那个窗口
      execute winid . 'wincmd w'
    endif
    execute 'buffer' suitable_bufnr
    execute 'bd' a:bufnr
  else
    " 新建一个空白buffer吸引焦点,避免最后一个聚焦buffer关闭后,焦点聚焦在quickfix上,导致后面代码被阻塞
    enew
    let empty_bufnr = FindEmptyNonQuickfixBuffer()
    if empty_bufnr != -1
        cclose
        execute 'buffer' empty_bufnr
        execute 'Startify'
    endif
    execute 'bd' a:bufnr
    call CloseQFBuffer()
  endif
endfunction

" 检查是否能找到既不是空buffer也不是quickfix buffer的buffer
function! CheckBuffers() abort
    " 遍历所有的 buffer
    for bufnr in range(1, bufnr('$'))
        " 找到一个不是空buffer 和 quickfix buffer的buffer
        if buflisted(bufnr) && getbufvar(bufnr, '&buftype') != 'quickfix' && len(getbufline(bufnr, 1, '$')) != 0
            " 如果找到符合条件的 buffer，返回其编号
            return 1
        endif
    endfor
    " 如果没有找到符合条件的 buffer，返回 -1
    return -1
endfunction

function! CloseBuffers()
  let current_line = line('.')
  let bufnr = getqflist()[current_line - 1].bufnr

  if !empty(g:selected_buffers)
    " 关闭所有选中的 buffers
    for bufnr in g:selected_buffers
      if buflisted(bufnr)
        " 检查是否关闭了原始聚焦的 buffer
        if bufnr == g:focused_bufnr
          call HandleFoucsBuffer(bufnr)
        else
          execute 'bd' bufnr
        endif
      endif
    endfor
    let g:selected_buffers = []
  else
    " 关闭当前行的 buffer
    if buflisted(bufnr)
      " 检查是否关闭了聚焦的 buffer
      if bufnr == g:focused_bufnr
        call HandleFoucsBuffer(bufnr)
      else
        execute 'bd' bufnr
        execute 'wincmd p'
      endif
    endif
  endif

  if CheckBuffers() == 1
    call ShowBuffersWithActions() " 如果还有其他非quickfix buffer存在,刷新quickfix列表
    call SaveNonQuickfixWindowNR()
  endif
endfunction

function! DoSplit(direction)
  let current_line = line('.')
  let bufnr = getqflist()[current_line - 1].bufnr

  let action =''
  if a:direction == 'v'
      let action = 'vert sb'
  elseif a:direction == 'hv'
      let action = 'vert leftabove sb'
  elseif a:direction == 'h'
      let action = 'sb'
  elseif a:direction == 'sj'
      let action = 'above split | buffer'
  endif

  execute g:last_non_quickfix_window_nr . 'wincmd w'
  if !empty(g:selected_buffers)
    " 分屏所有选中的 buffers
    for bufnr in g:selected_buffers
      if buflisted(bufnr)
        cclose
        execute action bufnr
      endif
    endfor
    let g:selected_buffers = []
  else
    " 分屏当前行的 buffer
    if buflisted(bufnr)
        cclose
        execute action bufnr
    endif
  endif
  call SaveNonQuickfixWindowNR()
endfunction

" 定义一个全局变量来存储窗口编号
let g:last_non_quickfix_window_nr = -2

" 定义一个函数来检查窗口类型并保存窗口 ID
function! SaveNonQuickfixWindowNR()
    " 检查当前窗口是否为 quickfix 窗口
    if &buftype != 'quickfix'
        " 不是 quickfix 窗口，保存窗口 ID
        let g:last_non_quickfix_window_nr = winnr()
    endif
endfunction

function! FocusToWindow()
  " 获取当前行的 buffer 编号
  let bufnr = getqflist()[line('.') - 1].bufnr
  " 检查buffer是否存在
  if buflisted(bufnr)
    " 切换到该 buffer
    let winid = bufwinnr(bufnr)
    if winid != -1
      " 如果 buffer 已经在某个窗口打开，则聚焦到那个窗口
      execute winid . 'wincmd w'
      let file_name = expand('%')
      echo 'Focus on '
      echohl DiffAdd
      echon file_name
      echohl None
      call SaveNonQuickfixWindowNR()
      execute 'wincmd p'
    endif
  endif
endfunction

function! ShowBuffersWithActions()
  " 创建一个列表来存储 buffer 信息
  let buffer_list = []
  let win_buffers = {}
  " 遍历所有窗口，收集窗口中的 buffer 编号
  for winid in range(1, winnr('$'))
    let bufnr = winbufnr(winid)
    if buflisted(bufnr) && getbufvar(bufnr, '&buftype') != 'quickfix'
      let win_buffers[bufnr] = bufname(bufnr)
    endif
  endfor
  " 遍历所有已列出的 buffer
  for bufnr in range(1, bufnr('$'))
    " 过滤掉 quickfix 类型的buffer
    if buflisted(bufnr) && getbufvar(bufnr, '&buftype') != 'quickfix'
      let buffer_name = bufname(bufnr)
      " 确保每个 buffer 只被添加一次
      if !has_key(win_buffers, bufnr)
        let win_buffers[bufnr] = buffer_name
      endif
    endif
  endfor
  " 添加 buffer 信息到列表
  for bufnr in keys(win_buffers)
    " 获取 buffer 的名称
    let buffer_name = win_buffers[bufnr]
    call add(buffer_list, {'filename': buffer_name, 'lnum': 1, 'text': 'Buffer ' . bufnr . ': ' . buffer_name, 'bufnr': bufnr})
  endfor

  " 在进入quickfix窗口之前保存当前聚焦的buffer编号
  let g:focused_bufnr = bufnr('%')

  call SaveNonQuickfixWindowNR()

  " 使用列表设置 quickfix
  call setqflist(buffer_list)
  " 使用 botright 前缀来确保 quickfix 窗口在底部打开
  botright copen

  " 在 quickfix 窗口中设置按键映射
  nnoremap <silent> <buffer> <CR> :call SwitchToBuffer()<CR>
  nnoremap <silent> <buffer> c :call CloseBuffers()<CR>
  nnoremap <silent> <buffer> h :call DoSplit('h')<CR>
  nnoremap <silent> <buffer> sj :call DoSplit('sj')<CR>
  nnoremap <silent> <buffer> v :call DoSplit('v')<CR>
  nnoremap <silent> <buffer> hv :call DoSplit('hv')<CR>
  nnoremap <silent> <buffer> f :call FocusToWindow()<CR>
  nnoremap <silent> <buffer> <Tab> :call ToggleSelectBuffer()<CR>
endfunction

nnoremap <silent> bl :call ShowBuffersWithActions()<CR>:botright copen<CR>
nnoremap <silent> bj :call ShowBuffersWithActions()<CR>:botright copen<CR>:<C-U>call EasyMotion#JK(0,0)<CR>


" -------------------------------------                    关闭当前Buffer
" Usage:
"       @eu : 关闭当前buffer
" Tips:
"       助记: eu=exit b'u'ffer, 即退出buffer
nnoremap <silent> eu :bd<CR>


" -------------------------------------                    恢复上次窗口布局
" Usage:
"       @wr : 恢复上次窗口布局
" Tips:
"       助记: wr=windows recover, 窗口恢复
" 保存当前布局到 session 文件
function! SaveSession()
    execute 'mksession! ~/.config/nvim/session/winrecord.vim'
endfunction

" 恢复 session 文件中的布局
function! RestoreSession()
    if filereadable(expand('~/.config/nvim/session/winrecord.vim'))
        execute 'source ~/.config/nvim/session/winrecord.vim'
    endif
endfunction

" 在离开任何窗口时自动保存 session
autocmd WinLeave * call SaveSession()
" 窗口独显(命令行执行:only命令)时自动保存session
"  自动命令,在命令行模式离开时触发。
"   (1) getcmdtype() 检查命令类型是否为普通命令(以 : 开始)
"   (2) getcmdline() 检查输入的命令是否是 only
"  如果这两个条件都满足,那么 SaveSession() 将被调用
autocmd CmdlineLeave : if getcmdtype() == ':' && getcmdline() == 'only' | call SaveSession() | endif

nnoremap <silent> wr :call RestoreSession()<CR>

" -------------------------------------                    新建tab
" Usage:
"       @nt  : 新建tab,nt=new tab
nnoremap <silent> nt :tabnew<CR>

" -------------------------------------                    进入命令行模式
" Usage:
"       @md : 进入vim命令行模式(支持可视模式)
" Tips:
"       @助记: md=com'm'an'd'
nnoremap md :
vnoremap md :

" -------------------------------------                    新建无文件缓冲区并命名
" Note: 在Vim中, 没有和文件关联的缓冲区称为无文件缓冲区(nofile buffer)
" Usage:                                                         
"       @bn : 按bn后提示输入名字,按Enter后会以该名字创建
"             一个空白buffer,并进入插入模式,bn=buffer new
" 新建的文件只存在于vim缓冲区,必须使用sf(save file)命令手动保存,否则不会存在
function! OpenBlankBufferWithInput()
    " 提示用户输入缓冲区名字
    let buffername = input('[Create No-File Buffer] Enter the buffer name: ')
    if buffername != ''
        " 创建一个新的空白缓冲区
        enew
        " 确保新缓冲区不会与任何实际的文件关联
        " 设置当前缓冲区的局部选项,而不影响其他缓冲区或全局设置。这意味着通过 setlocal 设置的任何选项只会应用于当前打开的缓冲区
        setlocal buftype=nofile    " 设置缓冲区的类型为无文件类型
        " 设置缓冲区的名字
        execute 'file ' . buffername
        " 清空命令行消息并强制刷新界面
        redraw!
        echo ""
        " 进入插入模式
        startinsert
    else
        redraw!
        echo ""
        " 创建一个新的空白缓冲区
        enew
    endif
endfunction
nnoremap <silent> bn :call OpenBlankBufferWithInput()<CR>

" -------------------------------------                    保存无文件缓冲区为文件
" Note: vim buftype 的类型
"         nofile  : 这种类型的缓冲区不与任何文件关联,不会被写入磁盘
"         nowrite : 这种类型的缓冲区不能被保存
"         quickfix: 快速修复窗口的缓冲区,通常用于显示搜索结果或编译错误
"         help    : 帮助窗口的缓冲区,用于显示 Vim 的帮助文档
"         acwrite : 当尝试写入缓冲区时,会触发BufWriteCmd事件,允许通过自定义命令处理写入操作
" Usage:
"       @hf : 无文件缓冲区保存为文件
" Tips: 助记, hf=hold file, 即保存为文件, hold=保存
function! SaveFileWithBrowse()
    " 获取当前缓冲区的文件名，不包括路径
    let filename = expand('%:t')
    let overwrite = 0

    " 首先询问用户是否保存在当前路径
    let currentPath = expand('%:p:h') . '/'   " 取当前文件的目录路径,并确保路径以斜杠(/)结尾
    echo ""
    echo 'Save to current path (' . currentPath . ')? [y/n] (default y): '
    let userChoice = getchar()
    " 检查是否按下了y或Enter键(其ASCII值为13)
    if userChoice == char2nr('y') || userChoice == 13
        " 如果选择 'y' 或输入空(按Enter), 则使用当前路径
        let savePath = currentPath
    else
    " 如果用户选择 'n'，则提示输入新的路径
        let savePath = ''
        while savePath == ''
            redraw! 
            let savePath = input('Enter new path: ', '', 'dir')
            " 如果用户取消对话框或未选择路径
            if savePath == ''
                echo ""
                echo '[Empty Path] save canceled'
                return
            endif
            " redraw!强制刷新屏幕显示
            redraw! 
            echo ""
            echo 'Will be saved in path '
            echohl DiffAdd
            echon savePath
            echohl None
            echo 'Confirm? [y/n] (default y): '
            let choice = getchar()
            if choice == char2nr('y') || choice == 13
                break
            elseif choice == 'n'
                let savePath = ''
            endif
        endwhile
    endif

    let saveFile = savePath . filename
    " 检查文件是否存在并且可读
    while filereadable(saveFile)
        " 提示用户文件已存在，并询问是否覆盖
        redraw!
        echo ""
        echohl Search
        echo '[!] File already exists.'
        echohl None
        echo 'Overwrite? [y/n] (default n): '
        let mychoice = getchar()
        " 如果选择不覆盖
        if mychoice == char2nr('n') || mychoice == 13
            echo ""
            redraw!
            let filename = input('Enter new buffer name: ')
            if filename != ''
                " 重新设置当前缓冲区的名字
                execute 'file ' . filename
                let saveFile = savePath . filename
                continue
            else
                echo ""
                echo '[Empty Name] save canceled'
                return
            endif
        elseif mychoice == char2nr('y')
            let overwrite = 1
            break
        endif
    endwhile

    " 保存文件
    setlocal buftype= 
    " 保存当前缓冲区到一个新的文件路径,这个路径由变量savePath指定。saveas命令类似于:w命令,但它还会改变当前缓冲区的关联文件
    execute 'saveas! ' . saveFile

    redraw!
    " 显示确认信息
    echo ""
    echo 'File saved as '
    echohl DiffAdd
    if overwrite == 1
        echon saveFile
        echohl OverwriteMsg
        echon ' [Overwrite]'
        echohl None
    else
        echon saveFile 
    endif
    echohl None
endfunction
hi OverwriteMsg cterm=bold ctermfg=1 ctermbg=194 
nnoremap <silent> hf :call SaveFileWithBrowse()<CR>

" -------------------------------------                    无文件缓冲区重命名
" Usage:
"       @er : 无文件缓冲区重命名
" Tips: er=empty(buffer) rename, 即空文件缓冲区重命名
function! RenameNoFileBuffer()
    " 提示用户输入新的缓冲区名字
    let newname = input('[Rename No-File Buffer] Enter new buffer name: ')
    if newname != ''
        " 获取原buffer名字
        let oldname = bufname('%')
        " 重新设置当前缓冲区的名字
        execute 'file ' . newname
        if oldname != ''
            redraw!
            " 使用 echon 和 echohl 在一行内显示所有信息，并对特定部分高亮
            echo 'File renamed from '
            echohl Search
            echon oldname
            echohl None
            echon ' to '
            echohl DiffAdd
            echon newname
            echohl None
        else
            echon 'Rename to '
            echohl DiffAdd
            echon newname
            echohl None
        endif
    else
        echo 'Rename cancelled.'
    endif
endfunction
nnoremap <silent> er :call RenameNoFileBuffer()<CR>

" -------------------------------------                    文件缓冲区重命名
" Usage:
"       @re : 对已存在的文件重命名
" Tips: 
"       助记: re=rename, 即重命名
function! RenameFile()
    let old_name = expand('%')
    let new_name = input('[Rename File Buffer] Enter new filename: ', expand('%'))
    if new_name != '' && new_name != old_name
        exec ':w'  
        exec ':saveas ' . new_name
        exec ':bd!' . bufnr(old_name)  
        exec ':silent !rm ' . shellescape(old_name, 1) 
        redraw!
        " 使用 echon 和 echohl 在一行内显示所有信息，并对特定部分高亮
        " Note: 使用echon替代echo来连续输出文本,而不会自动添加新行。
        "       echohl用于设置接下来的文本高亮,直到遇到echohl None
        "       重置为默认格式
        echo 'File renamed from '
        echohl Search
        echon old_name
        echohl None
        echon ' to '
        echohl DiffAdd
        echon new_name
        echohl None
    else
        echo 'Rename cancelled.'
    endif
endfunction

nnoremap <silent> re :call RenameFile()<CR>

" -------------------------------------                    清空命令行的显示信息
" Usage:
"       @cl : 清空命令行的显示信息,cl=clear,清屏
nnoremap <silent> cl :echo ""<CR>

" -------------------------------------                    打开命令行窗口(可以用vi模式编辑命令行)
" Usage:
"       @hd : 打开命令行窗口,以vi模式编辑命令
" 命令行历史窗口(即命令行窗口)高度
set cmdwinheight=1
nnoremap <silent> hd :<C-f>

" -------------------------------------                    查看帮助文件txt文本中标题部分的内容
" Usage:
"       @en : 进入标题对应的内容
"       @ne : 返回到标题
" Tips: en=enter, 即进入
nnoremap <silent> en <C-]>
nnoremap <silent> ne <C-t>

" -------------------------------------                    返回上一次光标所在行
" Usage:
"       @lr : 返回上一次光标所在行
" Tips:
"       助记: lr=line recover, 即行恢复
" 定义一个函数，用于跳转到上一次光标所在的行
function! GoToLastCursorPosition()
    normal ``
endfunction

nnoremap <silent> lr :call GoToLastCursorPosition()<CR>

" -------------------------------------                    光标后退/前进到历史位置
" Note: Vim 的设计哲学是效率和实用性,因此它只在用户执行
"       显著的跳转操作时更新跳转列表
"       跳转命令:
"           Ctrl-o (向后跳转): 移动到较早之前的位置
"           Ctrl-i (向前跳转): 移动到较新的位置
" Usage:
"       @aj : 后退到上一次光标位置, a=at
"       @ak : 前进到下一次光标位置
nnoremap <silent> aj <C-o>
nnoremap <silent> ak <C-i>

" -------------------------------------                    跳转到匹配的括号
" Usage:
"       @bm : 将光标移动到括号上,按bm跳转到匹配的另一个括号
"             bm=bracket match, 括号匹配
nnoremap <silent> bm %


" vim 配色笔记
" =============================================================================
" vim 终端背景三元色(RGB):
"       红:226
"       绿:240
"       蓝:218

" Vim识别三种不同的终端：
"       @term——黑白终端；
"       @cterm——彩色终端；
"       @gui——Gvim窗口
" 对于cterm:
"       cterm可以用ctermfg设置前景色；用ctermbg设置背景色, 用cterm设置字体
" 可用颜色:
"       cterm-colors + 256色, cterm-colors如下:
" -------------------------------------                    cterm-colors
"       NR-16   NR-8    COLOR NAME ~
"	    0	    0	    Black
"	    1	    4	    DarkBlue
"	    2	    2	    DarkGreen
"	    3	    6	    DarkCyan
"	    4	    1	    DarkRed
"	    5	    5	    DarkMagenta
"	    6	    3	    Brown, DarkYellow
"	    7	    7	    LightGray, LightGrey, Gray, Grey
"	    8	    0*	    DarkGray, DarkGrey
"	    9	    4*	    Blue, LightBlue
"	    10	    2*	    Green, LightGreen
"	    11	    6*	    Cyan, LightCyan
"	    12	    1*	    Red, LightRed
"	    13	    5*	    Magenta, LightMagenta
"	    14	    3*	    Yellow, LightYellow
"	    15	    7*	    White

" tips:
"       1、想修改vim某个地方的颜色, 或者自定义配置的颜色不生效, 可以
"          使用:highlight命令列出当前vim所有高亮配色, 从中找到相近颜
"          色的配置项在.vimrc中进行修改, 如果修改没有生效,找到修改该
"          配置项的插件, 然后在 .vim/after 下新建一个同名的插件,例如
"          xxx.vim,将配色方案写在该文件中,vim在运行时会最后加载该目录的插件

" vim 快捷键映射模式说明
" =============================================================================
" Note: 快捷键映射插件操作的语法解释
"       @ nmap 和 nnoremap 的区别在于:
"               nmap:     会将键映射应用到 Normal、Visual、Select 和 Operator-pending 
"                         模式，可能会导致意外的行为，因为它会递归地展开键映射。
"               nnoremap: 只会将键映射应用到 Normal 模式，不会展开其他键
"                         映射，避免了潜在的问题


" vim tips
" =============================================================================
" Note: Q=Question, A=Answer, N=Note
" 1. 查看vim映射键组合是否有其他绑定,使用verbose map命令, 例如查看a有哪些映射绑定:
"       :verbose map a (加上verbose可以显示映射操作最后是由谁执行的)
" 2. 查看当前的快捷键所绑定的函数,使用map命令,例如查看,h所绑定的函数:
"       :map ,h
" 3. Q: vim 如何修改原有的插件映射?
"    A: 使用verbose map命令查看原映射对应的插件函数,然后直接把插件函数原封不动放在新的映射命令后面即可
"       (1) 例如, 有映射如下:
"               n gs <Plug>(scratch-insert-reuse)
"           现在想修改gs,换成新的映射命令,直接将gs后面的映射函数放在新的映射命令后面即可,如下:
"               nnoremap ab <Plug>(scratch-insert-reuse)
"       (2) 例如, 有映射如下:
"               n dm * :<C-U>call signature#mark#Purge("line")<CR>
"           现在想修改gs,换成新的映射命令:
"               nnoremap md :<C-U>call signature#mark#Purge("line")<CR>
"               
" 4. vim 查看全局变量的值，例如查看g:scratch_height的值:
"       :echo g:scratch_height
" 5. vim查看用set设置的某个选项的值, 例如查看signcolum的值:
"       :set signcolumn?
" 6. vim 查看某个内容的帮助信息,使用h命令,后面跟要查询的内容,如下:
"       :h g:scratch_height
" 7. vim 查看某个插件的帮助信息,h命令后跟插件名字,如下:
"       :h tagbar
" 8. 查看sign column里所有标记的信息
"       :sign list
" 9. Q: vim如何查看高亮组名称?
"    A: 将光标移动到要查看的位置,然后使用如下vim命令查看:
"       :echo synIDattr(synID(line('.'), col('.'), 1), 'name')
" 10.Q: vim如何查看高亮组颜色配置方案?
"    A: hi name(高亮组名字)
" 11.Q: 如何查看是哪个文件最后设置了这个高亮组?
"    A: :verbose highlight Pmenu
" 12.Q: vim如何查看帮助文件txt文本中标题部分的内容?
"    A: ctr+]转到标题对应部分(已自定义映射为en),ctrl+t返回(已自定义映射为ne)
" 13.Q: vim有些高亮组link到了其他高亮组,自定义配色无法生效
"    A: 在Vim中,如果一个高亮组通过links命令链接到了另一个高亮组,那么
"       它会继承被链接高亮组的所有属性, 如果你尝试直接修改ColorA的颜
"       色,而它已经链接到了ColorB, 修改将不会生效, 因为LineNrBelow的
"       颜色和属性会被 LineNr 的设置覆盖。
"       [解决方法]: 要修改ColorA的颜色,需要先断开它与ColorB的链接,然
"       后再应用新的颜色设置。通过在init.vim 文件中添加以下命令来实现: 
"       (1) 首先断开ColorA与ColorB的链接
"               highlight! link ColorA NONE
"       (2) 然后设置ColorA的颜色
"               highlight ColorA ctermfg=red ctermbg=black
" 14.Q: vim如何查看当前buffer的编号?
"    A: :echo bufnr('%')
" 15.Q: vim如何查看当前窗口的类型?
"    A: echo &buftype 或者 set buftype?
"       普通buffer为空,quickfix窗口为'quickfix'
" 16.Q: vim如何查看当前窗口id?
"    A: echo win_getid() 
" 17.Q: vim如何查看编号?
"    A: echo winnr()
" 18.Q: 查看buffer的窗口编号
"    A: echo bufwinnr(bufnr), bufnr为buffer编号
" 19.Q: 查看当前buffer状态是否已被修改
"    A: echo &modified, 0未修改,1已修改
" 20.Q: vim脚本中如何调用vim插件<Plug>开头的函数
"    N: <Plug>映射是为了让插件的功能可以被用户自定义键绑定而设计的。通常,这些<Plug>映射不是直接用于命令行模式的命令,
"       它们是为了在普通模式、插入模式或其他模式下使用的。如果你想在命令行模式下执行与 <Plug>(easymotion-j) 相关的动作,
"       需要找到这个 <Plug> 映射背后的实际 Vim 脚本命令, 并直接调用那个命令。通常, 这可以通过查看插件的源代码来实现
"    A: 例如,有如下映射:
"           ,k <Plug>(easymotion-j)
"       要在vim脚本中执行,k的动作,不能直接在命令行或脚本中执行:call <Plug>(easymotion-j),在插件源码中找到对应的vim函数,例如:
"          +-------------------------------------------------------------------------------------------------------------+
"          | vim-easymotion ❯ grep -r "<Plug>(easymotion-j)" .                                                           |      
"          | ./t/easymotion_spec.vim: Expect maparg('<Plug>(easymotion-j)', 'n') ==# ':<C-U>¹call EasyMotion#JK(0,0)<CR>'|               
"          +-------------------------------------------------------------------------------------------------------------+
"       <Plug>(easymotion-j) 对应的vim函数实际为 call EasyMotion#JK(0,0),所以在命令行或者vim脚本中可以直接执行call EasyMotion#JK(0,0)
"       [注¹]: <C-U> 是一个控制字符,用于在命令行模式中清除当前行。在实际使用时,不需要包括 <C-U>，可以直接执行
" 21.Q: vim临时取消某个映射,例如取消gn映射,将其映射为一个空操作
"    A: nnoremap gn <Nop>




" TODO:
" 1. org配置
     "let g:org_agenda_files=['~/org/index.org']
" 2. 状态栏非活动窗口状态栏前景色
"     airline_x_inactive xxx ctermfg=59 ctermbg=23 guifg=#4e4e4e guibg=#002b2b
"     airline_x_inactive_bold xxx cterm=bold ctermfg=59 ctermbg=23 gui=bold guifg=#4e4e4e guibg=#002b2b
"     airline_x_inactive_red xxx ctermfg=231 ctermbg=23 guifg=#ffffff guibg=#002b2b
"     airline_y_inactive xxx ctermfg=59 ctermbg=23 guifg=#4e4e4e guibg=#002b2b
"     airline_y_inactive_bold xxx cterm=bold ctermfg=59 ctermbg=23 gui=bold guifg=#4e4e4e guibg=#002b2b
"     airline_y_inactive_red xxx ctermfg=231 ctermbg=23 guifg=#ffffff guibg=#002b2b
"     airline_z_inactive xxx ctermfg=59 ctermbg=23 guifg=#4e4e4e guibg=#002b2b
"     airline_z_inactive_bold xxx cterm=bold ctermfg=59 ctermbg=23 gui=bold guifg=#4e4e4e guibg=#002b2b
"     airline_z_inactive_red xxx ctermfg=231 ctermbg=23 guifg=#ffffff guibg=#002b2b
"     airline_term_inactive xxx ctermfg=85 ctermbg=232 guifg=#9cffd3 guibg=#202020
"     airline_term_inactive_bold xxx cterm=bold ctermfg=85 ctermbg=232 gui=bold guifg=#9cffd3 guibg=#202020
"     airline_term_inactive_red xxx ctermfg=231 ctermbg=232 guifg=#ffffff guibg=#202020
"     airline_error_inactive xxx ctermfg=232 ctermbg=160 guifg=#000000 guibg=#990000
"     airline_error_inactive_bold xxx cterm=bold ctermfg=232 ctermbg=160 gui=bold guifg=#000000 guibg=#990000
"     airline_error_inactive_red xxx ctermfg=231 ctermbg=160 guifg=#ffffff guibg=#990000
"     airline_a_inactive xxx ctermfg=59 ctermbg=23 guifg=#4e4e4e guibg=#002b2b
"     airline_a_inactive_bold xxx cterm=bold ctermfg=59 ctermbg=23 gui=bold guifg=#4e4e4e guibg=#002b2b
"     airline_a_inactive_red xxx ctermfg=231 ctermbg=23 guifg=#ffffff guibg=#002b2b
"     airline_b_inactive xxx ctermfg=59 ctermbg=23 guifg=#4e4e4e guibg=#002b2b
"     airline_b_inactive_bold xxx cterm=bold ctermfg=59 ctermbg=23 gui=bold guifg=#4e4e4e guibg=#002b2b
"     airline_b_inactive_red xxx ctermfg=231 ctermbg=23 guifg=#ffffff guibg=#002b2b
"     airline_c_inactive xxx ctermfg=59 ctermbg=23 guifg=#4e4e4e guibg=#002b2b
"     airline_c_inactive_bold xxx cterm=bold ctermfg=59 ctermbg=23 gui=bold guifg=#4e4e4e guibg=#002b2b
"     airline_c_inactive_red xxx ctermfg=231 ctermbg=23 guifg=#ffffff guibg=#002b2b
" 3. undotree diff颜色高亮配置
"     function! ToggleHighlightForDiff()
"         " 获取当前窗口的名字
"         let l:winname = win_gettype()
"
"         " 检查窗口名是否为 'diff'
"         if l:winname == 'diff'
"             " 执行 TSBufToggle highlight
"             execute 'TSBufToggle highlight'
"         endif
"     endfunction
"
"     " 设置自动命令，在每次窗口改变时调用上面的函数
"     autocmd WinEnter * call ToggleHighlightForDiff()
" 4. 打开qf列表,显示位置字符后,按字符进行跳转
"     nnoremap m/ :<C-U>call signature#mark#List(0, 0)<CR>:let g:trigger_enter_in_quickfix = 1<CR><Plug>(easymotion-j)
"     定义一个标志变量，用于判断是否需要在 quickfix 窗口中执行 Enter
"     let g:trigger_enter_in_quickfix = 0
"
"     "autocmd CmdlineLeave * if g:trigger_enter_in_quickfix == 1 | execute "normal! \<CR>" | endif
"        
"     function! TriggerEnterInQuickfix()
"         echo "world"
"         let g:trigger_enter_in_quickfix = 1
"      endfunction
"
"     function! SetupCursorMovedForQF()
"         " if &ft == 'qf' && g:trigger_enter_in_quickfix == 1
"         if &ft == 'qf'
"             " 仅在当前缓冲区类型为 quickfix 时设置 CursorMoved 自动命令
"             autocmd CursorMoved <buffer> call TriggerEnterInQuickfix()
"         endif
"     endfunction
"     augroup QuickfixCursorMove
"         autocmd!
"         " 当进入任何窗口时调用 SetupCursorMovedForQF 函数
"         autocmd WinEnter,BufWinEnter * call SetupCursorMovedForQF()
"     augroup END
" 5. man.vim使用tab打开man手册打开内容时设置buffer内容半屏显示
" 6. nvim代码截屏到剪贴板/保存到指定位置
"    候选插件: 
"       (1) SergioRibera/codeshot.nvim
"       (2) mistricky/codesnap.nvim
"
"     lua << EOF
"     require('codeshot').setup{
"       bin_path = '/opt/homebrew/bin/sss_code', -- Path to the binary
"       -- ...
"       }
"
"     -- Key mappings for taking screenshots
"     vim.keymap.set('v', 'sc', ":SSSelected<CR>", {silent = true})
"     vim.keymap.set('v', '<Leader>sf', ":SSFocused<CR>", {silent = true})
"     EOF




