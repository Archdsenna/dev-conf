" vim 动词(动词表示对文本的操作)
" +----------+----------+--------------------------------------------------------+
" |d         |delete    |删除(不会进插入模式)                                    |
" +----------+----------+--------------------------------------------------------+
" |c         |change    |修改(会进插入模式)                                      |
" +----------+----------+--------------------------------------------------------+
" |y         |yank      |复制                                                    |
" +----------+----------+--------------------------------------------------------+
" |v         |visual    |选中                                                    |
" +----------+----------+--------------------------------------------------------+
" |p         |put       |粘贴                                                    |
" +----------+----------+--------------------------------------------------------+
"

" vim 名词(表示待编辑的文本对象)
" +----------+----------+--------------------------------------------------------+
" |w         |world     |一个单词                                                |
" +----------+----------+--------------------------------------------------------+
" |s         |sentence  |一个句子(以英文'.'结束作为一个句子)                     |
" +----------+----------+--------------------------------------------------------+
" |p         |paragraph |一个段落(不包含空行的内容块作为一个段落)                |
" +----------+----------+--------------------------------------------------------+
"

" vim 修饰符(可以理解为vim 介词, 表示待编辑文本的范围或者位置)
" +----------+----------+--------------------------------------------------------+
" |i         |inside    |表示在...之内(带i的命令不会包含周围空格)                |
" +----------+----------+--------------------------------------------------------+
" |a         |around    |表示环绕                                                |
" +----------+----------+--------------------------------------------------------+
" |t         |till      |向后移动到某个字符之前(不包括该字符)                    |
" +----------+----------+--------------------------------------------------------+
" |T         |Till      |向前移动到某个字符之后                                  |
" +----------+----------+--------------------------------------------------------+
" |f         |find      |向后移动到某个字符(包括该字符)                          |
" +----------+----------+--------------------------------------------------------+
" |F         |Find      |向前移动到某个字符                                      |
" +----------+----------+--------------------------------------------------------+
"

" vim 光标移动
" +----------+-------------------------------------------------------------------+
" |;         |重复执行上一次光标移动                                             |
" +----------+-------------------------------------------------------------------+
" |'(原,命令)|反方向重复执行上一次光标移动                                       |
" +----------+-------------------------------------------------------------------+
"

" vim 命令(动词+介词+名词):[删除|替换|复制|选中|移动]
" +----------+-------------------------------------------------------------------+
" |C         |删除光标到行尾的内容,并进入插入模式                                |
" +----------+-------------------------------------------------------------------+
" |dw        |删除光标后的单词及其后空格, d2w:删除2个单词及其后空格              |
" +----------+-------------------------------------------------------------------+
" |diw       |删除光标所在位置的单词, 不删除其后空格                             |                                              
" +----------+-------------------------------------------------------------------+
" |de        |删除光标到单词尾的所有内容                                         |
" +----------+-------------------------------------------------------------------+
" |dj / dk   |删除光标行+上/下一行                                               |
" +----------+-------------------------------------------------------------------+
" |dh / dl   |删除光标左/右侧的1个字符(删除2个: d2h/d2l)                         |
" +----------+-------------------------------------------------------------------+
" |dt+位置字符|删除到位置字符之前(不包含位置字符)                                |
" +----------+-------------------------------------------------------------------+
" |cw        |替换光标后的单词( 会进入插入模式 )                                 |
" +----------+-------------------------------------------------------------------+
" |ciw       |替换光标处的完整单词( 会进入插入模式 )                             |
" +----------+-------------------------------------------------------------------+
" |c2h / c2l |替换光标左侧/右侧的2个字符(会进入插入模式)                         |
" +----------+-------------------------------------------------------------------+
" |yj / yk   |复制光标行+上/下一行                                               |
" +----------+-------------------------------------------------------------------+
" |yh / yl   |复制光标左侧/右侧的1个字符(复制2个: y2h/y2l)                       |  
" +----------+-------------------------------------------------------------------+
" |ye        |复制光标到行尾的所有内容                                           |
" +----------+-------------------------------------------------------------------+
" |yt+位置字符|复制到位置字符之前(不包含位置字符)                                |
" +----------+-------------------------------------------------------------------+
" |yf+位置字符|复制到位置字符(包含位置字符)                                      |
" +----------+-------------------------------------------------------------------+
" |viw       |选中光标处一个单词(不包含其后空格)                                 |
" +----------+-------------------------------------------------------------------+
" |v2b       |向前选中2个单词                                                    |
" +----------+-------------------------------------------------------------------+
" |ve        |选中光标到行尾的所有内容(v模式下e可连续按)                         |
" +----------+-------------------------------------------------------------------+
" |xp        |交换2个字符的位置                                                  |
" +----------+-------------------------------------------------------------------+
" |ddp       |交行2行的位置                                                      |
" +----------+-------------------------------------------------------------------+
" |ea        |在单词末尾进入插入模式                                             |
" +----------+-------------------------------------------------------------------+
" |f+位置字符|移动第1个匹配的字符处,例如:fa,移动到第一个a字符,再按fa移动到下一个a|
" +----------+-------------------------------------------------------------------+
" |t+位置字符|移动到位置字符之前                                                 |
" +----------+-------------------------------------------------------------------+
"

" vim 前缀命令g:g在Vim中是一个非常灵活的前缀命令,它可以与其他命令一起使用来实现各种功能
" +----------+-------------------------------------------------------------------+
" |gg        |跳转到文件开头(G跳转到文件末尾)                                    |
" +----------+-------------------------------------------------------------------+
" |gf        |打开光标所在文件路径的文件                                         |
" +----------+-------------------------------------------------------------------+
" |ge        |移动光标到前一个单词的末尾                                         |
" +----------+-------------------------------------------------------------------+
" |gu        |将单词转为全小写(guw:光标后小写, guiw:光标处单词转小写)| 字母大小写|
" +----------+-------------------------------------------------------| 互相转换用|
" |gU        |将单词转为全大写(gUw:光标后大写, gUiw:光标处单词转大写)| ~命令     |
" +----------+-------------------------------------------------------------------+
"

" vim 命令快捷键总结 : 功能自上而下依次为[插入|删除|替换|剪切|复制|选中|撤销|移动]
" +----------+-------------------------------------------------------------------+
" |命令      |功能                                                               |
" +----------+-------------------------------------------------------------------+
" |a         |在当前字符后, 进入[插入]模式                                       |
" +----------+-------------------------------------------------------------------+
" |A         |在当前行尾，进入[插入]模式                                         |
" +----------+-------------------------------------------------------------------+
" |o         |在下一行, 进入插入模式                                             |
" +----------+-------------------------------------------------------------------+
" |O         |在上一行, 进入插入模式                                             |
" +----------+-------------------------------------------------------------------+
" |i         |在当前位置, 进入插入模式                                           |
" +----------+-------------------------------------------------------------------+
" |I         |在当前行行首, 进入插入模式                                         |
" +----------+-------------------------------------------------------------------+
" |s         |删除当前字符, 进入插入模式(2s,删除光变后2个字符并进入插入模式)     |
" +----------+-------------------------------------------------------------------+
" |S         |删除当前行，进入插入模式(与cc效果相同)                             |
" +----------+-------------------------------------------------------------------+
" |x         |删除光标后的1个字符(不进入任何模式), 3x: 删除光标后的3个字符       |
" +----------+-------------------------------------------------------------------+
" |X         |删除光标前的1个字符, 2X: 删除光标前的2个字符                       |
" +----------+-------------------------------------------------------------------+
" |r         |精确替换一个字符(不进入输入模式),可视模式下会把选中内容全部替换    |
" +----------+-------------------------------------------------------------------+
" |R         |在当前行进入替换模式，直接输入替换的文本覆盖原文本                 |
" +----------+-------------------------------------------------------------------+
" |C         |删除从当前光标位置到本行末尾的所有字符, 并进入插入模式             |
" +----------+-------------------------------------------------------------------+
" |D         |剪切从当前光标位置到本行末尾的所有字符                             |
" +----------+-------------------------------------------------------------------+
" |Y         |复制整行                                                           |
" +----------+-------------------------------------------------------------------+
" |V         |进入可视行模式,可以按行选中文本                                    |
" +----------+-------------------------------------------------------------------+
" |ctrl+v    |进入可视块模式,可以选择多行中的相同列                              |
" +----------+-------------------------------------------------------------------+
" |u / Ctrl+r|撤销修改/恢复修改                                                  |
" +----------+-------------------------------------------------------------------+
" |b         |向左按单词移动                                                     |
" +----------+-------------------------------------------------------------------+
" |w         |向右按单词移动                                                     |
" +----------+-------------------------------------------------------------------+
" |e         |移动到单词末尾                                                     |
" +----------+-------------------------------------------------------------------+
" |h         |向左按字符移动, 2h为向左移动两个字符                               |
" +----------+-------------------------------------------------------------------+
" |l         |向右按字符移动, 2l为向右移动两个字符                               |
" +----------+-------------------------------------------------------------------+
" |j         |向下移动一行(注意:自定义映射已修改为j向上移动)                     |
" +----------+-------------------------------------------------------------------+
" |k         |向上移动一行(注意:自定义映射已修改为k向下移动)                     |
" +----------+-------------------------------------------------------------------+
"

" vim 个性化快捷键总结(自定义的快捷映射)
" +----------+-------------------------------------------------------------------+
" |命令      |功能                                                               |
" +----------+-------------------------------------------------------------------+
" |q         |:q                                                                 |
" +----------+-------------------------------------------------------------------+
" |aa/ee     |光标回行首/尾                                                      |        
" +----------+-------------------------------------------------------------------+
" |ai/ei     |光标回行首/尾+进入插入模式                                         |        
" +----------+-------------------------------------------------------------------+
" |as        |光标回行首+删除第1个字符+并进入插入模式                            |
" +----------+-------------------------------------------------------------------+
" |a+空格    |删除光标后1个字符+加空格+并进入插入模式                            |
" +----------+-------------------------------------------------------------------+
" |sh        |水平分屏                                                           |
" +----------+-------------------------------------------------------------------+
" |sv        |垂直分屏                                                           |
" +----------+-------------------------------------------------------------------+
" |ya / yb   |复制全文到 vim剪贴板 / 系统剪贴板                                  |
" +----------+-------------------------------------------------------------------+
" |da / db   |删除全文到 vim剪贴板 / 系统剪贴板                                  |
" +----------+-------------------------------------------------------------------+
" |yee / ys  |复制光标到行尾内容到 vim剪贴板 / 系统剪贴板                        |
" +----------+-------------------------------------------------------------------+
" |dee / ds  |删除光标到行尾内容到 vim剪贴板 / 系统剪贴板                        |
" +----------+-------------------------------------------------------------------+
" |dy        |删除选中的内容到系统剪贴板(y=s'y'stem)                             |
" +----------+-------------------------------------------------------------------+
" |hi        |逆序显示历史命令(hi=history)                                       |
" +----------+-------------------------------------------------------------------+
" |jk        |替代Esc(返回Normal模式/退出Visual模式/退出命令行模式)              |
" +----------+-------------------------------------------------------------------+
" |rr        |取消撤销(u)操作                                                    |
" +----------+-------------------------------------------------------------------+
" |ej / ek   |在上/下一行末尾进入插入模式                                        |
" +----------+-------------------------------------------------------------------+
" |aj / ak   |在上/下一行开头进入插入模式                                        |
" +----------+-------------------------------------------------------------------+
" |cj / ck   |删除上/下一行(光标保持在当前行)                                    |
" +----------+-------------------------------------------------------------------+
" |sj / sk   |清空上/下一行内容(光标保持在当前行)                                |
" +----------+-------------------------------------------------------------------+
" |fw        |写入当前修改内容(等价:w,wh=write fixed,即写入确定)                 |
" +----------+-------------------------------------------------------------------+
" |wf        |保存并退出 (fw=fixed write,确定写入)                               |
" +----------+-------------------------------------------------------------------+
" |si        |清除光标到行尾内容,并进入插入模式(光标为删除前的位置)              |
" +----------+-------------------------------------------------------------------+
" |sl        |清空当前行内容(space line)                                         |
" +----------+-------------------------------------------------------------------+
" |空格+i    |清空当前行,并进入插入模式                                          |
" +----------+-------------------------------------------------------------------+
" |tk        |在下一行进入插入模式,并缩进一个tab                                 |
" +----------+-------------------------------------------------------------------+
" |hm / hn   |水平分屏增大/减小                                                  |
" +----------+-------------------------------------------------------------------+
" |vm / vn   |垂直分屏增大/减小                                                  |
" +----------+-------------------------------------------------------------------+
" |vh        |2个垂直分屏转水平分屏                                              |
" +----------+-------------------------------------------------------------------+
" |hv        |2个水平分屏转垂直分屏                                              |
" +----------+-------------------------------------------------------------------+
" |wh/wj/wk/wl|当前分屏左/上/右/下移                                             |
" +----------+-------------------------------------------------------------------+
" |eh / el   ||开启光标所在行/列高亮,再按一次关闭                                |
" +----------+-------------------------------------------------------------------+
" |et        |同时开启行列高亮                                                   |
" +----------+-------------------------------------------------------------------+
" |er        |退出当前buffer                                                     |
" +----------+-------------------------------------------------------------------+
" |bl        |显示buffer列表,按Enter跳转,按c关闭,按Tab多选                       |
" +----------+-------------------------------------------------------------------+
" |wr        |恢复上次窗口布局                                                   |
" +----------+-------------------------------------------------------------------+
" |en        |vim帮助文档txt跳转到标题对应的内容(原ctrl+]命令)                   |
" +----------+-------------------------------------------------------------------+
" |ne        |返回到标题(原ctrl+t命令)                                           |
" +----------+-------------------------------------------------------------------+
" |md        |进入vim命令行模式                                                  |
" +----------+-------------------------------------------------------------------+
" |nr        |文件重命名                                                         |
" +----------+-------------------------------------------------------------------+
" |lr        |返回上一次光标所在行                                               |
" +----------+-------------------------------------------------------------------+

" 命令助记规则表(todo: 把所有命令都补充上)
" +-----------------------------------+------------------------------------+--------------------------------------+-----------------+
" |快捷键组合类型                     |示例                                |解释                                  |说明             |
" +-----------------------------------+------------------------------------+--------------------------------------+-----------------+
" |控制键 + 单词头¹/单词尾²           |¹ 空格+b : 显示buffer列表           |窗口控制键(空格) + buffer 单词头      |                 |
" |                                   |² 空格+d : 列表显示之前使用的命令   |窗口控制键(空格) + command单词尾      |                 |
" +-----------------------------------+------------------------------------+--------------------------------------+-----------------+
" |动词(单词首字母) + 名词            |g+Enter                             |generate + Enter, 产生一个换行        |与vim动词无关,本 |     
" |                                   |g+空格                              |generate + 空格 , 产生一个空格        |组快捷键仅适用于 |
" |                                   |d+Enter                             |delete + Enter  , 删除光标后的换行    |Normal模式       |
" +-----------------------------------+------------------------------------+--------------------------------------+-----------------+
"
" vim 插件快捷键总结
" -------------------------------------                    按插件归类(插件按英文首字母排序)
" +----------+----------+--------+--------- ----+
" |  插  件  |  快捷键  |  功能  |  快捷键总数  |
" +----------+----------+--------+--------------+
" 
" +----------+----------+--------------+
"

" -------------------------------------                    按前缀键归类
" +----------+----------+---------------------+--------+
" |  前缀键  |  触发键  |  所属插件  |  组合  |  功能  |        
" +----------+----------+------------+--------+--------+
" 

" mac nvim支持python3
" =============================================================================
" 步骤:
"   1. 系统需要先完成安装python3
"       $ brew install python3
"   2. 安装nvim自带的python支持
"       2.1 因为mac不允许直接通过pip方式下载python组件以防止损坏系统环境,所以通过python的虚拟环境完成下载,如下:
"           $ python3 -m venv ~/.venv       // 创建一个python虚拟环境
"           $ source ~/.venv/bin/activate   // 激活虚拟环境
"           $ python3 -m pip install neovim // 下载nvim的python支持
"           $ which python3                 // 在虚拟环境中查看python3的安装路径
"           $ 在init.vim中将python3安装路径赋值给g:python3_host_prog变量
let g:python3_host_prog = '~/.venv/bin/python3'

" 通用配置
" =============================================================================
let mapleader = ","      " 定义<leader>键
set nocompatible         " 设置不兼容原始vi模式
filetype on              " 设置开启文件类型侦测
filetype plugin on       " 设置加载对应文件类型的插件。在~/.vim/ftplugin/下创建不同语言的缩进格式文件，例如c为c.vim。
set noeb                 " 关闭错误的提示
syntax enable            " 开启语法高亮功能
syntax on                " 自动语法高亮
set t_Co=256             " 开启256色支持
" set cmdheight=2          " 设置命令行的高度
set showcmd              " select模式下显示选中的行数
set ruler                " 总是显示光标位置
set laststatus=2         " 总是显示状态栏
set number               " 开启行号显示
set cursorline           " 高亮显示当前行
set showmatch            " 自动高亮匹配的括号
set whichwrap+=<,>,h,l   " 设置光标键跨行
set ttimeoutlen=0        " 设置<ESC>键响应时间
set backspace=2          " 解决vim由于兼容vi导致back删除键失效
set hidden               " 允许不保存切换buffer
set autoread             " 文件在Vim之外修改过，自动重新读入
set helpheight=999       " 查看帮助文档全屏
" set sidescroll=10      " 设置Vim中侧向滚动的粒度
set scroll=20            " 设置鼠标滚动时的滚动粒度(Max:40)
set scrolloff=20         " 进行行滚动时，当前行始终保持在屏幕中间
set signcolumn=auto:4    " 设置左侧符号区域最多显示4个字符(auto表示有标志才显示,没有不显示)
set textwidth=1000       " 设置每行文本的宽度最大为1000个字符(避免文本在超过这个值时被自动折行,所以设置一个较大的值)
set splitright           " 设置新垂直窗口在右侧
set splitbelow           " 设置新水平窗口在下面
set virtualedit=all      " 设置光标可在buffer的所有区域移动
set history=3000         " 设置vim最多保留的历史命令数


" 代码缩进和排版
" =============================================================================
set autoindent           " 与前一行同样等级缩进
set cindent              " 设置使用C/C++语言的自动缩进方式
set smartindent          " 智能的选择对齐方式
filetype indent on       " 自适应不同语言的智能缩进
set expandtab            " tab=空格
set tabstop=4            " tab等于4个空格(不同语言tab的空格数在语言类型文件中定义)
set shiftwidth=4         " 自动缩进空格数(换行时自动缩进的空格数)
set nowrap               " 禁止折行
set nofoldenable         " 禁用折叠代码

" vim 命令补全
" =============================================================================
" vim 控制命令行补全
set wildmenu                         " 命令模式下补全以菜单形式显示
set wildoptions=pum                  " 命令行模式候选项竖排列表显示
set wildmode=longest,full            " 自动补全时优先显示最长的匹配项，然后显示所有可能的匹配项
" Vim 中控制自动补全行为
set completeopt-=preview             " 补全时不显示窗口，只显示补全列表
set completeopt=menu,menuone,longest " 在自动补全时显示菜单，并在只有一个匹配项时自动完成，同时显示最长的匹配项


" 搜索设置
" =============================================================================
" set hlsearch           " 高亮显示搜索结果
set nohlsearch           " 关闭高亮搜索结果
set incsearch            " 输入搜索模式时，每输入一个字符，就自动跳到第一个匹配的结果
set ignorecase           " 搜索时大小写不敏感
set smartcase            " 智能大小写搜索

" vim 主题设置
" =============================================================================
set background=light


" vim 插件列表
" =============================================================================
call plug#begin('~/.config/nvim/plugged') " 设置nvim下vim-plug下载插件的路径
" -------------------------------------                                 git 相关
Plug 'airblade/vim-gitgutter'      " 实时显示git文件修改的地方
Plug 'tpope/vim-fugitive'          " git插件(显示branch,支持vim内使用git)
Plug 'rbong/vim-flog'              " 查看git graph
Plug 'zivyangll/git-blame.vim'     " 显示git blame
Plug 'christoomey/vim-conflicted'  " 有助于解决git合并冲突(未学)

" -------------------------------------                                 任务构建
Plug 'skywind3000/asynctasks.vim'  " vim内完成编辑&编译&运行
Plug 'skywind3000/asyncrun.vim'    " 同上

" -------------------------------------                                 调    试
" Plug 'lldb-tools/vim-lldb'       " 等待社区修复使用python3.12导致的
                                   " lldb插件问题

" -------------------------------------                                 代码注释
Plug 'tomtom/tcomment_vim'         " 快速注释代码

" -------------------------------------                                 头文件切换
Plug 'vim-scripts/a.vim'           " C代码,.c与.h切换

" -------------------------------------                                 vim 美化
Plug 'vim-airline/vim-airline'     " vim 状态栏美化
Plug 'vim-airline/vim-airline-themes' " vim airline主题
Plug 'flazz/vim-colorschemes'      " vim 状态栏主题

" -------------------------------------                                 语法标签类
Plug 'preservim/tagbar'            " 显示类/方法/变量
Plug 'kshenoy/vim-signature'       " 在当前行添加一个标签(mark)

" -------------------------------------                                 自动补全
Plug 'neoclide/coc.nvim', {'branch': 'release'} " 基于LSP自动补全
Plug 'jiangmiao/auto-pairs'        " 自动补全括号对
Plug 'tpope/vim-endwise'           " ifdef/endif补全
Plug 'SirVer/ultisnips'            " 支持快速操作代码片段的选项”和插值
Plug 'honza/vim-snippets'          " 提供许多常用编程语言代码片段

" -------------------------------------                                 语法树支持
Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'} 
                                   " nvim中使用treesitter(为源文件构建
                                   " 具体的语法树,并在源文件编辑时有效
                                   " 地更新语法树)
Plug 'nvim-treesitter/nvim-treesitter-textobjects' 
                                   " 为nvim提供基于语义的文本对象
Plug 'nvim-treesitter/nvim-treesitter-context' 
                                   " 顶部显示当前在所在的函数、类等代码
                                   " 数据信息

" -------------------------------------                                 文件管理
Plug 'preservim/nerdtree'          " 显示文件目录列表
Plug 'Xuyuanp/nerdtree-git-plugin' " 显示 NERDTree 中文件和文件夹的 
                                   " Git 状态标志
Plug 'tiagofumo/vim-nerdtree-syntax-highlight' " NerdTree文件类型高亮
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } } " (插件作用同下)
Plug 'junegunn/fzf.vim'            " vim 快速搜索并打开一个文件，支持
                                   " 文件内容预览

" -------------------------------------                                 搜    索
" Plug 'junegunn/vim-slash'          " 优化搜索,移动光标后清除高亮(目前
                                   " 没起作用)

" -------------------------------------                                 文本操作
Plug 'machakann/vim-sandwich'      " 添加/替换/删除成对的符号(含括/引号)
Plug 'godlygeek/tabular'           " 快速对齐文本
Plug 'tpope/vim-abolish'           " 处理单词变体(修改大小写、命名格式)
                                   " [未学]
Plug 'brooth/far.vim'              " 文本查找与替换(未学)
Plug 'tommcdo/vim-exchange'        " 简单文本交换(快速交换两个单词/句子)
Plug 'terryma/vim-expand-region'   " 扩展选中的文本范围到下一个最大的
                                   " 文本对象(字符->单词->行->段->文件)

" -------------------------------------                                 文本比较
Plug 'AndrewRadev/linediff.vim'    " 快速比较两个文本块

" -------------------------------------                                 Muti-Cursor
Plug 'terryma/vim-multiple-cursors'

" -------------------------------------                                 快速笔记
Plug 'mtth/scratch.vim'            " 顶部临时开个窗口记笔记,切换窗口会
                                   " 自动关闭                                   

" -------------------------------------                                 剪贴板
Plug 'christoomey/vim-system-copy' " 可以将内容复制到系统剪贴板(终端
                                   " 不同tab中的vim可以互相复制粘贴)
" 对于通过远程SSH运行Vim的情况下执行复制非常有用(当前未启用)
" Plug 'ojroques/vim-oscyank', {'branch': 'main'}                                            

" -------------------------------------                                 寄存器
Plug 'junegunn/vim-peekaboo'       " 打开vim的寄存器列表,从中选取曾经
                                   " 复制或者删除的内容

" -------------------------------------                                 quickfix列表
Plug 'sk1418/QFGrep'               " 可以在quickfix窗口中过滤结果
Plug 'stefandtw/quickfix-reflector.vim' " 可以编辑quickfix窗口,然后将
                                        " 内容写回buffer

" -------------------------------------                                 事务管理(Todolist)
Plug 'jceb/vim-orgmode'

" -------------------------------------                                 日期管理
Plug 'tpope/vim-speeddating'       " 快速对日期加/减天数
Plug 'mattn/calendar-vim'          " 显示日历

" -------------------------------------                                 光标移动
Plug 'easymotion/vim-easymotion'   " 让光标快速到达指定位置(包括行)

" -------------------------------------                                 buffer相关
Plug 'AndrewRadev/bufferize.vim'   " 在新buffer中显示命令的输出结果,
                                   " 可对输出结果进行复制

" -------------------------------------                                 窗口管理
Plug 'dstein64/vim-win'            " 显示窗口编号并h/j/k/l移动

" -------------------------------------                                 其他优化插件
Plug 'tpope/vim-repeat'            " 使用.重复上次的插件操作(未起作用)
Plug 'voldikss/vim-floaterm'       " 支持在vim上悬浮终端窗口
Plug 'mbbill/undotree'             " 以列表显示vim撤回了哪些修改
                                   " 以及修改的内容 
Plug 'chrisbra/NrrwRgn'            " 将注意力集中在一个选定的区域内，暂
                                   " 时隐藏其余部分
" Plug 'kien/rainbow_parentheses.vim' " 括号对彩色高亮(默认不开启)
Plug 'mhinz/vim-startify'          " vim启动界面,显示会话列表&历史文件
Plug 'dstein64/vim-startuptime'    " 显示vim启动时间

Plug 'tpope/vim-rsi'

call plug#end()


" vim 插件配置
" =============================================================================
" -------------------------------------                    vim-gitgutter
" Note: vim-gitgutter只有对被git跟踪的文件才会在编辑时显示diff，
"       新增的文件编辑时不会显示
" Usage: 以下命令需要让光标位于hunk(修改处)上
"   @bk                  : 显示当前buffer文件的所有修改块。命令速记, 'h'表示hunk(块，即修改的地方)
"   @(当前暂未映射)      : 暂存修改(会保留修改的内容，但是去掉符号标记)
"   @(当前暂未映射)      : 撤销修改
"   @(当前暂未映射)      : 对比显示diff: 左侧显示源文件，右侧显示修改的地方
"   @ha                  : 在quickfix中显示所有有修改的文件(会忽略更改未保存的文件)
"   @,d                  : 对比显示diff
"   @gn                  : 跳到下个修改块(hunk)
"   @gp                  : 跳到上个修改块(hunk)
"   @nk                  : 在修改块之间循环跳转
"   @gz                  : 折叠所有未更改的行

set updatetime=50                         " 检测更新时间
let g:gitgutter_sign_priority = 0         " 设置gitgutter标志的优先级,0为最高,数字越小优先级越高,
                                          " vim标志绘制顺序为由左往右(优先级由高到低)

let g:gitgutter_sign_allow_clobber = 0    " 禁止vim-gitgutter覆盖其他标记
" 禁止GitGutter抢占终端焦点,当GitGutter在终端中显示Git状态信息时,仍然可以在终端中输入命令或者进行其他操作
let g:gitgutter_terminal_reports_focus=0 
" 关闭浮动窗口方式显示hunk,而是在底部用新开窗口显示hunk
let g:gitgutter_preview_win_floating = 0
" 将所有修改块加载到quickfix列表中(会忽略所有未保存的更改,如果想在quickfix中显示必须:wq写入),
" 这样就可以通过点击hunk中的修改直接转到文件
nnoremap ha :Gqf<CR>
command Gqf GitGutterQuickFix | copen

" 控制是否全局启动GitGutter插件,按一次显示diff符号及类型,再按一次关闭
" nnoremap <Leader>c :GitGutterToggle<cr>
" 对比显示diff: 左侧显示源文件，右侧显示修改的地方
nnoremap <leader>d :GitGutterDiffOrig<cr>

" 预览当前文件的所有修改块(命令助记: _b_uffer hun_k_)
" Tips: bk=buffer hunk,即当前buffer文件的hunk(修改块)
nmap bk <Plug>(GitGutterPreviewHunk)   
" 暂存修改(当前暂未映射)
" nmap <未映射> <Plug>(GitGutterStageHunk)     
" 撤销修改(当前暂未映射)
" nmap <未映射> <Plug>(GitGutterUndoHunk)      

" git diff状态标志的颜色
highlight GitGutterAdd    cterm=bold ctermfg=22    " 新增的内容"+" 
highlight GitGutterChange cterm=bold ctermfg=130   " 修改的内容"~"
highlight GitGutterDelete cterm=bold ctermfg=1     " 删除的内容"-"

set foldtext=gitgutter#fold#foldtext()  " 折行的显示方式：+-- 45 lines (*): abcdef

" 折叠所有未更改的行, 可使用'zr' 展开大块上方和下方的 3 行上下文
" 按'gz', 折叠所有未更改的行, 按'zr'前后各展开3行
nnoremap gz :GitGutterFold<cr>   

" 增强在修改块之间跳转,在修改块之间跳转时可循环遍历所有缓冲区中的块
function! NextHunkAllBuffers()
  let line = line('.')
  GitGutterNextHunk
  if line('.') != line
    return
  endif

  let bufnr = bufnr('')
  while 1
    bnext
    if bufnr('') == bufnr
      return
    endif
    if !empty(GitGutterGetHunks())
      1
      GitGutterNextHunk
      return
    endif
  endwhile
endfunction

function! PrevHunkAllBuffers()
  let line = line('.')
  GitGutterPrevHunk
  if line('.') != line
    return
  endif

  let bufnr = bufnr('')
  while 1
    bprevious
    if bufnr('') == bufnr
      return
    endif
    if !empty(GitGutterGetHunks())
      normal! G
      GitGutterPrevHunk
      return
    endif
  endwhile
endfunction

nmap <silent> gn :call NextHunkAllBuffers()<CR>
nmap <silent> gp :call PrevHunkAllBuffers()<CR>

" 在跳转最后一个修改块时，将从头进行跳转(仅对当前buffer)
function! GitGutterNextHunkCycle()
  let line = line('.')
  silent! GitGutterNextHunk
  if line('.') == line
    1
    GitGutterNextHunk
  endif
endfunction
" 按'nk'在修改块间循环跳转(仅对当前buffer)
nmap <silent> nk :call GitGutterNextHunkCycle()<CR>
"                 Tips: nk=_n_ext hun_k_

" -------------------------------------                    nerdtree
" Usage:
"   @,n : 打开Nerdtree窗口,显示文件夹和文件列表
"
"   Nerdtree 操作命令
"   (1) 文件/文件夹操作
"       Note: root目录 = 顶层目录 = 根目录,表示Nerdtree目录的根目录
"       @u   : 将root目录向上移动一个目录
"       @U   : 与u相同,但会保持旧的root目录是打开状态
"       @e   : 进入文件夹内部浏览, 会在右侧开启小窗口进入文件夹列表
"       @O   : 递归地打开当前文件夹下的所有文件夹
"              Warn: nerdtree展开的文件夹如果包含数量巨大的子文件夹/子文件,Nerdtree会有很大的延迟,
"                    可以改用vim-floaterm插件提供的yazi文件管理器窗口,打开方式:
"                    ① vim命令: FloatermNew yazi
"                    ② 快捷键 : 空格 + y 
"       @o   : 可以打开① 文件/② 文件夹
"              ① 文件   : 在右侧窗口中打开文件
"              ② 文件夹 : 打开/关闭文件夹(按一下打开,再按关闭)
"       @x   : 关闭父级文件夹
"       @X   : 递归关闭当前文件夹下的所有文件夹
"       @p   : 返回到父目录
"       @P   : 返回到root目录(顶层目录/根目录)
"       @go  : 在预览窗口中打开文件, 光标将仍然保留在Nerdtree窗口中, 用于预览多个文件特别有用.
"       @i   : 以水平分割窗口打开文件
"       @gi  : 以水平分割窗口打开文件, 但光标仍然保留在Nerdtree窗口
"       @s   : 以垂直分割窗口打开文件
"       @gs  : 以垂直分割窗口打开文件, 但光标仍然保留在Nerdtree窗口
"       @t   : 在新标签页打开选择的文件, 并全屏
"       @T   : 在新标签页静默打开选择的文件, 并全屏, 因为是静默, 所以不会跳转到新窗口
"       @C   : 将当前所选文件夹改为根目录, 即将该文件夹作为顶层目录, 与O不同, O是在当前视图下将文件夹展开, C则是直接进入到文件夹
"       @cd  : 将当前文件夹改为CWD(当前工作目录)
"       @CD  : 将文件夹目录跳转到CWD(当前工作目录)中, 即将CWD作为顶层目录
"              Note: 要CD的目录只有是cd的子目录才能直接用CD把目录设置为Nerdtree的顶层目录。例如,用cd设置了CWD=/A/B/C,此时
"                    vim的工作目录位于C,如果现在想用CD设置B为顶层目录会无效,因为B不是C的子目录, 而是C的父级目录。所以要想
"                    用CD把目录设置为顶层目录,必需满足该目录是CWD(即cd设置的目录)的子目录。所以一般先用cd设置CWD,然后再用
"                    CD来设置想要成为顶层目录的目录
"       @m   : 对所选择的文件或文件夹弹出编辑菜单, 包括修改文件名、复制、移动、删除等操作
"       @I   : 显示系统隐藏文件
"       @f   : 开/关文件过滤器,Nerdtree启动时候会默认开启过滤器,不显示过滤的文件/文件夹,如果想显示按下f。
"              在'let NERDTreeIgnore=[]'的[]中添加要过滤的文件/文件夹
"       @FL  : 文件右侧显示文件总行数
"       @B   : 隐藏/显示书签, 如果显示书签, 还会将光标自动跳转至书签
"              <1> Nerdtree书签(Bookmark)操作
"                  @:Bookmark             +name     : 创建书签(为文件/文件夹), 命令后跟要设置的名字,例如 Bookmark name
"                  @:ClearBookmarks                 : 清除指定的书签,后跟要删除的书签名,例如 ClearBookmarks name
"                  @:ClearAllBookmarks              : 清除所有书签
"                  @:OpenBookmark         +bookmark : 打开书签,后跟书签名,对于文件夹书签,会将文件夹设为新根;对于文件书签,
"                                                     会在右侧窗口打开该文件以供编辑
"                  @:RevealBookmark       +bookmark : 显示书签位置,后跟书签名
"                  @:BookmarkToRoot       +bookmark : 将与书签对应的目录设为新的根目录,如果书签指向文件,则将改用文件父级目录作根目录
"                  @:EditBookmarks                  : 打开书签文件进行手动编辑, 例如删除无效书签
"                  @:ReadBookmarks                  : 重新读取书签
"
"   (2) 关闭&移动
"       @q          : 退出NerdTree窗口
"       @D          : 删除书签(在最上方的bookmark list里选择要删除的书签,按D删除光标所在行显示的书签)
"       @F          : 隐藏文件(将不显示任何文件,只显示文件夹),再按一次恢复文件显示
"       @ctrl +  j  : 移动到同级的下一个目录
"       @ctrl +  k  : 移动到同级的上一个目录
"       @K          : 移动到同级目录的第一个(在上方)
"       @J          : 移动到同级目录的最后一个(在下方)
"
"   (3) 全屏
"       @A  : 全屏进入NerdTree窗口(再按一次退出全屏窗口)
"
"   (4) 刷新
"       @r  : 刷新当前文件夹的缓存, 使界面刷新
"       @R  : 刷新整个文件夹树的缓存, 使整个界面更新
"
"   (5) 帮助
"       @?  : 快速显示帮助, 忘记命令时使用

nnoremap <silent> <leader>n :NERDTreeToggle<cr>
let g:NERDTreeFileExtensionHighlightFullName = 1
let g:NERDTreeExactMatchHighlightFullName = 1
let g:NERDTreePatternMatchHighlightFullName = 1
let g:NERDTreeHighlightFolders = 1
let g:NERDTreeHighlightFoldersFullName = 1
let g:NERDTreeDirArrowExpandable='›'
let g:NERDTreeDirArrowCollapsible='⌄'
highlight NERDTreeUp ctermfg=25
highlight NERDTreeDir ctermfg=23
highlight NERDTreeDirSlash ctermfg=23
highlight NERDTreeOpenable ctermfg=23
highlight NERDTreeClosable ctermfg=23
highlight NERDTreeExecFile ctermfg=1

" 设置Nerdtree过滤器要忽略掉的文件/文件夹
" Note: '\.d$[[dir]]', '\.o$[[file]]', 'tmp/cache$[[path]]'分别表示文件夹、文件、路径
let NERDTreeIgnore=['\.git$[[dir]]', '\.vscode$[[dir]]', '\.dSYM$[[dir]]', 'tags']

" -------------------------------------                    nerdtree-git-plugin
" Note: git状态只有在git仓库中才能正确显示，没有git信息的
"       目录无法显示，因为获取不到git元数据
let g:NERDTreeGitStatusGitBinPath = '/usr/bin/git'
let g:NERDTreeGitStatusUntrackedFilesMode = 'all'
let g:NERDTreeGitStatusShowClean = 1
let g:NERDTreeGitStatusShowIgnored = 1      " 显示ignore状态
" Note: git文件状态含义
"     @Modified      [ M ]   (已修改):  文件有修改
"     @Staged        [ S ]   (暂  存):  文件的当前版本已经被添加到了暂存区（Index）中，
"                                       准备提交到 Git 仓库中
"     @Untracked     [ + ]   (未跟踪):  表示文件存在于工作目录中，但尚未被 Git 跟踪。这
"                                       通常是新创建的文件，Git 不会自动跟踪它们
"     @Renamed       [ R ]   (重命名):  表示文件在提交中被重命名了
"     @Unmerged      [ U ]   (未合并):  表示文件存在于一个冲突的合并中，需要手动解决冲突后才能继续
"     @Deleted       [ - ]   (已删除):  表示文件在提交中被删除了
"     @Dirty         [ ! ]       (脏):  表示工作目录中有未被暂存的改动
"     @Ignored       [ I ]   (已忽略):  表示文件被添加到了.gitignore 中，Git 将忽略对这些文件的跟踪和管理
"     @Clean         [ √ ]   (干  净):  表示工作目录中没有未被跟踪的文件，也没有未提交的修改
"     @Unknown       [ ? ]   (未  知):  表示 Git 不识别文件的状态，通常是因为文件不在 Git 仓库中
" Note:
"     表示文件的git状态符号颜色在.vim/after/syntax/nerdtree.vim中进行设置
let g:NERDTreeGitStatusIndicatorMapCustom = {
                \ 'Modified'  :'M',
                \ 'Staged'    :'ꓢ',
                \ 'Untracked' :'+',
                \ 'Renamed'   :'R',
                \ 'Unmerged'  :'U',
                \ 'Deleted'   :'-',
                \ 'Dirty'     :'!',
                \ 'Ignored'   :'I',
                \ 'Clean'     :'√',
                \ 'Unknown'   :'?',
                \ }
highlight NERDTreeFlags ctermfg=22      " git 状态的[ ]颜色

" -------------------------------------                    airline
" Usage:
"       @空格+数字 : 切换到数字对应的buffer
"       @th        : 切换到上一个buffer(递减buffer编号)
"       @tl        : 切换到下一个buffer(递增buffer编号)
"                    Tips: 助记,t=tab
" Note:
"     Vim 状态栏(trailing、mixed-indent、mix-indent-file)的含义:
"         @Trailing (显示行尾空格): 显示行尾存在空格的行
"         @Mixed-indent(显示混合缩进): 显示当前行的混合缩进情况。
"           混合缩进是指当前行的缩进方式与文件中其他行的缩进方式不一致
"         @Mixed-indent-file(显示文件中的混合缩进):将文件中存在混合缩进的行数显示在状态栏中
if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif
let g:airline_theme="luna"                              " vim 状态栏主题
let g:airline#extensions#tabline#enabled = 1            " 顶部显示标签
let g:airline#extensions#tabline#show_splits = 1        " 显示每个tab打开的分割(仅当tab打开时)[好像没生效]
let g:airline#extensions#tabline#show_tabs = 1          " 显示tab，无论数量多少
let g:airline#extensions#tabline#show_tab_count = 1     " 显示tab数量
let g:airline#extensions#tabline#tab_nr_type = 1        " tab编号的显示类型(只显示序号，不显示该tab下分割的buffer数)
let g:airline#extensions#tabline#tabnr_formatter = 'tabnr' "tab显示样式
let g:airline#extensions#tabline#show_tab_nr = 1        " 显示tab编号
let g:airline#extensions#tabline#show_tab_type = 1      " 显示类型:[buffers]/[tabs]
let g:airline#extensions#tabline#formatter = 'unique_tail' " buffer文件只显示文件名,不显示路径

let g:airline#extensions#branch#enabled = 1     " 底部状态栏显示git分支
let g:airline#extensions#hunks#enabled = 1      " 底部状态栏显示修改记录
let g:airline#extensions#hunks#non_zero_only = 1 " 仅当有修改时显示
let g:airline#extensions#hunks#hunk_symbols = ['+', '~', '-'] " 底部状态栏显示增加/修改/删除的标记符号

let g:airline#extensions#tagbar#enabled = 1     " tagbar扩展[暂没明确作用]
let g:airline#extensions#fzf#enabled = 1        " fzf扩展[暂没明确作用]

let g:airline_symbols.branch = '⎇ '             " git分支图标
let g:airline_symbols.readonly = '🔒'           " 只读文件标记
let g:airline_symbols.colnr = '❯'               " 列符号
let g:airline_symbols.linenr = ' ❯'             " 行符号
let g:airline_symbols.maxlinenr = '🏁 '         " 行总数标记

" 开启buffer编号显示，按数字1、2等切换buffer,按-/+来递减/递增buffer
let g:airline#extensions#tabline#buffer_idx_mode = 1
nmap <Space>1 <Plug>AirlineSelectTab1
nmap <Space>2 <Plug>AirlineSelectTab2
nmap <Space>3 <Plug>AirlineSelectTab3
nmap <Space>4 <Plug>AirlineSelectTab4
nmap <Space>5 <Plug>AirlineSelectTab5
nmap <Space>6 <Plug>AirlineSelectTab6
nmap <Space>7 <Plug>AirlineSelectTab7
nmap <Space>8 <Plug>AirlineSelectTab8
nmap <Space>9 <Plug>AirlineSelectTab9
nnoremap <silent> th <Plug>AirlineSelectPrevTab
nnoremap <silent> tl <Plug>AirlineSelectNextTab
" buffer编号样式
let g:airline#extensions#tabline#buffer_idx_format = {
        \ '0': '⓿ ',
        \ '1': '① ',
        \ '2': '② ',
        \ '3': '③ ',
        \ '4': '④ ',
        \ '5': '⑤ ',
        \ '6': '⑥ ',
        \ '7': '⑦ ',
        \ '8': '⑧ ',
        \ '9': '⑨ '
        \}

" airline 依赖的扩展插件
" -------------------------------------                      vim-flog [airline extension]
" Usage: 
"   @gl         : 打开git commit graph
"   @ctrl+n     : 直接打开下一个commit
"   @ctrl+p     : 打开上一条commit
"   @u          : 刷新graph
"   @a          : 显示所有分支
"   @gq         : 退出git commit graph
" gl打开git提交历史 
nnoremap <silent> gl :Flog<cr>                    


" -------------------------------------                      tagbar
" 了解tagbar: https://github.com/vimcn/tagbar.cnx/blob/master/tagbar.cnx
" Usage:
"    @<F1>              :显示键映射帮助。
"    @<CR>/<Enter>      :跳转到当前光标下的 tag。如果是伪标签或一般的头信息则没作用.
"    @p                 :源文件跳转到当前光标下的 tag。但光标停留在 Tagbar 窗口。
"    @<LeftMouse>       :如果点击折叠图标，按折叠的当前状态开打开或关闭折叠。
"    @<2-LeftMouse>     :同 <CR>。如果希望使用单击替代双击，参考 |g:tagbar_singleclick|。
"    @<Space>           :在命令行显示当前 tag 的原型信息。(比如行号)
"    @+/zo              :打开当前光标下的折叠。
"    @-/zc              :如果光标下有折叠则关闭光标下的折叠，如果没有则关闭当前的折叠。
"    @o/za              :切换光标下的折叠状态，如果光标下没有折叠，切换当前的折叠状态。
"    @*/zR              :通过设置折叠级别(foldlevel)为 99 来打开所有的折叠。
"    @=/zM              :通过设置折叠级别为 0 来关闭所有的折叠。
"    @<C-N>             :转到下一个顶层 tag。
"    @<C-P>             :转到前一个顶层 tag。
"    @s                 :在 tag 名称排序和文件顺序排序中切换。
"    @x                 :切换 Tagbar 窗口的最大化。
"    @q                 :关闭 Tagbar 窗口。
let g:tagbar_width = 30
nnoremap <silent> <leader>t :TagbarToggle<cr>
let g:tagbar_sort = 0           " tagbar按照标签在文件中出现的顺序排序,1为按英文首字母顺序排列
let g:tagbar_autofocus = 1      " 在 Tagbar 窗口打开时，光标会自动移动到 Tagbar 窗口
" @TagbarKind: Tagbar 种类，通用的类型比如函数和变量的头。
highlight TagbarKind ctermfg=23
" @TagbarScope: Tagbar 范围，定义范围的 tags，比如 class,struct 等。
highlight TagbarScope ctermfg=25
" @TagbarType: tag 或范围的类型，如果是有的话。
highlight TagbarType ctermfg=1
" @TagbarSignature: 函数签名(参数颜色)
highlight TagbarSignature ctermfg=89
" @TagbarPseudoID: 星号表示伪标签。
" highlight TagbarPseudoID ctermfg=1
" @TagbarFoldIcon: 可折叠 tags 左边的图标。
highlight TagbarFoldIcon ctermfg=130
" @TagbarHighlight: 自动高亮的当前 tag 的颜色。
" @TagbarAccessPublic: "public" 可见性/可访问性符号(结构体成员前面的标识符)
highlight TagbarAccessPublic ctermfg=1
" @TagbarAccessProtected: "protected" 可见性/可访问性符号。
highlight TagbarAccessProtected ctermfg=1
" @TagbarAccessPrivate: "private" 可见性/可访问性符号。
highlight TagbarAccessPrivate ctermfg=1

" -------------------------------------                    fzf
" Usage:
"       @tab键  : 选择多个
"       @空格+f : 打开文件列表
"       @,+g    : 显示当前目录下所有git文件(不带git状态)
"       @,+sg   : 显示当前目录下所有git文件(带git状态)
"       @空格+b : 显示buffer列表
"       @空格+a : 显示commit列表(源代码所有commit)
"       @空格+c : 显示当前 buffer 的 commit 列表(仅当前文件的commit)
"       @空格+e : 列表显示之前打开过的文件
"       @空格+d : 列表显示之前使用的命令(vim函数或系统命令)
"                 Tips: 空格+d会显示历史命令,选中命令后,直接Enter会执行该命令,如果
"                       想在该命令的基础上进行修改,可以按Ctrl+e,命令会被复制到命令
"                       行,可以在此基础上继续编辑
"       @空格+t : 显示Tabs列表
"       @ctrl+j/k: 列表中向上/下选择
       
" 打开文件搜索列表,默认显示当前目录文件。查找指定路径可给Files函数传入路径参数，例如 :Files path, 命令助记(f = _f_iles)
nnoremap <Space>f :Files<cr>
" 显示所有git文件(文件不显示git状态)
nnoremap <silent> <Leader>g :GFiles<cr>
" 显示所有git文件(文件显示git状态)
nnoremap <silent> <Leader>sg :GFiles?<cr>
" 打开buffer列表, 命令助记(b = _b_uffer)
nnoremap <silent> <Space>b :Buffers<cr>
" 打开 commit 列表(依赖fugitive.vim插件), 命令助记(a = _a_ll commits)
nnoremap <silent> <Space>a :Commits<cr>
" 打开当前 buffer 的 commit 列表, 命令助记(c = burrer _c_ommit)
nnoremap <silent> <Space>c :BCommits<cr>
" 显示commit的diff差异时,用垂直窗口分割进行对比
set diffopt+=vertical

" 列表显示之前打开过的文件, 命令助记(e = fil_e_)
nnoremap <silent> <Space>e :History<cr> 
" 列表显示之前使用的命令, 包括vim函数或系统命令, 命令助记(d = comman_d_)
nnoremap <silent> <Space>d :History:<cr>
" 显示Tabs列表
" nnoremap <silent> <Space>t :Windows<CR>

" 设置fzf窗口的高度和宽度
let g:fzf_layout = { 'window': { 'height': 1.0, 'width': 1.0 } }

" fzf搜索框颜色
"       @fg        : 列表项字体颜色
"       @fg+       : 列表当前项字体颜色
"       @bg        : 窗口背景色
"       @bg+       : 列表当前项背景色
"       @hl        : 突出显示的子字符串(列表)
"       @hl+       ：突出显示的子字符串(当前)
"       @preview-bg: 右侧预览窗口背景色
"       @info      : 预览框里的行信息 
"       @border    : 边框色
"       @gutter    : 文件列表左侧竖线
"       @prompt    : 搜索类型标记(path/gitfile)
"       @pointer   : 列表左侧指示箭头
"       @query     : 输入字体颜色
let g:fzf_colors =
                        \{'fg':         ['fg', 'NERDTreeDir'],
                        \ 'fg+':        ['fg', 'NERDTreeDir'],
                        \ 'bg':         ['bg', 'Normal'],
                        \ 'bg+':        ['bg', 'CursorLine'],
                        \ 'hl':         ['fg', 'NERDTreeExecFile'],
                        \ 'hl+':        ['bg', 'Search'],
                        \ 'preview-bg': ['bg', 'Normal'],
                        \ 'info':       ['bg', 'airline_c'],
                        \ 'border':     ['bg', 'airline_c'],
                        \ 'gutter':     ['bg', 'Normal'],
                        \ 'prompt':     ['bg', 'airline_b'],
                        \ 'pointer':    ['bg', 'Keyword'],
                        \ 'marker':     ['bg', 'Error'],
                        \ 'spinner':    ['bg', 'Error'],
                        \ 'query':      ['fg', 'DiagnosticWarn'],
                        \ 'header':     ['bg', 'Error'] }

" -------------------------------------                    git-blame
" Usage:
"       @ctrl+s : 查看git blame信息
nnoremap <C-s> :<C-u>call gitblame#echo()<CR>

" -------------------------------------                    vim-floaterm
" Usage:
"       @空格 + s : 在vim上打开悬浮终端窗口,再按一下隐藏
"                   Tips: 助记: s=shell, 即终端shell
"       @空格 + y : 打开yazi文件管理器浮动窗口
" 在vim上打开悬浮终端       
let g:floaterm_keymap_toggle = '<Space>s'
let g:floaterm_width = 1.00
let g:floaterm_height = 1.02
let g:floaterm_opener='edit'    " 从yazi打开文件时从当前buffer打开(默认会用水平分割窗口打开文件)
highlight Floaterm ctermbg=NONE
highlight FloatermBorder cterm=bold ctermfg=23 ctermbg=NONE
nnoremap <silent> <Space>y :FloatermNew yazi<CR>

" -------------------------------------                    asyncrun
" Repo: 
"       https://github.com/skywind3000/asynctasks.vim/tree/master 
" Usage:
"       @ar    : 编译并运行, 助记,ar='a'sync'r'un
"       @ctrl+g : 在项目中查找关键词
let g:asyncrun_open = 15             " quickfix 窗口高度
let g:asynctasks_term_rows = 10      " 终端高度为 10"
let g:asynctasks_term_pos = 'bottom' " 终端位置
"let g:asynctasks_term_pos = 'tab'   " 内置终端将在vim buffer中打开

" 运行asynctask命令后，将光标焦点保持在quickfix窗口上
"   @编译并运行
"     Note: run为async插件定义的单个任务命令，可在.task文件中定义
function! RunAndSwitch()
    :AsyncTask run
    :wincmd p
endfunction
noremap <silent> ar :call RunAndSwitch()<cr>
"   @在项目中查找关键词
"     Note: 显示所有包含关键字的代码行，选中行按Enter新打开文件
"             并跳转到关键字所在行
function! GrepAndSwitch()
    :AsyncTask grep
    :wincmd p
endfunction
noremap <silent> <C-g> :call GrepAndSwitch()<cr>

" -------------------------------------                    undotree
" Usage:
"       @空格+u : 打开撤销操作列表
nnoremap <silent> <Space>u :UndotreeToggle<CR>       
let g:undotree_DiffAutoOpen = 1         " 自动打开差异窗口，显示当前状态和选择的历史状态之间的差异
let g:undotree_SetFocusWhenToggle = 1   " 打开undo面板后，光标自动聚焦到undo面板
let g:undotree_ShortIndicators = 1      " 使用短指示器来表示撤销树中的分支关系
let g:undotree_WindowLayout = 2         " undo面板布局类型
let g:undotree_DiffpanelHeight = 20     " undo diff面板高度
let g:undotree_SplitWidth = 25          " undo左侧面板宽度

" -------------------------------------                    NrrwRgn
" Usage:
"       @mn     : 在新的缩小窗口中打开所选区域(原插件命令:NR)
"       @wq     : 将专注区的修改写回原始区，同时关闭专注窗口
"       @NRV    : 打开上次可视选择的区域的缩小窗口
"       @WR     : 将专注区的修改写回原始区，但不关闭专注窗口

vnoremap <silent> mn :NR<CR>                    " mn 打开专注窗口                          

"let g:nrrw_rgn_vert = 1                        " 垂直方式打开专注窗口
let g:nrrw_rgn_resize_window = 'relative'       " 通过百分比的方式设置专注窗口的尺寸
let g:nrrw_rgn_rel_min = 100                    " 专注窗口高度最小值
let g:nrrw_rgn_rel_max = 100                    " 专注窗口高度最大值
let g:nrrw_rgn_nohl = 1                         " 不在原始区域中高亮显示选中内容

" -------------------------------------                    tcomment_vim
" Usage: 
"       [注] 1. 单行: 按第一次注释，再按一次取消注释
"            2. 多行: 可视模式下选中文本进行注释/取消注释
"       @空格      : 注释当前行
"       @空格+r    : 在光标右侧添加注释
"       @空格+空格 : 选中的内容添加块注释
noremap <silent> <Space> :TComment<CR>
noremap <silent> <Space>r :TCommentRight<CR> 
noremap <silent> <Space><Space> :TCommentBlock<CR>

" -------------------------------------                    tabular
" Usage:
"       @=      : 先用v命令选中文本块,然后按'='号,会在命令行调用
"                 Tabularize /命令,然后输入对齐参照字符,例如以','
"                 对齐,在Tabularize /后直接输入','字符, 完整命令
"                 为:Tabularize /,(,号为对齐参照)
map = :Tabularize /

" -------------------------------------                    calendar-vim
" Usage:
"       @ ← ↑ ↓ →方向键         : 选择日期
"       @shift + h              : 到上个月
"       @shift + l              : 到下个月
"       @:CalendarH             : (vim命令)打开日历面板
"       @t                      : 回到今天(日历面板已开的情况下)
let g:calendar_focus_today = 1          " 移至下一个或上一个日历时保持焦点在今天
let g:calendar_keys = { 'goto_next_month': '<S-l>', 'goto_prev_month': '<S-h>'} " shift+h: 到上个月, shift+l: 到下个月
let g:calendar_number_of_months = 6     " 日历面板显示6个月
let g:calendar_navi = 'top'             " 导航栏置于顶部
let g:calendar_navi = 'center'

" -------------------------------------                    vim-sandwich
" Note: 
"       (1) 下面的命令在可视模式下也可使用
"       (2) 下面的"括号"是简单表达,表示成对出现的任何字符
" Usage:
"       @sr+目标字符+替换字符 : 替换字符,把目标字符换成替换字符，例如sr"', 把"替换为', 命令sr助记: sandwich + replace
"       @sd+待删除括号        : 删除括号, 例如sd(, 删除()括号对, 命令sd助记: sandwich + delete
"                               Tips: 在可视模式下,删除选中文本块中的匹配括号对,如果只有一对匹配,直接执行sd命令即可删除括号对,
"                                     无需指定要删除的括号对,sd命令会删除任意括号对;如果选中的文本有多对匹配,例如({[]}),会默认
"                                     删除最外层的括号对,即例子中的()
"       @sal +待添加括号      : 给光标后的字符添加括号(给单词中的字母添加成对符号)
"       @saw +待添加括号      : 给光标后的单词添加括号, 例如saw(, 光标后的单词会加上括号对(), 命令sa助记: sandwich + add
"       @saiw+待添加括号      : 给光标处的单词添加括号, 例如saiw(, 光标处的单词周围会加上括号对()
"       
"       @sais+待添加括号      : 段落添加括号,不包括外层包围字符(surrounding), 助记: i=inner
"       @saas+待添加括号      : 段落添加括号,包括外层包围字符,助记: a = around
"                               Tips: sais类命令按的时候,不要一次按完,否则不生效,先按sa,然后按i,最后按s,比如: sa i s这样的节奏(下同)
"       @saib+待添加括号      : 句子添加括号,不包括外层包围字符(surrounding)
"       @saab+待添加括号      : 句子添加括号,包括外层包围字符
"                               范围解释:
"                                            |<----ib,is---->|
"                               {surrounding}{surrounded text}{surrounding}
"                               |<-----------------ab,as----------------->|

" -------------------------------------                    vim-easymotion
" Usage:
"       @,+w/b    : 跳转到当前光标前/后的位置
"       @,+j/k    : 行级跳转,跳转到当前光标行上/下的位置
"       @,+h/l    : 行内跳转,跳转到当前光标行左/右的位置 
"       @/        : 搜索跳转,按Tab向下翻页,按Shift+Tab向上翻页,到达目标区域时,按Enter显示位置
"       @,+.      : 重复上一次的搜索
map <leader> <Plug>(easymotion-prefix)
map <Leader>j <Plug>(easymotion-k)
map <Leader>k <Plug>(easymotion-j)
map <Leader>h <Plug>(easymotion-linebackward)
map <Leader>l <Plug>(easymotion-lineforward)
map / <Plug>(easymotion-sn)
map <Leader>. <Plug>(easymotion-repeat)

let g:EasyMotion_smartcase = 1          " 设置此选项后, v 将匹配 v 和 V ，但 V 将仅匹配 V

hi EasyMotionTarget cterm=bold ctermbg=228 ctermfg=red         " 单字位置标识
hi EasyMotionTarget2First cterm=bold ctermbg=228 ctermfg=166   " 双字位置标识第1字
hi EasyMotionTarget2Second cterm=bold ctermbg=228 ctermfg=166  " 双字位置标识第2字
hi EasyMotionIncSearch cterm=bold ctermbg=228 ctermfg=red      " 搜索模式下匹配的文本颜色
hi EasyMotionIncCursor cterm=bold ctermbg=202                  " 搜索模式下光标颜色

" -------------------------------------                    vim-system-copy
" Usage:
"   @cpiw   : 将单词复制到系统剪贴板
"   @cy     : 将整行复制到系统剪贴板
"   @cp     : 要将选中的内容复制到剪贴板,在可视模式下选中然后cp
let g:system_copy_silent = 1            " 抑制打印消息输出
" let g:system_copy_enable_osc52 = 1    " 远程ssh使用vim复制失败的备份复制工具(当前未启用)

nmap <silent> cy <Plug>SystemCopyLine

" -------------------------------------                    vim-peekaboo
" Note: Vim有许多不同的寄存器。当你复制文本时, 它会进入"寄存器。
"       当你删除文本时, 它会进入数字寄存器。然后还有小写和大写
"       等寄存器供你个人使用。
"       当你要使用寄存器时, 这个插件会预览它们。当你按下"键时,
"       它会在右侧打开一个寄存器列表, 可以看到每个寄存器的内容
"       并选择正确的寄存器内容。
" Usage:
"   @"  : 打开vim的寄存器列表(可以用v选中文本,然后打开寄存器列表,选中寄存器
"         前面的标识符即可复制寄存器内容,然后按p将内容粘贴到光标位置) 

" -------------------------------------                    linediff.vim
" Usage:
"   @tt  : 可视模式下选中第一块文本内容按'tt',然后选中第二块
"          文本再按'tt',即可比较两块文本的差异。Normal模式下,
"          按tt默认会选中当前行作为第一块要比较的文本
map tt :Linediff<CR>

" -------------------------------------                    vim-signature
" Usage:
"   @mx              : 在当前行添加一个标签'x'(每行可打2个标记符号)
"   @m,              : 放置下一个可用标记
"   @cmx       (原dm): 删除标签'x'
"   @dm        (原m-): 删除当前行所有标记
"   @m + 空格        : 删除当前缓冲区的所有标记
"   @m/              : 打开位置列表(quickfix)并显示当前缓冲区的所有标记
" Note: 这个插件的标记是以行为准打的,所以如果标记的位置如果有行变动(行增/行减),
"       则之前在该位置打的标记则可能会变动
" Tips:
"   1. 命令助记, m 表示mark
hi SignatureMarkText cterm=bold ctermfg=88  " mark字符标记颜色



" 重新映射原插件命令:
"   dm => cm
"   m- => dm
nnoremap cm :<C-U>call signature#utils#Remove(v:count)<CR>
nnoremap dm :<C-U>call signature#mark#Purge("line")<CR>

" -------------------------------------                    scratch.vim
" Note: Vim的文档提到了一种称为scratch缓冲区的特殊缓冲区类型。
"       这个插件实现了它。Scratch缓冲区是临时丢弃缓冲区。
" Usage:
"   @空格+n     : normal模式下打开草稿窗口并进入插入模式,当离开插入模式时，草稿窗口会关闭。
"                 在可视模式下时,会将当前选择( 按字符、按行或按块 )粘贴到草稿窗口中,所有的
"                 笔记内容会写入g:scratch_persistence_file指定的文件中,后续写入的笔记会追加
"                 在之前的记录后面
"   @空格+N     : 新打开一个干净的草稿窗口(其余功能同上),新窗口写入的内容会覆盖原笔记内容
vnoremap <Space>n <Plug>(scratch-selection-reuse)
nnoremap <Space>n <Plug>(scratch-insert-reuse)
vnoremap <Space>N <Plug>(scratch-selection-clear)
nnoremap <Space>N <Plug>(scratch-insert-clear)
let g:scratch_height = 0.5      " 草稿窗口高度
" 默认情况下,离开Vim时草稿窗口的内容会丢失。要保存笔记内容,需要将
" g:scratch_persistence_file 选项设置为有效的文件路径,该文件用来保存笔记内容
let g:scratch_persistence_file = '~/note/scratch.vim'

" -------------------------------------                    QFRestore
" Note: Quickfix是vim最大的特性之一。不幸的是,一旦用结果填充了quickfix列表，它就会被冻结。
"       无法进一步过滤quickfix列表。这种行为不太合理,因为我们总是希望细化结果。Qfgrep允许
"       这样做。现在,我们可以在quickfix窗口中过滤结果
" Usage:
"   @,q     : 对当前Quickfix进行过滤,用户以交互方式输入
"   @,qb    : 对当前Quickfix进行反向过滤，用户以交互方式输入
"   @,qr    : 恢复原始Quickfix条目
" Tips: 命令助记, q 等于 quickfix

let g:QFG_hi_prompt='ctermbg=24 ctermfg=15'     " 用户输入模式提示颜色
let g:QFG_hi_info = 'ctermbg=113 ctermfg=16'    " 信息提示颜色
let g:QFG_hi_error = 'ctermbg=88 ctermfg=15'    " 错误信息提示颜色

" 对当前Quickfix进行过滤，用户以交互方式输入
map <Leader>q :QFGrep<CR>
" 对当前Quickfix进行反向过滤，用户以交互方式输入
map <Leader>qb ::QFGrepV<CR>
" 恢复原始Quickfix条目
map <Leader>qr :QFRestore<CR>

" -------------------------------------                    quickfix-reflector
" Usage: 
"   @用法和正常编辑buffer一样,就是把quickfix当成了buffer进行操作,如果要写回buffer需要执行:w命令
"   @:w   : 将quickfix中的修改写回buffer

" -------------------------------------                    rainbow_parentheses.vim
" Note: 此插件当前默认关闭,因为当所有括号高亮后会使代码界面色彩过多,削弱语法的高亮效果
"       如需开启,将上面此插件的Plug开关打开,并取消下面的注释
" 颜色格式[ctermfg, guifg]
" let g:rbpt_colorpairs = [
"     \ ['brown',       'RoyalBlue3'],
"     \ ['Darkblue',    'SeaGreen3'],
"     \ ['darkcyan',    'RoyalBlue3'],
"     \ ['darkred',     'SeaGreen3'],
"     \ ['darkmagenta', 'DarkOrchid3'],
"     \ ['brown',       'firebrick3'],
"     \ ['darkmagenta', 'DarkOrchid3'],
"     \ ['Darkblue',    'firebrick3'],
"     \ ['darkcyan',    'SeaGreen3'],
"     \ ['darkred',     'DarkOrchid3'],
"     \ ]
" let g:rbpt_max = 16     " 最大的嵌套层数(超过不再高亮)
" let g:rbpt_loadcmd_toggle = 0
" au VimEnter * RainbowParenthesesToggle      
" au Syntax * RainbowParenthesesLoadRound     " ()
" au Syntax * RainbowParenthesesLoadSquare    " []
" au Syntax * RainbowParenthesesLoadBraces    " {}

" -------------------------------------                    a.vim
" Usage: 
"       @,a     : 垂直分割窗口并打开c\h文件
"
"       :A	    : 在新Buffer中切换到c\h文件
"       :AS     : 垂直分割窗口并打开c\h文件
"       :AT     : 新建一个Tab并打开c\h文件
" 垂直分割窗口并打开c\h文件
noremap <Leader>a :AV<CR> 


" -------------------------------------                    bufferize.vim
" Usage: 
"   @M  : 命令行调用Bufferize命令,然后在后面输入命令,在右侧的垂直窗口
"         中显示命令的输出结果(本质是一个vim临时缓冲区), 可对命令的输
"         出结果进行复制
" Tips: (1) 如果是普通normal模式下命令,按下M后直接在提示符后输入命令名即可,
"           例如, 在新buffer中显示所有高亮组
"               :vertical botright Bufferize hi
"       (2) 如果要在新buffer中显示vim命令的结果,则需要在命令前加":"
"           例如, 在新buffer中显示TSInstallInfo命令的结果(命令前加:)
"               :vertical botright Bufferize :TSInstallInfo

" 将光标焦点保持在打开的输出窗口上
let g:bufferize_focus_output = 1
" 在右侧的垂直窗口中显示命令的输出结果
map M :vertical botright Bufferize 

" -------------------------------------                    vim-exchange
" Note: 先选第一处交换位置,用Usage里的命令,然后再选第二处交
"       换位置,同样是Usage里的命令,在第二处位置处按下命令后,
"       两处位置就会自动完成交换
" Usage:
"   @cx     : 标记要交换的位置范围(位置范围用w/iw/is来指定,
"             分别表示光标后单词/光标处单词/光标所在的段落,
"             如果没有指定范围, 默认位置为光标所在的字符)
"   @cxc    : 清除cx的位置标记
"   @X      : 作用与cx相同,但用于[ 可视模式 ]
"   @cxl    : 标记位置范围为[ 光标后的字符 ]
"   @cxw    : 标记位置范围为[ 光标后的单词 ]
"   @cxiw   : 标记位置范围为[ 光标位置的完整单词 ]
"   @cxis   : 标记位置范围为[ 光标所在的段落 ]
"   @cxx    : 标记位置范围为[ 光标所在的行 ]
" Tips:
"   1. 用法可以理解为: cx + 交换范围,cx就是标记第一处位置,表明
"      这处位置接下来要与哪处位置进行交换。按下cx后,可以指定要
"      交换的范围,例如w表示光标后的单词,iw表示光标所在的完整单
"      词,如果cx后没有指定范围, 默认会标记当前光标所在的字符作
"      为交换位置。标记好第一处位置后,接下来将光标移动到第二处
"      位置,再次用命令选中要交换的位置,选中的同时,位置交换完成
"   2. 如果两处交换的位置相同,例如都是cxiw,第二处可以直接使用.

" -------------------------------------                    vim-expand-region
" Usage:
"       @+      : 可视模式下先选中,然后按 + 展开视觉选择
"       @_      : 可视模式下先选中,然后按 _ 缩小视觉选择

" -------------------------------------                    coc.nvim
" Note: Coc是一个基于Language Server Protocol(LSP)的插件, 可以
"       与各种语言服务器进行交互来提供代码补全、语法检查、跳转
"       定义等功能 
"     ▶ 如何使用?
"       (1) Coc本身不提供具体语言的补全功能,只是提供了一个
"           补全功能的平台, 所以在安装完成后, 需要安装具体
"           的语言服务(lsp)以提供补全的内容。
"       (2) 使用方法
"           Q: 安装完coc.nvim后,如何实现跳转到函数定义或者查看函数被引用等功能?
"           A: (1) 先安装对应语言的lsp,例如C可用clangd作为lsp,coc安装命令:
"                   :CocInstall coc-clangd 
"              (2) 为lsp生成compile_commands.json(编译数据库文件,用于提供函数定义跳转)
"                  clangd等lsp服务在处理大型项目时都依赖compile_commands.json文件,
"                  通过这个文件来支持函数定义跳转等功能,所以需要使用一些工具来先生成
"                  compile_commands.json文件,将这个文件放在项目的根目录下,然后coc.nvim
"                  就可以支持跳转到函数定义等代码浏览功能。
"           Q: 如何生成compile_commands.json文件?
"           A: 主要有三种工具可以来生成: bear 、compiledb、cmake
"              使用区别:
"              ▶ cmake    : 直接支持编译完生成编译数据库文件
"                           Usage: cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1
"              ▶ compiledb: 为基于GNU make构建系统生成Clang的JSON编译数据库文件
"                           Usage: compiledb /path/to/make (for make)
"              ▶ bear     : 为clang工具生成编译数据库的工具,也可为make构建系统生成编译数据库文件
"                           Usage: bear -- /path/to/make (for make)
"     ▶ coc.nvim的一些优点:
"       (1) coc提高重构效率: coc支持修改符号名后,可以立即更新整个项目中的符号
"       (2) 对编程语言的补全通过lsp,并且以插件方式提供lsp服务,直接下载对应插件就可以支持该语言的补全,插件系统也很方便管理所有插件
"
" Usage:
"       @ae     : 显示所有错误(打开quickfix列表)       
"       @<      : 到上一个错误
"       @>      : 到下一个错误
"       @Tab键  : 悬浮方式显示信息(例如函数原型信息)
"       @cn     : 快速更改变量名或符号,并自动更新所有相关引用
" Tips: coc命令
"       @:CocList extensions : 查看已安装的lsp
"                              Note: CocList extensions 命令用来显示所有已安装的扩展列表。
"                                    执行这个命令后,会弹出一个模糊匹配的提示输入框, 这样
"                                    可以快速筛选和选择你想要的扩展
"       @:CocUpdate          : 更新 coc.nvim 以及所有相关的语言服务器插件
"       @:CocOpenLog         : 查看日志
set encoding=utf-8 
set nobackup            " 禁止在保存文件时创建备份文件 
set nowritebackup       " 禁止在写入文件时创建备份

nnoremap <silent> ae :CocDiagnostics<CR>

inoremap <silent><expr> <TAB>
      \ coc#pum#visible() ? coc#pum#next(1) :
      \ CheckBackspace() ? "\<Tab>" :
      \ coc#refresh()
inoremap <expr><S-TAB> coc#pum#visible() ? coc#pum#prev(1) : "\<C-h>"

inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm()
                              \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"

function! CheckBackspace() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

if has('nvim')
  inoremap <silent><expr> <c-space> coc#refresh()
else
  inoremap <silent><expr> <c-@> coc#refresh()
endif

" 到上一个诊断信息
nmap <silent> < <Plug>(coc-diagnostic-prev)
" 到下一个诊断信息
nmap <silent> > <Plug>(coc-diagnostic-next)

" 转到定义(包括函数或变量)
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

nnoremap <silent> <Tab> :call ShowDocumentation()<CR>
function! ShowDocumentation()
  if CocAction('hasProvider', 'hover')
    call CocActionAsync('doHover')
  else
    call feedkeys('<Tab>', 'in')
  endif
endfunction

" 光标停留一定时间后(CursorHold事件触发),高亮显示代码中的错误和警告信息
autocmd CursorHold * silent call CocActionAsync('highlight')
" 快速更改变量名或符号,并自动更新所有相关引用, 助记: cn=change name
nmap <silent> cn <Plug>(coc-rename)

augroup mygroup
  autocmd!
  " 当文件类型为 typescript 或 json 时的格式化格式
  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
  " 触发 Coc.nvim 插件的跳转占位符操作时,更新签名帮助信息
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
augroup end

" airline对coc.nvim的支持
let g:airline#extensions#coc#enabled = 1
let g:airline#extensions#coc#error_symbol = 'E:'
let g:airline#extensions#coc#warning_symbol = 'W:'
let g:airline#extensions#coc#show_coc_status = 1
let g:airline#extensions#coc#stl_format_err = '%C(L%L)'
let g:airline#extensions#coc#stl_format_warn = '%C(L%L)'

highlight! link CocFloatThumb NONE
hi CocFloatThumb ctermfg=NONE ctermbg=NONE  " 滚动条区域中的拖动条颜色

highlight! link CocFloatSbar NONE           
hi CocFloatSbar ctermfg=NONE ctermbg=NONE   " coc浮动窗口的滚动条区域背景

highlight! link CocFloatDividingLine NONE
hi CocFloatDividingLine ctermfg=22          " coc浮动窗口分割线

highlight! link CocErrorFloat NONE
hi CocErrorFloat ctermfg=1

hi CocFloating cterm=NONE ctermfg=66 ctermbg=194       " coc浮动窗口内文字颜色
" hi CocMenuSel ctermfg=23 ctermbg=150       " 列表选中项的背景
hi CocPumSearch ctermfg=26                  " 列表项匹配的子子字符串的颜色

" -------------------------------------                    ultisnips & vim-snippets
" Note: ultisnips插件提供一种快速操作代码片段的能力,例如编辑
"       代码片段的选项或者进行插值。而vim-snippets提供的是代
"       码片段,包括各种编程语言的代码片段,也可以自定义自己的
"       代码片段,其中,vim-snippets包含了两种格式的代码片段,
"           (1) snippets/*  : 使用 snipMate 格式的片段
"           (2) UltiSnips/* : 使用 UltiSnips 格式的片段
"       ultisnips插件可通过设置触发键,通过关键字快速插入代码
"       片段,并且可以切换到不同的选项位置进行编辑。
" Tips: 如果想借助coc.nvim提供的补全能力, 在补全时可以将代码
"       片段也显示在后选项里,可以安装
"            ~/.config/nvim/plugged/vim-snippets/snippets,
"       其中c.snippets文件是c语言的代码补全片段
" 快速地插入预定义的代码片段的触发键(按此键插入代码片段,当前未设置)
let g:UltiSnipsExpandTrigger="<Nop>"
" 设置代码片段跳转的快捷键
let g:UltiSnipsJumpForwardTrigger="<Nop>"
let g:UltiSnipsJumpBackwardTrigger="<Nop>"

" 使用 :UltiSnipsEdit 命令(语言的代码补全配置)时, 垂直分屏打开ultisnips配置
let g:UltiSnipsEditSplit="vertical"

" -------------------------------------                    vim-startuptime
" Usage:
"       @:StartupTime : 显示vim的启动时间,即启动项时间占比

" -------------------------------------                    vim-win
" Usage:            
"       @空格+w  : 启用vim-win窗口管理
"       @w       : 关闭vim-win
"       @q       : 关闭buffer窗口
"       @f       : 水平分屏
"                  Tisp: 助记,f=fen,即分(分屏), f的'-'表示水平方向
"       @v       : 垂直分屏
"       @n       : 切换到下一个buffer
"       @p       : 切换到上一个buffer
"       @h/j/k/l : 移动到左/上/下/右窗口
"       @H/J/K/L : 把窗口移动到左/上/下/右侧
"       @g       : 增加高度(增大水平分屏的高度),g=gao,即高
"       @d       : 降低高度(减小水平分屏的高度),d=di, 即低
"       @M       : 增加宽度(增大垂直分屏的宽度),M=Max,即增大
"       @N       : 减小宽度(减小垂直分屏的宽度),N=miN,即减小
"                  Tips: 大写的M、N竖线多,表示垂直方向,所以M、N分别控制垂直方向分屏的增加和缩小
"       @r       : 恢复窗口的默认标准宽/高度
"       @m       : 最大化当前分屏, m=max
"       @o       : 恢复上一次分屏布局,o=original,即原始的
"       @t       : 创建一个新的tab
map <silent> <Space>w <plug>WinWin
" 自定义vim命令: Win启用vim-win
command Win :call win#Win()
let g:win_ext_command_map = {
      \   'q': 'wincmd c',
      \   'v': 'wincmd v',
      \   'f': 'wincmd s',
      \   'm': 'only',
      \   'o': 'call RestoreSession()',
      \   'n': 'bnext',
      \   'p': 'bprevious',
      \   'r': 'wincmd =',
      \   't': 'tabnew',
      \   'w': 'Win#exit',
      \   'j': 'wincmd k',
      \   'k': 'wincmd j',
      \   'H': 'wincmd H',
      \   'J': 'wincmd K',
      \   'K': 'wincmd J',
      \   'L': 'wincmd L',
      \   'g': 'resize +10',
      \   'd': 'resize -10',
      \   'M': 'vertical resize +20',
      \   'N': 'vertical resize -20'
      \ }
" vim-win指示*号颜色
highlight! link WinStar NONE
hi WinStar cterm=bold ctermfg=23 ctermbg=NONE

" -------------------------------------                    vim-startify
" Note: session保存的位置: ~/.config/nvim/session
" Usage:
"    启动界面命令:
"       @e       : 创建一个空缓冲区
"       @i       : 创建一个空缓冲区并进入插入模式
"    导航至某个条目:
"       @b       : 在buffer中打开
"       @s       : 在水平分屏中打开
"       @v       : 在垂直分屏中打开
"       @t       : 在tab中打开
"                  Tips: 先导航到条目上,在执行操作,可以对多个
"                        条目执行此操作,也可以混合使用它们,选
"                        择的顺序将被记住
"       @B/S/V/T : 批处理多个,功能同上
"                  Tips: 要关闭批处理模式, 只需再次使用相同的大写键或任何小写变体。
"                        选择完成后, Startify 将自动关闭, 也可以通过:Startify重新
"                        打开启动界面
"    session命令 

" session保存的位置
let g:startify_session_dir = '~/.config/nvim/session'

" vim启动界面标题
let g:startify_custom_header = [
            \ '            __                  ',
            \ '    __  __ /\_\    ___ ___      ',
            \ '   /\ \/\ \\/\ \ /'' __` __`\   ',
            \ '   \ \ \_/ |\ \ \/\ \/\ \/\ \   ',
            \ '    \ \___/  \ \_\ \_\ \_\ \_\  ',
            \ '     \/__/    \/_/\/_/\/_/\/_/  ',
            \ ]

" 启动界面文件字体颜色
hi StartifyFile ctermfg=23
" 启动界面路径字体颜色
hi StartifyPath ctermfg=66

" -------------------------------------                    nvim-treesitter
" Note: 当前已安装的语言解析器
"       [c] [vim] [vimdoc] [query] [lua] [markdown] [markdown_inline]
" Usage:
"       @
" zc 关闭光标下的折叠。
" zo 打开光标下的折叠。
" za 切换光标下的折叠状态。
" zR 打开所有折叠。
" zM 关闭所有折叠。
"   ▶ nvim-treesitter命令
"       @:TSInstall 语言 : 安装对应语言的语法解析器,例如C:
"                          TSInstall c
"       @:TSUpdate 语言  : 更新对应语言的解析器
"       @:TSUpdate all   : 更新所有语言解析器,或仅使用:TSUpdate
"       @:TSInstallInfo  : 查看所有可安装的语言解析器,及安装状态
"       @:TSBufToggle highlight : 启用treesitter高亮
"   
"   ▶ 查看光标处nvim-treesitter的高亮组
"       @:Inspect以显示光标下的突出显示组
"       @:InspectTree显示解析的语法树
"       @:EditQuery打开实时查询编辑器
" Tips:
"       助记: treesitter有关的命令为TS开头,TS=TreeSitter

lua << EOF
require'nvim-treesitter.configs'.setup {
  -- 需要安装的语言解析器的列表,这些语言的解析器将被安装
  ensure_installed = { "c", "lua", "vim", "vimdoc", "query", "markdown", "markdown_inline" },
  -- 当设置为 false 时，表示解析器的安装将是异步的，即不会阻塞 Neovim 的其他操作
  sync_install = false,
  -- 当设置为true时,如果进入一个缓冲区buffer且缺少相应的解析器,nvim-treesitter会自动安装缺失的解析器
  auto_install = true,
  -- 这是一个列表, 包含不应安装的解析器, 在这个例子中, "javascript" 解析器将被忽略
  ignore_install = { "javascript" },
  highlight = {
    -- 设置为 true 以启用基于 tree-sitter 的语法高亮
    enable = true,
    -- 可以是一个列表,列出不需要高亮的语言解析器,也可以是一个函数,用于在特定条件下禁用高亮,例如当文件大小超过100KB时
    disable = {},
    -- 设置为 false 表示不使用传统的Vim正则表达式高亮,仅使用tree-sitter进行高亮,这可以提高性能并减少高亮冲突
    additional_vim_regex_highlighting = false,
  },
  -- nvim-treesitter增量操作
  incremental_selection = {
    -- 启用增量选择功能,这允许通过自定义的快捷键逐步扩大或缩小代码的选择范围
    enable = true,
    -- 这是一个键映射表,定义了如何通过键盘操作来控制增量选择的行为
    keymaps = {
      -- 这个键绑定用于初始化选择。按下 gnn 时,将选中光标下的最小语法节点,如果设置为 false,则此映射被禁用
      init_selection = "gnn",
      -- 这个键绑定用于增加选择的范围。每次按下 grn,选择的范围会扩展到包含当前选择的下一个较大的语法节点
      node_incremental = "grn",
      -- 这个键绑定用于按作用域逐步增加选择范围。按下 grc 时,将扩展选择范围到当前节点的父级作用域
      scope_incremental = "grc",
      -- 这个键绑定用于减小选择的范围。每次按下 grm,选择的范围会缩小到当前选择的下一个较小的语法节点
      node_decremental = "grm",
    },
  },
}
EOF

" 配置 Neovim 中的代码折叠(folding)功能,特别是通过 Tree-sitter 语法树来控制折叠行为
set foldmethod=expr  " 设置折叠方法为表达式
" 设置折叠表达式为 Tree-sitter 提供的函数,即使用 vim.treesitter.foldexpr() 函数来决定折叠,
" 这个函数是由 Neovim 的 Tree-sitter 集成提供,它根据语法树的结构来计算折叠点
set foldexpr=v:lua.vim.treesitter.foldexpr()



" -------------------------------------                    vim-orgmode
"


" -------------------------------------                    far.vim
" Usage:
"   @
let g:far#enable_undo=1         " 支持撤回替换操作



" vim 个性化
" =============================================================================
" -------------------------------------                    vim字符样式
" 修改vim填充字符, 去掉'~'符号。 注: '\'后有个空格
set fillchars=eob:\ 

" 修改分割线样式
set fillchars+=vert:\⎜

" vim diff 模式下将删除部分的填充字符设置为空格
set fillchars+=diff:\ 

" -------------------------------------                    vim光标
set guicursor=a:block-iCursor-blinkon0      " 设置所有模式下光标保持为不闪烁的块

" 终端模拟器光标颜色(此处用于控制vim-fzf插件打开的搜索窗口中的光标颜色)
hi TermCursor ctermbg=NONE ctermfg=darkred

" 修改vim-easymotion插件搜索输入(按/)时双光标问题的第一个光标颜色(此问题属于nvim问题,还未修复)
hi Cursor ctermbg=166 ctermfg=166

" 自定义vim颜色配置
" -------------------------------------                    vim区域配色
" Note: 分割线颜色(必须放在vim配置的最后，否则不生效)
hi WinSeparator cterm=bold ctermbg=NONE ctermfg=22   " nvim使用WinSeparator控制垂直分割线

" 当前行&当前行行号&当前列颜色
highlight CursorLine cterm=bold ctermfg=NONE ctermbg=NONE
highlight CursorLineNr cterm=bold ctermfg=black ctermbg=NONE
hi CursorColumn cterm=bold ctermfg=NONE ctermbg=151

" 设置行号颜色为浅灰色
highlight LineNr ctermfg=249

" 设置括号对的颜色
highlight MatchParen cterm=bold ctermbg=yellow ctermfg=Red

" 多窗口时底部状态栏的分割线颜色
highlight StatusLine cterm=NONE ctermfg=NONE ctermbg=23
highlight StatusLineNC cterm=NONE  ctermfg=NONE ctermbg=23

" 底部状态栏显示的字体颜色
highlight StatusLine cterm=bold ctermbg=23 ctermfg=15

" 底部模式字符颜色
hi ModeMsg cterm=bold ctermbg=NONE ctermfg=88   " 插入模式字符,例如'--插入--'
hi MoreMsg cterm=bold ctermbg=NONE ctermfg=88   " 查看模式,例如'--更多--' 

" vim 搜索匹配字符的颜色
hi Search cterm=NONE ctermbg=228 ctermfg=1
hi CurSearch cterm=NONE ctermbg=228 ctermfg=1

" 底部交互模式时信息提示字符颜色
hi Question cterm=NONE ctermfg=25

" vim diff模式下比较文本差异时的配色
highlight DiffAdd cterm=NONE ctermfg=23 ctermbg=194 " 新增文本背景色
highlight DiffDelete cterm=NONE ctermfg=1 ctermbg=224
highlight DiffChange cterm=NONE ctermfg=1 ctermbg=224
highlight DiffText cterm=NONE ctermfg=124 ctermbg=217

" vim 菜单配色
highlight PMenu cterm=NONE ctermfg=15 ctermbg=23           " 列表背景
highlight PMenuSel cterm=NONE ctermfg=15 ctermbg=106       " 列表选中项的背景
highlight PmenuSbar cterm=NONE ctermfg=NONE ctermbg=23     " 弹出菜单的滚动条区域背景
highlight PmenuThumb cterm=NONE ctermfg=white ctermbg=23   " 滚动条区域中的拖动条颜色

" vim浮动窗口
hi DiagnosticWarn ctermfg=130          " 浮动窗口警告字体颜色(当前用于coc插件)

hi WarningMsg ctermfg=130              " vim警告色

" 代码折叠相关配色
highlight Folded ctermfg=NONE ctermbg=NONE         " Folded 指的是被折叠起来的代码块
highlight FoldColumn ctermfg=NONE ctermbg=NONE     " 折叠列
highlight CursorLineFold ctermfg=NONE ctermbg=NONE " 光标所在行折叠

" vim 可视(块)模式下选中文字的背景色
" highlight Visual ctermbg=151 ctermfg=22
highlight Visual ctermbg=194 ctermfg=23

" -------------------------------------                    vim语法通用部分配色
" Note: 语言相关的配色通过ftplugin目录下的x.vim进行单独配色,例如c.vim为C语言配色,
"       语言文件中未指定的配色,将使用vim的自动配色设置，就是下面的语法类型的设置
"
" Tips:
"       Q: 想修改某个字符的配色,如何查看它属于哪个高亮组？
"       A: 将光标放在该单词上,然后使用以下命令来检查该位置的语法组: 
"               :echo synIDattr(synID(line("."), col("."), 1), "name")
"       Q: 怎么查看某个高亮组是哪种配色方案？
"       A: 使用hi(highlight缩写)命令, 例如查看VertSplit的高亮色,命令如下:
"               :hi VertSplit     
"
" 语法类解释:
"     Comment       : 用于注释代码中的解释或说明        
"     Constant      : 常数,表示固定的数值、字符串或符号
"     Special       : 表示特殊字符或符号
"     Identifier    : 表示标识符或变量名  
"     Statement     : 语句中涉及到的语法关键字颜色 
"     PreProc       : 表示预处理指令 
"     Type          : 表示数据类型 
"     Underlined    : 表示下划线
"     Ignore        : 表示忽略的内容  
"     String        : 表示字符串 
"     Character     : 表示字符 
"     Number        : 表示数字
"     Boolean       : 表示布尔值 
"     Float         : 表示浮点数
"     Function      : 表示函数 
"     Conditional   : 表示条件语句
"     Repeat        : 表示循环语句
"     Label         : 表示标签
"     Operator      : 表示运算符 
"     Keyword       : 语法关键字颜色 
"     Include       : 表示包含的文件 
"     Define        : 表示宏定义 
"     Macro         : 表示宏 
"     PreCondit     : 表示预处理条件  
"     StorageClass  : 表示存储类 
"     Structure     : 表示结构体
"     Typedef       : 表示类型定义 
"     Tag           : 表示标签 
"     SpecialChar   : 表示特殊字符
"     Delimiter     : 表示分隔符
"     SpecialComment: 表示特殊注释

hi Comment cterm=NONE ctermfg=239
hi Constant cterm=NONE ctermfg=88    
hi Special cterm=NONE ctermfg=5
hi Identifier cterm=NONE ctermfg=25
hi Keyword cterm=NONE ctermfg=130
hi Statement cterm=NONE ctermfg=130
hi PreProc cterm=NONE ctermfg=88
hi Type cterm=NONE ctermfg=28
hi Ignore cterm=NONE ctermfg=88
hi String cterm=NONE ctermfg=88
hi Character cterm=NONE ctermfg=88
hi Number cterm=NONE ctermfg=88
hi Boolean cterm=NONE ctermfg=136
hi Float cterm=NONE ctermfg=89
hi Function cterm=NONE ctermfg=25
hi Conditional cterm=NONE ctermfg=126
hi Repeat cterm=NONE ctermfg=5
hi Label cterm=NONE ctermfg=126
hi Operator cterm=NONE ctermfg=166
hi Keyword cterm=NONE ctermfg=red
hi Include cterm=NONE ctermfg=88
hi Define cterm=NONE ctermfg=126
hi Macro cterm=NONE ctermfg=25
hi PreCondit cterm=NONE ctermfg=31
hi StorageClass cterm=NONE ctermfg=130
hi Structure cterm=NONE ctermfg=89
hi Typedef cterm=NONE ctermfg=5
hi Tag cterm=NONE ctermfg=25
hi SpecialChar cterm=NONE ctermfg=88 
hi Delimiter cterm=NONE ctermfg=130
hi SpecialComment cterm=NONE ctermfg=239

" ------------------------------------- nvim-treesitter语法配色                    
" Note:
"       (1) 在nvim-treesitter中,每种语言的Treesitter解析器都有自己的查询文件,
"           可在nvim-treesitter的每个语言解析器目录下找到 highlights.scm文件,
"           查看所有的捕获组,即可以被捕获和高亮的语法元素
"       (2) scm文件解释: 
"             ; Command command  ;表示.scm文件的注释
"             (command) @string  表示一个规则,将类型为command的节点
"                                高亮显示为string类型的颜色, 可以用
"                                hi命令修改string配色从而改变treesitter
"                                的语法配色
"       (3) 如何修改treesitter语法高亮色
"           修改@后的高亮组即可,例如.scm中有高亮组:
"             [
"               "sign"
"               "abort"
"             ] @keyword
"           用hi命令查看vim当前是否有keyword高亮组,如果有直接用hi命令重新设置高亮色:
"             hi keyword ctermfg=9

" vim语法配色
hi keyword ctermfg=130

" C语法配色
hi @keyword.import ctermfg=17       " #include
hi @keyword.conditional ctermfg=126 " if/else/case/switch
" [
"   "#if"
"   "#ifdef"
"   "#ifndef"
"   "#else"
"   "#elif"
"   "#endif"
"   "#elifdef"
"   "#elifndef"
"   (preproc_directive)
" ] @keyword.directive
hi @keyword.directive ctermfg=6
hi @keyword.directive.define ctermfg=126 " #define" @keyword.directive.define
hi @type ctermfg=2      " typedef定义的类型等
hi @property ctermfg=66 " field_identifier,即字段名(结构体成员)

" -------------------------------------                    高亮显示y命令复制区域
 " 定义高亮样式
highlight YankHighlight ctermbg=229
 " 使用自动命令在复制后高亮显示
autocmd TextYankPost * silent! lua vim.highlight.on_yank {higroup="YankHighlight", timeout=200}


" 自定义vim自动命令
" -------------------------------------                    设置quickfix窗口高度
autocmd FileType qf setlocal winheight=20

" -------------------------------------                    自动关闭位置列表和quickfix列表
" 在位置列表/quickfix列表跳转完成后,自动关闭
" 位置列表/quickfix列表
autocmd FileType qf nnoremap <silent> <buffer> <CR> <CR>:lclose<CR>:cclose<CR>

" -------------------------------------                    关闭quickfix后,聚焦到之前的窗口
" Usage:
"       @q  : 关闭quickfix后,保持原始窗口的聚焦(vim默认关闭
"             qf窗口后,会改变原始窗口的聚焦,即关闭qf窗口后,
"             新聚焦的窗口不是进入qf窗口前的那个窗口)
autocmd FileType qf nnoremap <silent> <buffer> q :wincmd p<CR>:cclose<CR>


" 自定义vim快捷键映射
" -------------------------------------                    分屏
" Note: 
"       h=horizontal,水平
"       v=vertical,  垂直
" Usage:
"       @sh : 水平分屏
"       @sv : 垂直分屏
" Tips: 
"       助记: sh=split horizontal, 切分水平
"             sv=split vertical,   切分垂直
nnoremap <silent> sh :sp<CR>
nnoremap <silent> sv :vsp<CR>

" -------------------------------------                    增加/减少垂直分屏宽度
" Usage:
"       @vm  : 增加垂直分屏宽度
"       @vn  : 减少垂直分屏宽度
" Tips: 
"       助记: vm=vertical max, 即垂直变大
"             vn=vplit mini,   即垂直减小
" 增加垂直分屏宽度
nnoremap <silent> vm :vertical resize +20<CR>
" 减少垂直分屏宽度
nnoremap <silent> vn :vertical resize -20<CR>

" -------------------------------------                    增加/减少水平分屏高度
" Usage:
"       @hm :增加水平分屏高度
"       @hn :减少水平分屏高度
" Tips:
"       助记: hm=horizontal max, 即水平变大
"             hn=horizontal mini,即水平减小
" 增加水平分屏高度
nnoremap <silent> hm :resize +10<CR>
" 减少水平分屏高度
nnoremap <silent> hn :resize -10<CR>

" -------------------------------------                    窗口分屏均匀化/最大化(即单独显示分屏)
" Usage:
"       @wn : 恢复窗口到vim默认布局(标准大小)
"       @wm : 分屏最大化(即分屏单独显示为全屏)
" Tips: 
"       助记: wn=windows normal,即窗口标准化
"             wm=windows max, 即窗口最大化
nnoremap <silent> wn :wincmd =<CR>
nnoremap <silent> wm :only<CR>

" -------------------------------------                    垂直分屏<=>水平分屏
" Usage:
"       @vh : 2个垂直分屏转水平分屏
"       @hv : 2个水平分屏转垂直分屏
" Tips:
"       助记: vh=vertical 转 horizontal, 即垂直转水平
"             hv=horizontal 转 vertical, 即水平转垂直
nnoremap <silent> vh <C-w>t<C-w>K
nnoremap <silent> hv <C-w>t<C-w>H

" -------------------------------------                    垂直/水平分屏换位置
" Usage:
"       @wh : 将当前窗口移到左方
"       @wj : 将当前窗口移到上方
"       @wk : 将当前窗口移到下方
"       @wl : 将当前窗口移到右方
" Tips:
"       助记: w=window, 即窗口
nnoremap <silent> wh : wincmd H<CR>
nnoremap <silent> wj : wincmd K<CR>
nnoremap <silent> wk : wincmd J<CR>
nnoremap <silent> wl : wincmd L<CR>

" -------------------------------------                    移动窗口
" Usage:
"       @空格+h : 移到 左 窗口
"       @空格+j : 移到 上 窗口
"       @空格+k : 移到 下 窗口
"       @空格+l : 移到 右 窗口
nnoremap <silent> <Space>h <C-w>h
nnoremap <silent> <Space>j <C-w>k
nnoremap <silent> <Space>k <C-w>j
nnoremap <silent> <Space>l <C-w>l

" -------------------------------------                    快速垂直滚动
" Usage:
"       @shift+j    : 单按1次▶光标上移20行, 持续按▶以20行/秒的速度向上滚动
"       @shift+k    : 单按1次▶光标下移20行, 持续按▶以20行/秒的速度向下滚动
map <silent> <S-j> 20<Up>
map <silent> <S-k> 20<Down>

" -------------------------------------                    快速水平滚动
" Usage:
"       @shift+h    : 单按1次▶光标左移5个字符, 持续按▶以5个字符/秒的速度向左滚动
"       @shift+l    : 单按1次▶光标右移5个字符, 持续按▶以5个字符/秒的速度向右滚动
map <silent> <S-h> 5<Left>
map <silent> <S-l> 5<Right>

" -------------------------------------                    单行移动
" Usage:
"       @j      : 上移一行
"       @k      : 下移一行
" Tips: 
"       1. 快速滚动到目标区域附近后，通过j、k以单行向上、下移动
"       2. 以下设置在所有模式下都生效
map <silent> j <Up>
map <silent> k <Down>

" -------------------------------------                    退出窗口/buffer
" Usage:
"       @q      : 退出当前窗口/buffer
"       @空格+q : 退出所有窗口/buffer
nnoremap <silent> q :q<CR>
nnoremap <silent> <Space>q :qa<CR>

" -------------------------------------                    光标回行首/尾
" Usage:
"       @aa : 光标回行首
"       @ee : 光标回行尾
noremap <silent> aa 0
noremap <silent> ee $
  
" -------------------------------------                    光标回行首/尾+进入插入模式
" Usage:
"       @ai : 光标回行首+进入插入模式
"       @ei : 光标回行尾+进入插入模式
nnoremap <silent> ai I
nnoremap <silent> ei A
inoremap <silent> ei <Esc>A

" -------------------------------------                    "注释快速编辑: 
" Usage:
"       @as     : 光标回行首+删除第一个字符+进入插入模式
"                 [适用]: 有注释如" abc, 要删除注释符,并且进入插入模式
"       @a+空格 : 删除光标后第一个字符+加空格+进入插入模式
"                 [适用]: 在""下,需要删除第2个",空格后,进入插入模式
" 删除光标后字符+增加空格+进入插入模式
nnoremap <silent> as 0s
nnoremap <silent> a<Space> ls<Space>

" -------------------------------------                    删除上/下一行
" Usage:
"       @cj : 删除上方一行
"       @ck : 删除下方一行
" Tips: 
"       助记: c=clear,表示清除
nnoremap <silent> cj kdd
nnoremap <silent> ck jddk

" -------------------------------------                    清空上/下一行内容
" Usage:
"       @sj : 清空上一行内容
"       @sk : 清空下一行内容
" Tips:
"       助记: s=space,空格,表示变成空行,即清空行
nnoremap <silent> sj k0Dj
nnoremap <silent> sk j0Dk

" -------------------------------------                    清空当前行内容
" Usage:
"       @sl : 清空当前行内容, 助记:space line,清空行
nnoremap <silent> sl Vs<ESC>

" -------------------------------------                    清空当前行内容+进入插入模式
" Usage:
"       @空格+i : 清空行,并进入插入模式
" Tips: 空格+i=清空+insert
nnoremap <silent> <Space>i Vs

" -------------------------------------                    在上/下一行末尾进入插入模式 (支持Normal模式+插入模式)
" Usage:
"       @ej : 在上一行末尾进入插入模式
"       @ek : 在下一行末尾进入插入模式
" Tips: 
"      助记: ej/ek中的e同时包含两个含义, e=end+edit,即末尾编辑
nnoremap <silent> ej kA
nnoremap <silent> ek jA

" -------------------------------------                    在上/下一行开头进入插入模式
" Usage:
"       @aj : 在上一行开头进入插入模式
"       @ak : 在下一行开头进入插入模式
nnoremap <silent> aj k0i
nnoremap <silent> ak j0i

" -------------------------------------                    在下一行进入插入模式+Tab缩进 (支持Normal模式+插入模式)
" Usage:
"       @tk : 在下一行开头进入插入模式,并增加Tab缩进
inoremap <silent> tk <Esc>ji<Tab>
nnoremap <silent> tk <Esc>ji<Tab>

" -------------------------------------                    移动当前行
" Usage:
"       @ctrl + j : 当前行上移
"       @ctrl + k : 当前行下移
nnoremap <silent> <C-j> :m-2<CR>
nnoremap <silent> <C-k> :m+1<CR>

" -------------------------------------                    增加空格
" Usage:
"   @gs : 在光标前添加一个空格(generate space)
nnoremap <silent> g<Space> :normal! i<Space><Esc>


" -------------------------------------                    增加空行
" Usage:
"       @gj : 在上方增加空行(光标在当前行不动)
"       @gk : 在下方增加空行(光标在当前行不动)
"       @ga : 在上方+下方增加空格,并进入插入模式
nmap <silent> gj O<Esc>k
nmap <silent> gk o<Esc>j
noremap <silent> ga O<Esc>ko<Esc>j

" -------------------------------------                    增加换行
" Usage:
"   @g+Enter    : 将光标后的内容移入下一行(generate enter)
nnoremap <silent> g<CR> i<CR><Esc>

" -------------------------------------                    取消换行
" Usage:
"   @d+Enter    : 将下一行内容移入光标后(delete enter)
nnoremap <silent> d<CR> a<Del><Esc>

" -------------------------------------                    缩短组合前缀键等待延时(ms)
set timeoutlen=200

" -------------------------------------                    复制全文
" Usage:
"       @ya : 选中全文复制到vim剪贴板
"       @yb : 选中全文复制到系统剪贴板
" Note: 快捷映射使用vim Ex 命令
"       % : 表示选择整个文件。
"       y : 是 yank(复制)命令。
"       + : 指定使用系统剪贴板
nnoremap <silent> ya :%y<CR>
nnoremap <silent> yb :%y+<CR>

" -------------------------------------                    剪贴全文
" Usage:
"       @da : 剪贴全文到vim剪贴板
"       @db : 剪贴全文到系统剪贴板 
nnoremap <silent> da :%d<CR>
nnoremap <silent> db :%d+<CR>

" -------------------------------------                    复制光标到行尾
" Usage:
"       @yee : 复制光标至行尾内容到vim剪贴板
"       @ys  : 复制光标到行尾内容到系统剪贴板(s=system,
"              表示系统剪贴板)
" 映射 'ys' 以复制从光标到行尾的内容到系统剪贴板
nnoremap <silent> ys "+y$

" -------------------------------------                    删除光标到行尾
" Usage:
"       @dee : 删除光标到行尾内容到vim剪贴板
"       @ds  : 删除光标到行尾内容到系统(s=system)剪贴板
nnoremap <silent> ds "+d$

" -------------------------------------                    删除选中内容到系统剪贴板
" Note: "+寄存器,表示系统剪贴板
" Usage:
"       @dy : 删除选中内容到系统剪贴板
vnoremap <silent> dy "+d

" -------------------------------------                    删除光标到行尾+进入插入模式
" Usage:
"       @si : 清除光标到行尾+进入插入模式
"             Tips: 助记,s=space,清空,即清空光标到行尾内容
nnoremap <silent> si C

" -------------------------------------                    反转(逆序)文本
" Usage:
"       @:ReverseText : 反转全部文本
" command! ReverseText execute "g/^/m0"
command! ReverseText silent! %!gtac

" -------------------------------------                    逆序显示历史命令
" Note: 在macOS上,tac命令不是默认安装的,因为它是GNU的一部分,
"       而macOS使用的是BSD工具。tac命令用于将文件的内容以反
"       向顺序输出。为了在macOS上使用tac, 你可以安装GNU的coreutils,
"       它包括 tac 和其他 GNU 版本的常用命令,gtac(tac命令的GNU版本)
"       mac使用如下命令安装:
"           $ brew install coreutils
" Usage:
"   @hi  : 逆序显示历史命令(时间越近,位置越前)
function! HistoryReverse()
    execute "vertical botright Bufferize history"
    silent! %!gtac
endfunction
map <silent> hi :call HistoryReverse()<CR>

" -------------------------------------                    输入法自动切换英文
" Note: 
"       (1) 工具地址: https://github.com/daipeihust/im-select
"       (2) 安装:(安装好后可以在/usr/local/bin中找到工具)
"               $ brew tap daipeihust/tap
"               $ brew install im-select
"           然后在init.vim中添加下面的语句:
"               autocmd ModeChanged *:n,*:v silent !im-select 输入法名
           
" Normal/Visual模式自动切换到英文输入法
autocmd ModeChanged *:n,*:v silent !im-select com.apple.keylayout.ABC

" -------------------------------------                    Esc键快捷映射
" 将 'jk' 映射为 'Esc' 在插入模式和可视模式下
inoremap <silent> jk <Esc>
vnoremap <silent> jk <Esc>
" 在命令行模式下将 jk 映射为 <Esc>
cnoremap <silent> jk <C-c>

" -------------------------------------                    vim取消撤销操作(u)
" Usage:
"       @rr : 取消撤销操作(vim原Ctrl+r命令)
nnoremap <silent> rr <C-r>

" -------------------------------------                    保存写入(写入当前内容)
" Usage:
"       @ew : 当前修改内容写入(等价:w)
"             Tips: ew=ensure write : 确定写入
nnoremap <silent> ew :w<CR>

" -------------------------------------                    保存写入+退出
" Usage:
"       @we : (保持写入)保存并退出(等价:wq)
"             Tips: we=write exit : 写入并退出
nnoremap <silent> we ZZ

" -------------------------------------                    反方向重复执行上一次光标移动
" Usage:
"       @'  : 反方向重复上一次光标移动
nnoremap <silent> ' ,

" -------------------------------------                    高亮光标所在行/列
" Usage:
"       @eh : 开启光标所在行高亮,再按一次关闭
"       @el : 开启光标所在列高亮,再按一次关闭
"       @et : 同时开启行列高亮
" Tips:
"       助记: eh=extrude hang(行), extrude=突出,即突出行
"             el=extrude lie(列), 突出列
"             et,t字母表示'十'的意思
" 定义一个变量来标记当前配置状态

" 高亮光标所在行
nnoremap <silent> eh :call ToggleHighlight()<CR>
let g:highlight_enabled = 0
function! ToggleHighlight()
    if g:highlight_enabled == 0
        " 开启高亮设置
        hi CursorLine cterm=bold ctermfg=NONE ctermbg=151
        hi CursorLineNr cterm=bold ctermfg=black ctermbg=151
        let g:highlight_enabled = 1
    else
        " 取消高亮设置
        hi CursorLine cterm=bold ctermfg=NONE ctermbg=NONE
        hi CursorLineNr cterm=bold ctermfg=black ctermbg=NONE
        let g:highlight_enabled = 0
    endif
endfunction

" 高亮光标所在列
nnoremap <silent> el :set cursorcolumn!<CR>
" 同时高亮行和列
nnoremap <silent> et :call ToggleHighlight()<CR>:set cursorcolumn!<CR>

" -------------------------------------                    显示Buffer列表并切换/关闭/分屏
" Usage:
"       @bl  : 使用quickfix显示buffer列表,在选项上按Enter即可跳转
"
"       ▶ 进入quickfix后:
"            @按Enter : 切换到对应buffer
"            @c       : 关闭该buffer,可按Tab多选
"            @h       : 水平分屏,可按Tab多选(默认在当前buffer下方打开新水平分屏)
"            @sj      : 在上方水平分屏,可按Tab多选
"            @v       : 垂直分屏,可按Tab多选(默认在当前buffer右侧打开新垂直分屏)
"            @hv      : 在左侧垂直分屏,可按Tab多选
"            @按Tab   : 多选
" Tips:
"       助记: bl=buffer list, 即buffer列表

let g:selected_buffers = []     " 选中的buffer列表

function! SwitchToBuffer()
  " 获取当前行的 buffer 编号
  let bufnr = getqflist()[line('.') - 1].bufnr
  " 检查buffer是否存在
  if buflisted(bufnr)
    " 切换到该 buffer
    let winid = bufwinnr(bufnr)
    if winid != -1
      " 如果 buffer 已经在某个窗口打开，则切换到那个窗口
      execute winid . 'wincmd w'
    endif
    cclose
    execute 'buffer' bufnr
  endif
endfunction

" tab选中的高亮色
hi SelectedBuffer ctermbg=228 ctermfg=1

" 开始一个新的自动命令组
" 关闭guickfix时清空选择的buffer
augroup ClearSelectedBuffers 
  " 清除 ClearSelectedBuffers 组中的所有现有自动命令
  autocmd!                   
  " 监听 quickfix 窗口关闭事件
  autocmd WinClosed * if getwininfo(win_getid())[0].loclist == 0 | let g:selected_buffers = [] | endif
augroup END

function! UpdateQuickfixHighlight()
  let l:qf_list = getqflist()
  " 清除之前的高亮
  call clearmatches()
  for i in range(len(l:qf_list))
    let l:bufnr = l:qf_list[i].bufnr
    if index(g:selected_buffers, l:bufnr) >= 0
      " 为选中的 buffer 添加高亮
      call matchadd('SelectedBuffer', '\V' . escape(l:qf_list[i].text, '\'))
    endif
  endfor
  call setqflist(l:qf_list)
endfunction

function! ToggleSelectBuffer()
  let current_line = line('.')     " 保存当前行号
  let bufnr = getqflist()[current_line - 1].bufnr
  let idx = index(g:selected_buffers, bufnr)
  if idx == -1
    call add(g:selected_buffers, bufnr)
  else
    call remove(g:selected_buffers, idx)
  endif
  call UpdateQuickfixHighlight()
  call cursor(current_line, 1)  " 恢复光标到当前行
endfunction

function! GetTargetBuffer()
  for check_bufnr in range(1, bufnr('$'))
    if buflisted(check_bufnr) && getbufvar(check_bufnr, '&buftype') != 'quickfix' && index(g:selected_buffers, check_bufnr) == -1 && check_bufnr != g:focused_bufnr
      return check_bufnr
    endif
  endfor
  return -1
endfunction

function! FindEmptyNonQuickfixBuffer()
    " 遍历所有 buffer
    for bufnr in range(1, bufnr('$'))
        " 检查 buffer 是否存在
        if bufexists(bufnr)
            " 检查 buffer 名称是否为空
            if bufname(bufnr) == ''
                " 检查 buffer 类型是否为空
                if getbufvar(bufnr, '&buftype') == ''
                    " 检查 buffer 是否未被修改
                    if getbufvar(bufnr, '&modified') == 0
                        " 找到符合条件的 buffer，返回其编号
                        return bufnr
                    endif
                endif
            endif
        endif
    endfor
    " 如果没有找到，返回 0
    return -1
endfunction

function! CloseQFBuffer() abort
    " 遍历所有的 buffer
    for bufnr in range(1, bufnr('$'))
        " 找到quickfix buffer
        if buflisted(bufnr) && getbufvar(bufnr, '&buftype') == 'quickfix'
            " 如果找到符合条件的 buffer，返回其编号
            execute 'bd' bufnr
        endif
    endfor
    " 如果没有找到符合条件的 buffer，返回 -1
    return -1
endfunction

function! HandleFoucsBuffer(bufnr)
  let suitable_bufnr = GetTargetBuffer()
  if suitable_bufnr != -1
    let winid = bufwinnr(suitable_bufnr)
    if winid != -1
      " 如果 buffer 已经在某个窗口打开，则切换到那个窗口
      execute winid . 'wincmd w'
    endif
    execute 'buffer' suitable_bufnr
    execute 'bd' a:bufnr
  else
    " 新建一个空白buffer吸引焦点,避免最后一个聚焦buffer关闭后,焦点聚焦在quickfix上,导致后面代码被阻塞
    enew
    let empty_bufnr = FindEmptyNonQuickfixBuffer()
    if empty_bufnr != -1
        cclose
        execute 'buffer' empty_bufnr
        execute 'Startify'
    endif
    execute 'bd' a:bufnr
    call CloseQFBuffer()
  endif
endfunction

" 检查是否能找到既不是空buffer也不是quickfix buffer的buffer
 function! CheckBuffers() abort
    " 遍历所有的 buffer
    for bufnr in range(1, bufnr('$'))
        " 找到一个不是空buffer 和 quickfix buffer的buffer
        if buflisted(bufnr) && getbufvar(bufnr, '&buftype') != 'quickfix' && len(getbufline(bufnr, 1, '$')) != 0
            " 如果找到符合条件的 buffer，返回其编号
            return 1
        endif
    endfor
    " 如果没有找到符合条件的 buffer，返回 -1
    return -1
endfunction

function! CloseBuffers()
  let current_line = line('.')
  let bufnr = getqflist()[current_line - 1].bufnr

  if !empty(g:selected_buffers)
    " 关闭所有选中的 buffers
    for bufnr in g:selected_buffers
      if buflisted(bufnr)
        " 检查是否关闭了原始聚焦的 buffer
        if bufnr == g:focused_bufnr
          call HandleFoucsBuffer(bufnr)
        else
          execute 'bd' bufnr
        endif
      endif
    endfor
    let g:selected_buffers = []
  else
    " 关闭当前行的 buffer
    if buflisted(bufnr)
      " 检查是否关闭了聚焦的 buffer
      if bufnr == g:focused_bufnr
        call HandleFoucsBuffer(bufnr)
      else
        execute 'bd' bufnr
        execute 'wincmd p'
      endif
    endif
  endif

  if CheckBuffers() == 1
    call ShowBuffersWithActions() " 如果还有其他非quickfix buffer存在,刷新quickfix列表
    call SaveNonQuickfixWindowNR()
  endif
endfunction

function! DoSplit(direction)
  let current_line = line('.')
  let bufnr = getqflist()[current_line - 1].bufnr

  let action =''
  if a:direction == 'v'
      let action = 'vert sb'
  elseif a:direction == 'hv'
      let action = 'vert leftabove sb'
  elseif a:direction == 'h'
      let action = 'sb'
  elseif a:direction == 'sj'
      let action = 'above split | buffer'
  endif

  execute g:last_non_quickfix_window_nr . 'wincmd w'
  if !empty(g:selected_buffers)
    " 分屏所有选中的 buffers
    for bufnr in g:selected_buffers
      if buflisted(bufnr)
        cclose
        execute action bufnr
      endif
    endfor
    let g:selected_buffers = []
  else
    " 分屏当前行的 buffer
    if buflisted(bufnr)
        cclose
        execute action bufnr
    endif
  endif
  call SaveNonQuickfixWindowNR()
endfunction

" 定义一个全局变量来存储窗口编号
let g:last_non_quickfix_window_nr = -2

" 定义一个函数来检查窗口类型并保存窗口 ID
function! SaveNonQuickfixWindowNR()
    " 检查当前窗口是否为 quickfix 窗口
    if &buftype != 'quickfix'
        " 不是 quickfix 窗口，保存窗口 ID
        let g:last_non_quickfix_window_nr = winnr()
    endif
endfunction

function! FocusToWindow()
  " 获取当前行的 buffer 编号
  let bufnr = getqflist()[line('.') - 1].bufnr
  " 检查buffer是否存在
  if buflisted(bufnr)
    " 切换到该 buffer
    let winid = bufwinnr(bufnr)
    if winid != -1
      " 如果 buffer 已经在某个窗口打开，则聚焦到那个窗口
      execute winid . 'wincmd w'
      let file_name = expand('%')
      echo 'Focus on '
      echohl DiffAdd
      echon file_name
      echohl None
      call SaveNonQuickfixWindowNR()
      execute 'wincmd p'
    endif
  endif
endfunction

function! ShowBuffersWithActions()
  " 创建一个列表来存储 buffer 信息
  let buffer_list = []
  let win_buffers = {}
  " 遍历所有窗口，收集窗口中的 buffer 编号
  for winid in range(1, winnr('$'))
    let bufnr = winbufnr(winid)
    if buflisted(bufnr) && getbufvar(bufnr, '&buftype') != 'quickfix'
      let win_buffers[bufnr] = bufname(bufnr)
    endif
  endfor
  " 遍历所有已列出的 buffer
  for bufnr in range(1, bufnr('$'))
    " 过滤掉 quickfix 类型的buffer
    if buflisted(bufnr) && getbufvar(bufnr, '&buftype') != 'quickfix'
      let buffer_name = bufname(bufnr)
      " 确保每个 buffer 只被添加一次
      if !has_key(win_buffers, bufnr)
        let win_buffers[bufnr] = buffer_name
      endif
    endif
  endfor
  " 添加 buffer 信息到列表
  for bufnr in keys(win_buffers)
    " 获取 buffer 的名称
    let buffer_name = win_buffers[bufnr]
    call add(buffer_list, {'filename': buffer_name, 'lnum': 1, 'text': 'Buffer ' . bufnr . ': ' . buffer_name, 'bufnr': bufnr})
  endfor

  " 在进入quickfix窗口之前保存当前聚焦的buffer编号
  let g:focused_bufnr = bufnr('%')

  call SaveNonQuickfixWindowNR()

  " 使用列表设置 quickfix
  call setqflist(buffer_list)
  " 使用 botright 前缀来确保 quickfix 窗口在底部打开
  botright copen

  " 在 quickfix 窗口中设置按键映射
  nnoremap <silent> <buffer> <CR> :call SwitchToBuffer()<CR>
  nnoremap <silent> <buffer> c :call CloseBuffers()<CR>
  nnoremap <silent> <buffer> h :call DoSplit('h')<CR>
  nnoremap <silent> <buffer> sj :call DoSplit('sj')<CR>
  nnoremap <silent> <buffer> v :call DoSplit('v')<CR>
  nnoremap <silent> <buffer> hv :call DoSplit('hv')<CR>
  nnoremap <silent> <buffer> f :call FocusToWindow()<CR>
  nnoremap <silent> <buffer> <Tab> :call ToggleSelectBuffer()<CR>
endfunction

nnoremap <silent> bl :call ShowBuffersWithActions()<CR>:botright copen<CR>


" -------------------------------------                    关闭当前Buffer
" Usage:
"       @er : 关闭当前buffer
" Tips:
"       助记: er=exit buffe_r_, 即退出buffer
nnoremap <silent> er :bd<CR>

" -------------------------------------                    恢复上次窗口布局
" Usage:
"       @wr : 恢复上次窗口布局
" Tips:
"       助记: wr=windows recover, 窗口恢复
" 保存当前布局到 session 文件
function! SaveSession()
    execute 'mksession! ~/.config/nvim/session/winrecord.vim'
endfunction

" 恢复 session 文件中的布局
function! RestoreSession()
    if filereadable(expand('~/.config/nvim/session/winrecord.vim'))
        execute 'source ~/.config/nvim/session/winrecord.vim'
    endif
endfunction

" 在离开任何窗口时自动保存 session
autocmd WinLeave * call SaveSession()

nnoremap <silent> wr :call RestoreSession()<CR>

" -------------------------------------                    新建tab/buffer
" Usage:
"       @nt  : 新建tab,nt=new tab
"       @nb  : 新建空白buffer,nb=new buffer
nnoremap <silent> nt :tabnew<CR>

" -------------------------------------                    进入命令行模式
" Usage:
"       @md : 进入vim命令行模式
" Tips:
"       @助记: md=com'm'an'd'
nnoremap md :

" -------------------------------------                    文件重命名
" Note: 使用echon替代echo来连续输出文本,而不会自动添加新行。
"       echohl用于设置接下来的文本高亮,直到遇到echohl None
"       重置为默认格式
" Usage:
"       @nr : 文件重命名
" Tips: 
"       助记: nr=_n_ame _r_ename,即名字重命名
function! RenameFile()
    let old_name = expand('%')
    let new_name = input('Enter new filename: ', expand('%'))
    if new_name != '' && new_name != old_name
        exec ':w'  
        exec ':saveas ' . new_name
        exec ':bd!' . bufnr(old_name)  
        exec ':silent !rm ' . shellescape(old_name, 1) 
        redraw!
        " 使用 echon 和 echohl 在一行内显示所有信息，并对特定部分高亮
        echo 'File renamed from '
        echohl Search
        echon old_name
        echohl None
        echon ' to '
        echohl DiffAdd
        echon new_name
        echohl None
    else
        echo 'Rename cancelled.'
    endif
endfunction

nnoremap nr :call RenameFile()<CR>

" -------------------------------------                    返回上一次光标所在行
" Usage:
"       @lr : 返回上一次光标所在行
" Tips:
"       助记: lr=line recover, 即行恢复
" 定义一个函数，用于跳转到上一次光标所在的行
function! GoToLastCursorPosition()
    normal ``
endfunction

" 将 lr 键映射到这个函数
nnoremap lr :call GoToLastCursorPosition()<CR>


" vim 配色笔记
" =============================================================================
" vim 终端背景三元色(RGB):
"       红:226
"       绿:240
"       蓝:218

" Vim识别三种不同的终端：
"       @term——黑白终端；
"       @cterm——彩色终端；
"       @gui——Gvim窗口
" 对于cterm:
"       cterm可以用ctermfg设置前景色；用ctermbg设置背景色, 用cterm设置字体
" 可用颜色:
"       cterm-colors + 256色, cterm-colors如下:
" -------------------------------------                    cterm-colors
"       NR-16   NR-8    COLOR NAME ~
"	    0	    0	    Black
"	    1	    4	    DarkBlue
"	    2	    2	    DarkGreen
"	    3	    6	    DarkCyan
"	    4	    1	    DarkRed
"	    5	    5	    DarkMagenta
"	    6	    3	    Brown, DarkYellow
"	    7	    7	    LightGray, LightGrey, Gray, Grey
"	    8	    0*	    DarkGray, DarkGrey
"	    9	    4*	    Blue, LightBlue
"	    10	    2*	    Green, LightGreen
"	    11	    6*	    Cyan, LightCyan
"	    12	    1*	    Red, LightRed
"	    13	    5*	    Magenta, LightMagenta
"	    14	    3*	    Yellow, LightYellow
"	    15	    7*	    White

" tips:
"       1、想修改vim某个地方的颜色, 或者自定义配置的颜色不生效, 可以
"          使用:highlight命令列出当前vim所有高亮配色, 从中找到相近颜
"          色的配置项在.vimrc中进行修改, 如果修改没有生效,找到修改该
"          配置项的插件, 然后在 .vim/after 下新建一个同名的插件,例如
"          xxx.vim,将配色方案写在该文件中,vim在运行时会最后加载该目录的插件

" vim 快捷键映射模式说明
" =============================================================================
" Note: 快捷键映射插件操作的语法解释
"       @ nmap 和 nnoremap 的区别在于:
"               nmap:     会将键映射应用到 Normal、Visual、Select 和 Operator-pending 
"                         模式，可能会导致意外的行为，因为它会递归地展开键映射。
"               nnoremap: 只会将键映射应用到 Normal 模式，不会展开其他键
"                         映射，避免了潜在的问题


" vim tips
" =============================================================================
" 1. 查看vim映射键组合是否有其他绑定,使用verbose map命令, 例如查看a有哪些映射绑定:
"       :verbose map a (加上verbose可以显示映射操作最后是由谁执行的)
" 2. 查看当前的快捷键所绑定的函数,使用map命令,例如查看,h所绑定的函数:
"       :map ,h
" 3. Q: vim 如何修改原有的插件映射?
"    A: 使用verbose map命令查看原映射对应的插件函数,然后直接把插件函数原封不动放在新的映射命令后面即可
"       (1) 例如, 有映射如下:
"               n gs <Plug>(scratch-insert-reuse)
"           现在想修改gs,换成新的映射命令,直接将gs后面的映射函数放在新的映射命令后面即可,如下:
"               nnoremap ab <Plug>(scratch-insert-reuse)
"       (2) 例如, 有映射如下:
"               n dm * :<C-U>call signature#mark#Purge("line")<CR>
"           现在想修改gs,换成新的映射命令:
"               nnoremap md :<C-U>call signature#mark#Purge("line")<CR>
"               
" 4. vim 查看全局变量的值，例如查看g:scratch_height的值:
"       :echo g:scratch_height
" 5. vim查看用set设置的某个选项的值, 例如查看signcolum的值:
"       :set signcolumn?
" 6. vim 查看某个内容的帮助信息,使用h命令,后面跟要查询的内容,如下:
"       :h g:scratch_height
" 7. vim 查看某个插件的帮助信息,h命令后跟插件名字,如下:
"       :h tagbar
" 8. 查看sign column里所有标记的信息
"       :sign list
" 9. Q: vim如何查看高亮组名称?
"    A: 将光标移动到要查看的位置,然后使用如下vim命令查看:
"       :echo synIDattr(synID(line('.'), col('.'), 1), 'name')
" 10.Q: vim如何查看高亮组颜色配置方案?
"    A: hi name(高亮组名字)
" 11.Q: 如何查看是哪个文件最后设置了这个高亮组?
"    A: :verbose highlight Pmenu
" 12.Q: vim如何查看帮助文件txt文本中标题部分的内容?
"    A: ctr+]转到标题对应部分(已自定义映射为en),ctrl+t返回(已自定义映射为ne)
nnoremap <silent> en <C-]>
    " Tips: en=enter, 即进入
nnoremap <silent> ne <C-t>
" 13.Q: vim有些高亮组link到了其他高亮组,自定义配色无法生效
"    A: 在Vim中,如果一个高亮组通过links命令链接到了另一个高亮组,那么
"       它会继承被链接高亮组的所有属性, 如果你尝试直接修改ColorA的颜
"       色,而它已经链接到了ColorB, 修改将不会生效, 因为LineNrBelow的
"       颜色和属性会被 LineNr 的设置覆盖。
"       [解决方法]: 要修改ColorA的颜色,需要先断开它与ColorB的链接,然
"       后再应用新的颜色设置。通过在init.vim 文件中添加以下命令来实现: 
"       (1) 首先断开ColorA与ColorB的链接
"               highlight! link ColorA NONE
"       (2) 然后设置ColorA的颜色
"               highlight ColorA ctermfg=red ctermbg=black
" 14.Q: vim如何查看当前buffer的编号?
"    A: :echo bufnr('%')
" 15.Q: vim如何查看当前窗口的类型?
"    A: echo &buftype
"       普通buffer为空,quickfix窗口为'quickfix'
" 16.Q: vim如何查看当前窗口id?
"    A: echo win_getid() 
" 17.Q: vim如何查看编号?
"    A: echo winnr()
" 18.Q: 查看buffer的窗口编号
"    A: echo bufwinnr(bufnr), bufnr为buffer编号




let g:org_agenda_files=['~/org/index.org']

" airline_x_inactive xxx ctermfg=59 ctermbg=23 guifg=#4e4e4e guibg=#002b2b
" airline_x_inactive_bold xxx cterm=bold ctermfg=59 ctermbg=23 gui=bold guifg=#4e4e4e guibg=#002b2b
" airline_x_inactive_red xxx ctermfg=231 ctermbg=23 guifg=#ffffff guibg=#002b2b
" airline_y_inactive xxx ctermfg=59 ctermbg=23 guifg=#4e4e4e guibg=#002b2b
" airline_y_inactive_bold xxx cterm=bold ctermfg=59 ctermbg=23 gui=bold guifg=#4e4e4e guibg=#002b2b
" airline_y_inactive_red xxx ctermfg=231 ctermbg=23 guifg=#ffffff guibg=#002b2b
" airline_z_inactive xxx ctermfg=59 ctermbg=23 guifg=#4e4e4e guibg=#002b2b
" airline_z_inactive_bold xxx cterm=bold ctermfg=59 ctermbg=23 gui=bold guifg=#4e4e4e guibg=#002b2b
" airline_z_inactive_red xxx ctermfg=231 ctermbg=23 guifg=#ffffff guibg=#002b2b
" airline_term_inactive xxx ctermfg=85 ctermbg=232 guifg=#9cffd3 guibg=#202020
" airline_term_inactive_bold xxx cterm=bold ctermfg=85 ctermbg=232 gui=bold guifg=#9cffd3 guibg=#202020
" airline_term_inactive_red xxx ctermfg=231 ctermbg=232 guifg=#ffffff guibg=#202020
" airline_error_inactive xxx ctermfg=232 ctermbg=160 guifg=#000000 guibg=#990000
" airline_error_inactive_bold xxx cterm=bold ctermfg=232 ctermbg=160 gui=bold guifg=#000000 guibg=#990000
" airline_error_inactive_red xxx ctermfg=231 ctermbg=160 guifg=#ffffff guibg=#990000
" airline_a_inactive xxx ctermfg=59 ctermbg=23 guifg=#4e4e4e guibg=#002b2b
" airline_a_inactive_bold xxx cterm=bold ctermfg=59 ctermbg=23 gui=bold guifg=#4e4e4e guibg=#002b2b
" airline_a_inactive_red xxx ctermfg=231 ctermbg=23 guifg=#ffffff guibg=#002b2b
" airline_b_inactive xxx ctermfg=59 ctermbg=23 guifg=#4e4e4e guibg=#002b2b
" airline_b_inactive_bold xxx cterm=bold ctermfg=59 ctermbg=23 gui=bold guifg=#4e4e4e guibg=#002b2b
" airline_b_inactive_red xxx ctermfg=231 ctermbg=23 guifg=#ffffff guibg=#002b2b
" airline_c_inactive xxx ctermfg=59 ctermbg=23 guifg=#4e4e4e guibg=#002b2b
" airline_c_inactive_bold xxx cterm=bold ctermfg=59 ctermbg=23 gui=bold guifg=#4e4e4e guibg=#002b2b
" airline_c_inactive_red xxx ctermfg=231 ctermbg=23 guifg=#ffffff guibg=#002b2b




" 加载 Tree-sitter Context 插件配置
lua <<EOF
require'treesitter-context'.setup{
  enable = true,
  max_lines = 0,
  min_window_height = 0,
  line_numbers = true,
  multiline_threshold = 20,
  trim_scope = 'outer',
  mode = 'cursor',
  separator = nil,
  zindex = 20,
  on_attach = nil,
}
EOF
        




" 在状态栏显示当前光标位置的语法结构，基于 Tree-sitter 的解析树。这里的 90 是一个参数，表示状态栏显示的最大长度（单位为字符）
" 参数 90 指定了状态栏信息的最大长度。这意味着无论语法结构的实际长度如何，显示在状态栏的字符串将被截断，不超过90个字符
" echo nvim_treesitter#statusline(90) " 90 can be any length
" module->expression_statement->call->identifier




